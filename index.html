<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#020010">
    <title>AROA - A Road Of Adventure</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üöÄ</text></svg>">
    <style>
/* ========================================
   AROA - Global Styles
======================================== */
*, *::before, *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

:root {
    --bg-dark: #020010;
    --bg-surface: #0a0a1a;
    --primary: #4fc3f7;
    --secondary: #ab47bc;
    --accent: #ffd700;
    --success: #44ff88;
    --danger: #ff4466;
    --text: #e8e8ff;
    --text-muted: #888;
    --border: rgba(79, 195, 247, 0.3);
    --safe-top: env(safe-area-inset-top, 0px);
    --safe-bottom: env(safe-area-inset-bottom, 0px);
}

html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: var(--bg-dark);
    color: var(--text);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    touch-action: none;
    position: fixed;
    -webkit-tap-highlight-color: transparent;
    -webkit-user-select: none;
    user-select: none;
}

#app {
    position: fixed;
    inset: 0;
    overflow: hidden;
    z-index: 100;
}

#game-container {
    position: fixed;
    inset: 0;
    z-index: 1;
}

/* ========================================
   Common Components
======================================== */
.btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 14px 32px;
    border: none;
    border-radius: 30px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
    font-family: inherit;
}
.btn:active { transform: scale(0.96); }
.btn-primary {
    background: linear-gradient(135deg, var(--primary), #2196f3);
    color: #fff;
    box-shadow: 0 4px 20px rgba(33, 150, 243, 0.4);
}
.btn-primary:hover {
    box-shadow: 0 6px 25px rgba(33, 150, 243, 0.6);
    transform: translateY(-2px);
}
.btn-secondary {
    background: linear-gradient(135deg, var(--secondary), #7b1fa2);
    color: #fff;
}
.btn-outline {
    background: transparent;
    color: var(--text);
    border: 1px solid var(--border);
}
.btn-ghost {
    background: rgba(255,255,255,0.1);
    color: var(--text);
}
.btn-block { width: 100%; }
.btn-sm { padding: 10px 20px; font-size: 0.9rem; }

/* Page Layout */
.page-center {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 24px;
    padding-top: calc(24px + var(--safe-top));
    padding-bottom: calc(24px + var(--safe-bottom));
}
.page-content {
    max-width: 400px;
    width: 100%;
    text-align: center;
}
.page-icon {
    font-size: 4rem;
    margin-bottom: 16px;
    animation: float 3s ease-in-out infinite;
}
@keyframes float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

/* ========================================
   Title Screen Styles
======================================== */
.title-screen {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 20px;
    padding-top: env(safe-area-inset-top, 20px);
    padding-bottom: env(safe-area-inset-bottom, 20px);
}

.logo-section {
    text-align: center;
    margin-bottom: 50px;
}

.logo-icon {
    font-size: 60px;
    margin-bottom: 10px;
    animation: float 3s ease-in-out infinite;
}

.logo-title {
    font-size: 52px;
    font-weight: bold;
    background: linear-gradient(135deg, #4fc3f7 0%, #ab47bc 50%, #ff6b9d 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    letter-spacing: 8px;
    margin-bottom: 8px;
    animation: glow 2s ease-in-out infinite alternate;
}

@keyframes glow {
    from { filter: drop-shadow(0 0 10px rgba(79, 195, 247, 0.5)); }
    to { filter: drop-shadow(0 0 20px rgba(171, 71, 188, 0.8)); }
}

.logo-subtitle {
    font-size: 14px;
    color: #888;
    letter-spacing: 3px;
    text-transform: uppercase;
}

.button-section {
    width: 100%;
    max-width: 300px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-bottom: 40px;
}

.login-btn {
    width: 100%;
    padding: 16px 24px;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    font-family: inherit;
}

.login-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    transition: left 0.5s ease;
}

.login-btn:hover::before {
    left: 100%;
}

.login-btn:active {
    transform: scale(0.98);
}

.btn-google {
    background: #ffffff;
    color: #333;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}

.btn-google:hover {
    box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    transform: translateY(-2px);
}

.google-icon {
    width: 20px;
    height: 20px;
}

.btn-guest {
    background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
    color: #fff;
    border: 1px solid rgba(255,255,255,0.2);
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}

.btn-guest:hover {
    background: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.08) 100%);
    border-color: rgba(255,255,255,0.3);
    transform: translateY(-2px);
}

.settings-section {
    position: absolute;
    bottom: calc(env(safe-area-inset-bottom, 20px) + 60px);
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 30px;
}

.setting-btn {
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    color: #fff;
    padding: 10px 16px;
    border-radius: 25px;
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: all 0.3s ease;
    font-family: inherit;
}

.setting-btn:hover {
    background: rgba(255,255,255,0.15);
    border-color: rgba(255,255,255,0.3);
}

.setting-btn:active {
    transform: scale(0.95);
}

.version-info {
    position: absolute;
    bottom: calc(env(safe-area-inset-bottom, 10px) + 20px);
    left: 50%;
    transform: translateX(-50%);
    color: #444;
    font-size: 11px;
}

/* Guest Warning Modal */
.guest-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.7);
    z-index: 200;
    display: none;
    justify-content: center;
    align-items: center;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.guest-modal-overlay.show {
    display: flex;
    opacity: 1;
}

.guest-modal-content {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 20px;
    padding: 30px;
    width: 90%;
    max-width: 320px;
    text-align: center;
    transform: scale(0.9);
    transition: transform 0.3s ease;
}

.guest-modal-overlay.show .guest-modal-content {
    transform: scale(1);
}

.warning-icon {
    font-size: 50px;
    margin-bottom: 15px;
    animation: shake 0.5s ease-in-out;
}

@keyframes shake {
    0%, 100% { transform: rotate(0deg); }
    25% { transform: rotate(-10deg); }
    75% { transform: rotate(10deg); }
}

.warning-title {
    color: #ffcc00;
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 20px;
}

.warning-text {
    color: #ccc;
    font-size: 14px;
    line-height: 1.8;
    margin-bottom: 25px;
}

.warning-text strong {
    color: #ff6b6b;
}

.warning-buttons {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.warning-btn {
    width: 100%;
    padding: 14px 20px;
    border: none;
    border-radius: 10px;
    font-size: 15px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: inherit;
}

.warning-btn:active {
    transform: scale(0.98);
}

.btn-recommend {
    background: linear-gradient(135deg, #4fc3f7 0%, #2196f3 100%);
    color: #fff;
    box-shadow: 0 4px 15px rgba(33, 150, 243, 0.4);
}

.btn-recommend:hover {
    box-shadow: 0 6px 20px rgba(33, 150, 243, 0.6);
    transform: translateY(-2px);
}

.btn-continue {
    background: rgba(255,255,255,0.1);
    color: #888;
    border: 1px solid rgba(255,255,255,0.1);
}

.btn-continue:hover {
    background: rgba(255,255,255,0.15);
    color: #aaa;
}

/* Language Modal */
.lang-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.7);
    z-index: 200;
    display: none;
    justify-content: center;
    align-items: center;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.lang-modal-overlay.show {
    display: flex;
    opacity: 1;
}

.lang-modal-content {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 20px;
    padding: 30px;
    width: 90%;
    max-width: 320px;
    transform: scale(0.9);
    transition: transform 0.3s ease;
}

.lang-modal-overlay.show .lang-modal-content {
    transform: scale(1);
}

.lang-modal-title {
    color: #fff;
    font-size: 20px;
    font-weight: 600;
    text-align: center;
    margin-bottom: 25px;
}

.language-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.language-btn {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    color: #fff;
    padding: 14px 20px;
    border-radius: 10px;
    font-size: 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 12px;
    transition: all 0.3s ease;
    font-family: inherit;
}

.language-btn:hover {
    background: rgba(79, 195, 247, 0.2);
    border-color: rgba(79, 195, 247, 0.5);
}

.language-btn.active {
    background: linear-gradient(135deg, rgba(79, 195, 247, 0.3) 0%, rgba(171, 71, 188, 0.3) 100%);
    border-color: #4fc3f7;
}

.language-btn .flag {
    font-size: 24px;
}

.lang-modal-close {
    margin-top: 20px;
    width: 100%;
    padding: 14px;
    background: rgba(255,255,255,0.1);
    border: none;
    border-radius: 10px;
    color: #888;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: inherit;
}

.lang-modal-close:hover {
    background: rgba(255,255,255,0.15);
    color: #fff;
}

/* PC Î∞òÏùëÌòï */
@media (min-width: 769px) {
    .logo-title {
        font-size: 72px;
        letter-spacing: 12px;
    }
    .logo-subtitle {
        font-size: 16px;
        letter-spacing: 5px;
    }
    .logo-icon {
        font-size: 80px;
    }
    .button-section {
        max-width: 350px;
    }
    .login-btn {
        padding: 18px 28px;
        font-size: 17px;
    }
}

.page-title {
    font-size: 1.5rem;
    font-weight: bold;
    margin-bottom: 20px;
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}
.page-text {
    font-size: 1rem;
    line-height: 1.9;
    color: var(--text-muted);
    margin-bottom: 30px;
}
.page-text .hl { color: var(--primary); font-weight: 500; }
.page-text .gold { color: var(--accent); }
.page-text .danger { color: var(--danger); }

/* Dots Indicator */
.dots {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-bottom: 25px;
}
.dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: rgba(255,255,255,0.2);
    transition: all 0.3s;
}
.dot.active {
    background: var(--primary);
    width: 24px;
    border-radius: 4px;
}
.dot.done { background: rgba(255,255,255,0.4); }

/* Dice */
.dice-box {
    width: 140px;
    height: 140px;
    margin: 24px auto;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 4rem;
    background: rgba(255,255,255,0.05);
    border: 2px solid var(--border);
    border-radius: 20px;
    transition: all 0.3s;
}
.dice-box.rolling { animation: shake 0.1s linear infinite; }
@keyframes shake {
    0%, 100% { transform: rotate(0deg) scale(1); }
    25% { transform: rotate(-10deg) scale(1.05); }
    50% { transform: rotate(10deg) scale(0.95); }
    75% { transform: rotate(-5deg) scale(1.02); }
}

.env-ranges {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin: 20px 0;
    font-size: 0.75rem;
}
.env-range {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 10px;
    background: rgba(255,255,255,0.05);
    border-radius: 8px;
    color: var(--text-muted);
}

.dice-result { margin: 20px 0; min-height: 100px; }
.result-icon { font-size: 3rem; margin-bottom: 8px; }
.result-name { font-size: 1.3rem; font-weight: bold; color: var(--primary); margin-bottom: 6px; }
.result-desc { font-size: 0.9rem; color: var(--text-muted); margin-bottom: 4px; }
.result-weak { font-size: 0.8rem; color: var(--danger); }

/* Skip Button */
.skip-btn {
    position: absolute;
    top: calc(var(--safe-top) + 15px);
    right: 20px;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    color: var(--text-muted);
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 13px;
    cursor: pointer;
    z-index: 200;
    transition: all 0.3s;
}
.skip-btn:hover { background: rgba(255,255,255,0.15); color: #aaa; }

/* ========================================
   Game HUD
======================================== */
.hud-top {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 50;
    padding: 12px 16px;
    padding-top: calc(12px + var(--safe-top));
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    pointer-events: none;
}
.hud-top > * { pointer-events: auto; }

.hud-panel {
    background: rgba(0, 20, 40, 0.85);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 10px 14px;
    backdrop-filter: blur(8px);
}
.hud-name { font-size: 0.75rem; color: var(--primary); margin-bottom: 6px; font-weight: 600; }
.hud-row { display: flex; align-items: center; gap: 6px; font-size: 0.8rem; margin-bottom: 4px; }
.hud-val { font-weight: 700; color: var(--accent); }
.hud-label { color: var(--text-muted); font-size: 0.65rem; }

.size-bar { display: flex; align-items: center; gap: 6px; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); }
.size-track { flex: 1; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; }
.size-fill { height: 100%; background: linear-gradient(90deg, var(--primary), var(--accent)); border-radius: 3px; transition: width 0.3s; }
.size-num { font-size: 0.7rem; color: var(--text-muted); min-width: 24px; text-align: right; }

.parts-panel { max-width: 140px; }
.parts-title { font-size: 0.65rem; color: var(--text-muted); margin-bottom: 6px; }
.parts-grid { display: flex; flex-wrap: wrap; gap: 4px; }
.part-badge { display: flex; align-items: center; gap: 2px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; padding: 3px 6px; font-size: 0.7rem; }
.part-badge.active { border-color: var(--primary); box-shadow: 0 0 8px rgba(79, 195, 247, 0.3); }
.part-cnt { font-size: 0.6rem; color: var(--accent); }

.progress-section { margin-top: 8px; }
.progress-label { display: flex; justify-content: space-between; font-size: 0.6rem; margin-bottom: 3px; }
.progress-left { color: var(--text-muted); }
.progress-right { color: var(--primary); }
.progress-track { height: 5px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; }
.progress-fill { height: 100%; border-radius: 3px; transition: width 0.3s; }
.progress-fill.evo { background: linear-gradient(90deg, var(--primary), var(--secondary)); }
.progress-fill.stage { background: linear-gradient(90deg, var(--secondary), var(--danger)); }

.hud-btns { display: flex; gap: 8px; }
.hud-btn { width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; background: rgba(0, 20, 40, 0.9); border: 1px solid var(--border); border-radius: 10px; font-size: 1.1rem; cursor: pointer; transition: all 0.2s; }
.hud-btn:hover { border-color: var(--primary); box-shadow: 0 0 10px rgba(79, 195, 247, 0.3); }

.hud-bottom {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 40;
    padding: 12px 16px;
    padding-bottom: calc(100px + var(--safe-bottom));
    pointer-events: none;
}
.stage-bar { background: rgba(0, 20, 40, 0.9); border: 1px solid rgba(171, 71, 188, 0.3); border-radius: 12px; padding: 10px 14px; backdrop-filter: blur(8px); }
.stage-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
.stage-cur { font-size: 0.75rem; color: var(--secondary); font-weight: 600; }
.stage-next { font-size: 0.65rem; color: var(--text-muted); }

/* Controls */
.controls {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 60;
    padding: 16px 24px;
    padding-bottom: calc(16px + var(--safe-bottom));
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    pointer-events: none;
}
.controls > * { pointer-events: auto; }

.joystick { position: relative; width: 120px; height: 120px; opacity: 0.6; transition: opacity 0.2s; }
.joystick:active, .joystick.active { opacity: 1; }
.joy-base { position: absolute; inset: 0; background: rgba(0, 20, 40, 0.5); border: 2px solid rgba(79, 195, 247, 0.4); border-radius: 50%; }
.joy-knob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; margin: -25px 0 0 -25px; background: linear-gradient(135deg, var(--primary), #2196f3); border-radius: 50%; box-shadow: 0 0 20px rgba(79, 195, 247, 0.5); transition: transform 0.05s; }

.action-btn { width: 75px; height: 75px; display: flex; align-items: center; justify-content: center; background: rgba(0, 20, 40, 0.6); border: 2px solid var(--primary); border-radius: 50%; font-size: 1.6rem; cursor: pointer; box-shadow: 0 0 25px rgba(79, 195, 247, 0.3); opacity: 0.6; transition: all 0.2s; }
.action-btn:hover { opacity: 0.9; }
.action-btn:active { transform: scale(0.92); opacity: 1; box-shadow: 0 0 35px rgba(79, 195, 247, 0.6); }
.action-btn.disabled { opacity: 0.3; pointer-events: none; }

/* Evolution Popup */
.evo-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    z-index: 200;
    background: rgba(0, 20, 40, 0.98);
    border: 2px solid var(--primary);
    border-radius: 20px;
    padding: 30px 40px;
    text-align: center;
    opacity: 0;
    pointer-events: none;
    transition: all 0.4s;
    box-shadow: 0 0 50px rgba(79, 195, 247, 0.5);
}
.evo-popup.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
.evo-icon { font-size: 4rem; margin-bottom: 12px; animation: float 2s ease-in-out infinite; }
.evo-title { font-size: 1.4rem; font-weight: bold; color: var(--primary); margin-bottom: 8px; }
.evo-desc { color: var(--text-muted); font-size: 0.9rem; margin-bottom: 6px; }
.evo-fx { color: var(--accent); font-size: 0.85rem; font-weight: 600; }

/* Modal */
.modal {
    position: fixed;
    inset: 0;
    z-index: 300;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0, 10, 20, 0.95);
    padding: 24px;
}
.modal.show { display: flex; }
.modal-box { background: rgba(0, 30, 60, 0.95); border: 1px solid var(--border); border-radius: 20px; padding: 32px 28px; max-width: 340px; width: 100%; text-align: center; }
.modal-icon { font-size: 4rem; margin-bottom: 16px; }
.modal-title { font-size: 1.5rem; font-weight: bold; margin-bottom: 12px; }
.modal-title.fail { background: linear-gradient(135deg, #ff6b6b, var(--danger)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.modal-title.win { background: linear-gradient(135deg, var(--primary), var(--accent)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.modal-desc { color: var(--text-muted); font-size: 0.95rem; margin-bottom: 24px; line-height: 1.6; }
.modal-stats { background: rgba(0, 20, 40, 0.5); border-radius: 12px; padding: 14px; margin-bottom: 20px; }
.stat-row { display: flex; justify-content: space-between; padding: 6px 0; }
.stat-row:not(:last-child) { border-bottom: 1px solid rgba(255,255,255,0.1); }
.stat-label { color: var(--text-muted); font-size: 0.85rem; }
.stat-val { font-weight: 700; color: var(--primary); }
.modal-btns { display: flex; flex-direction: column; gap: 10px; }

/* Loading */
#loading {
    position: fixed;
    inset: 0;
    background: var(--bg-dark);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 500;
    transition: opacity 0.5s;
}
#loading.fade-out { opacity: 0; pointer-events: none; }
.spinner { width: 50px; height: 50px; border: 3px solid rgba(255,255,255,0.1); border-top-color: var(--primary); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
@keyframes spin { to { transform: rotate(360deg); } }
#loading p { color: var(--text-muted); font-size: 14px; }

/* Language Modal */
.lang-modal {
    position: fixed;
    inset: 0;
    z-index: 400;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.8);
    padding: 24px;
}
.lang-modal.show { display: flex; }
.lang-options { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-top: 20px; }
.lang-btn { padding: 16px; background: rgba(255,255,255,0.05); border: 1px solid var(--border); border-radius: 12px; font-size: 1.1rem; cursor: pointer; transition: all 0.2s; }
.lang-btn:hover { border-color: var(--primary); background: rgba(79, 195, 247, 0.1); }
.lang-btn.active { border-color: var(--primary); background: rgba(79, 195, 247, 0.2); }

/* Phase 4 Ïö∞Ï£ºÏÑºÌÑ∞ Ïä§ÌÉÄÏùº */
.space-job-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 15px 10px;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s;
    color: #fff;
}
.space-job-btn:hover:not(.locked) {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}
.space-job-btn:active:not(.locked) {
    transform: translateY(0);
}
.space-job-btn.locked {
    cursor: not-allowed;
}
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <p>Loading AROA...</p>
    </div>
    
    <div id="game-container"></div>
    <div id="app"></div>
    
    <!-- Evolution Popup -->
    <div class="evo-popup" id="evo-popup">
        <div class="evo-icon" id="evo-icon">üß¨</div>
        <div class="evo-title" id="evo-title">ÏßÑÌôî!</div>
        <div class="evo-desc" id="evo-desc"></div>
        <div class="evo-fx" id="evo-fx"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    
    <script>
// ========================================
// AROA - Configuration
// ========================================
const CONFIG = {
    // Phase 1
    GROWTH_THRESHOLD: 15,
    STAGE_THRESHOLD: 2000,
    INITIAL_SIZE: 12,
    MAX_SIZE: 80,
    MAX_FOODS: 40,
    MAX_ENEMIES: 8,
    ENEMY_SPAWN_INTERVAL: 3000,
    DASH_COOLDOWN: 2500,
    DASH_DURATION: 200,
    DASH_SPEED: 18,
    
    // Phase 2
    P2_GRAVITY: 0.6,
    P2_JUMP_FORCE: -14,
    P2_MOVE_SPEED: 5,
    P2_PLATFORM_SPEED: 2,
    P2_STAGE_THRESHOLD: 3000,
    P2_PART_THRESHOLD: 500,
    
    // Phase 3
    P3_STAGE_DIST: [300, 350, 400, 450, 500], // Í∞Å Ïä§ÌÖåÏù¥ÏßÄÎ≥Ñ Î™©Ìëú Í±∞Î¶¨
    P3_BASE_SPEED: 2.5,
    P3_GRAVITY: 0.7,
    P3_JUMP_POWER: -15,
    P3_OBSTACLE_GAP: 1800,
    P3_GOAL_DIST: 1500 // ÏµúÏ¢Ö Î™©Ìëú Í±∞Î¶¨
};

// ========================================
// Ìö®Í≥ºÏùå ÏãúÏä§ÌÖú (Web Audio API)
// ========================================
const SFX = {
    ctx: null,
    enabled: true,
    
    init() {
        if (this.ctx) return;
        try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.log('Web Audio not supported');
            this.enabled = false;
        }
    },
    
    resume() {
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },
    
    play(type) {
        if (!this.enabled || !this.ctx) return;
        this.resume();
        
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        switch(type) {
            case 'jump':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
                break;
                
            case 'land':
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(80, now + 0.08);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
                break;
                
            case 'eat':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.05);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                osc.start(now);
                osc.stop(now + 0.08);
                break;
                
            case 'hit':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.15);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
                break;
                
            case 'coin':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, now);
                osc.frequency.setValueAtTime(1100, now + 0.05);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
                break;
                
            case 'evolve':
                // ÏßÑÌôî ÏÇ¨Ïö¥Îìú (ÏÉÅÏäπÏùå)
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.exponentialRampToValueAtTime(900, now + 0.3);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
                // Ï∂îÍ∞Ä ÌôîÏùå
                const osc2 = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();
                osc2.connect(gain2);
                gain2.connect(this.ctx.destination);
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(450, now + 0.1);
                osc2.frequency.exponentialRampToValueAtTime(1200, now + 0.4);
                gain2.gain.setValueAtTime(0.08, now + 0.1);
                gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc2.start(now + 0.1);
                osc2.stop(now + 0.5);
                break;
                
            case 'clear':
                // ÌÅ¥Î¶¨Ïñ¥ Ìå°ÌååÎ†à
                [0, 0.1, 0.2, 0.3].forEach((delay, i) => {
                    const o = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    o.connect(g);
                    g.connect(this.ctx.destination);
                    o.type = 'sine';
                    const freqs = [523, 659, 784, 1047]; // C5, E5, G5, C6
                    o.frequency.setValueAtTime(freqs[i], now + delay);
                    g.gain.setValueAtTime(0.12, now + delay);
                    g.gain.exponentialRampToValueAtTime(0.01, now + delay + 0.3);
                    o.start(now + delay);
                    o.stop(now + delay + 0.3);
                });
                break;
                
            case 'gameover':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.4);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
                break;
                
            case 'bounce':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(250, now);
                osc.frequency.exponentialRampToValueAtTime(500, now + 0.08);
                osc.frequency.exponentialRampToValueAtTime(300, now + 0.15);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
                osc.start(now);
                osc.stop(now + 0.18);
                break;
                
            case 'dash':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
                break;
                
            case 'powerup':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
                osc.start(now);
                osc.stop(now + 0.25);
                break;
                
            case 'click':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
                break;
                
            case 'dice':
                // Ï£ºÏÇ¨ÏúÑ Íµ¥Î¶¨Îäî ÏÜåÎ¶¨ (ÎûúÎç§Ìïú Îî∏ÍπçÎî∏Íπç)
                for (let i = 0; i < 8; i++) {
                    const o = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    o.connect(g);
                    g.connect(this.ctx.destination);
                    o.type = 'square';
                    const delay = i * 0.06;
                    const freq = 200 + Math.random() * 300;
                    o.frequency.setValueAtTime(freq, now + delay);
                    g.gain.setValueAtTime(0.08, now + delay);
                    g.gain.exponentialRampToValueAtTime(0.01, now + delay + 0.04);
                    o.start(now + delay);
                    o.stop(now + delay + 0.05);
                }
                break;
                
            case 'fall':
                // Ï∂îÎùΩ ÏÜåÎ¶¨
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
                break;
        }
    }
};

// ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Ïò§ÎîîÏò§ Ïª®ÌÖçÏä§Ìä∏ Ï¥àÍ∏∞Ìôî
document.addEventListener('click', () => SFX.init(), { once: true });
document.addEventListener('touchstart', () => SFX.init(), { once: true });

// Î∞∞Í≤Ω Ï†ÑÌôò Íµ¨Í∞Ñ Ï†ïÏùò (Ïó∞ÏÜç ÏßÑÌñâ)
const BG_ZONES = [
    { start: 0, end: 300, id: 'primitive', name: 'ü¶é ÏõêÏãú Ïú°ÏßÄ',
      sky: ['#87CEEB', '#E0F7FA'], ground: '#8B7355' },
    { start: 300, end: 600, id: 'dinosaur', name: 'ü¶ñ Í≥µÎ£° ÏãúÎåÄ',
      sky: ['#FF8C00', '#FFD700'], ground: '#8B4513' },
    { start: 600, end: 900, id: 'ice', name: 'üßä ÎπôÌïòÍ∏∞',
      sky: ['#B0E0E6', '#E6F3FF'], ground: '#E8E8E8' },
    { start: 900, end: 1200, id: 'human', name: 'üßç ÏõêÏãúÏù∏',
      sky: ['#87CEEB', '#F0E68C'], ground: '#D2B48C' },
    { start: 1200, end: 9999, id: 'modern', name: 'üèôÔ∏è ÌòÑÎåÄ',
      sky: ['#1a1a2e', '#16213e'], ground: '#2d2d2d' }
];

// ÏßÑÌôî Ïù¥Î≤§Ìä∏ Í±∞Î¶¨ (1200mÏóê ÌòÑÎåÄ Î¨∏Î™Ö ÏßÑÌôî Ï∂îÍ∞Ä)
const EVOLUTION_POINTS = [100, 300, 600, 1000, 1200];

// ÌòÑÏû¨ Íµ¨Í∞Ñ Í∞ÄÏ†∏Ïò§Í∏∞
function getCurrentZone(distance) {
    for (const zone of BG_ZONES) {
        if (distance >= zone.start && distance < zone.end) return zone;
    }
    return BG_ZONES[BG_ZONES.length - 1];
}

// ========================================
// Î™®ÎìàÏãù Ï∫êÎ¶≠ÌÑ∞ ÏãúÏä§ÌÖú
// ========================================
const CREATURE_PARTS = {
    // Î®∏Î¶¨ ÌòïÌÉú
    heads: [
        { id: 'round', name: 'Îë•Í∑ºÌòï', draw: (g, x, y, s, c) => { g.beginFill(c); g.drawCircle(x, y, s * 0.4); g.endFill(); } },
        { id: 'oval', name: 'ÌÉÄÏõêÌòï', draw: (g, x, y, s, c) => { g.beginFill(c); g.drawEllipse(x, y, s * 0.35, s * 0.45); g.endFill(); } },
        { id: 'triangle', name: 'ÏÇºÍ∞ÅÌòï', draw: (g, x, y, s, c) => { g.beginFill(c); g.moveTo(x, y - s * 0.45); g.lineTo(x + s * 0.35, y + s * 0.3); g.lineTo(x - s * 0.35, y + s * 0.3); g.closePath(); g.endFill(); } },
        { id: 'square', name: 'ÏÇ¨Í∞ÅÌòï', draw: (g, x, y, s, c) => { g.beginFill(c); g.drawRoundedRect(x - s * 0.3, y - s * 0.35, s * 0.6, s * 0.7, s * 0.1); g.endFill(); } },
        { id: 'diamond', name: 'ÎßàÎ¶ÑÎ™®', draw: (g, x, y, s, c) => { g.beginFill(c); g.moveTo(x, y - s * 0.45); g.lineTo(x + s * 0.3, y); g.lineTo(x, y + s * 0.45); g.lineTo(x - s * 0.3, y); g.closePath(); g.endFill(); } },
        { id: 'crescent', name: 'Ï¥àÏäπÎã¨', draw: (g, x, y, s, c) => { g.beginFill(c); g.arc(x, y, s * 0.4, -Math.PI * 0.7, Math.PI * 0.7); g.arc(x + s * 0.15, y, s * 0.35, Math.PI * 0.7, -Math.PI * 0.7, true); g.endFill(); } },
    ],
    // Îàà Ïä§ÌÉÄÏùº
    eyes: [
        { id: 'round', name: 'Îë•Í∑ºÎàà', draw: (g, x, y, s) => { g.beginFill(0xffffff); g.drawCircle(x - s * 0.12, y - s * 0.05, s * 0.12); g.drawCircle(x + s * 0.12, y - s * 0.05, s * 0.12); g.endFill(); g.beginFill(0x111111); g.drawCircle(x - s * 0.1, y - s * 0.05, s * 0.06); g.drawCircle(x + s * 0.14, y - s * 0.05, s * 0.06); g.endFill(); } },
        { id: 'big', name: 'ÌÅ∞Îàà', draw: (g, x, y, s) => { g.beginFill(0xffffff); g.drawCircle(x - s * 0.15, y - s * 0.08, s * 0.18); g.drawCircle(x + s * 0.15, y - s * 0.08, s * 0.18); g.endFill(); g.beginFill(0x000000); g.drawCircle(x - s * 0.12, y - s * 0.06, s * 0.1); g.drawCircle(x + s * 0.18, y - s * 0.06, s * 0.1); g.endFill(); g.beginFill(0xffffff); g.drawCircle(x - s * 0.14, y - s * 0.1, s * 0.04); g.drawCircle(x + s * 0.16, y - s * 0.1, s * 0.04); g.endFill(); } },
        { id: 'slit', name: 'Í∞ÄÎäîÎàà', draw: (g, x, y, s) => { g.beginFill(0xFFD700); g.drawEllipse(x - s * 0.12, y - s * 0.05, s * 0.1, s * 0.06); g.drawEllipse(x + s * 0.12, y - s * 0.05, s * 0.1, s * 0.06); g.endFill(); g.beginFill(0x000000); g.drawEllipse(x - s * 0.12, y - s * 0.05, s * 0.03, s * 0.06); g.drawEllipse(x + s * 0.12, y - s * 0.05, s * 0.03, s * 0.06); g.endFill(); } },
        { id: 'alien', name: 'Ïô∏Í≥ÑÏù∏Îàà', draw: (g, x, y, s) => { g.beginFill(0x000000); g.drawEllipse(x - s * 0.18, y - s * 0.05, s * 0.15, s * 0.22); g.drawEllipse(x + s * 0.18, y - s * 0.05, s * 0.15, s * 0.22); g.endFill(); g.beginFill(0x00ff88, 0.3); g.drawEllipse(x - s * 0.18, y - s * 0.08, s * 0.08, s * 0.12); g.drawEllipse(x + s * 0.18, y - s * 0.08, s * 0.08, s * 0.12); g.endFill(); } },
        { id: 'cyclops', name: 'Ïô∏Îàà', draw: (g, x, y, s) => { g.beginFill(0xffffff); g.drawCircle(x, y - s * 0.05, s * 0.2); g.endFill(); g.beginFill(0xff3333); g.drawCircle(x, y - s * 0.05, s * 0.12); g.endFill(); g.beginFill(0x000000); g.drawCircle(x, y - s * 0.05, s * 0.06); g.endFill(); } },
        { id: 'multi', name: 'Î≥µÎàà', draw: (g, x, y, s) => { const cols = [0xff6666, 0x66ff66, 0x6666ff, 0xffff66]; for (let i = 0; i < 4; i++) { const ox = (i % 2 - 0.5) * s * 0.25; const oy = (Math.floor(i / 2) - 0.5) * s * 0.2 - s * 0.05; g.beginFill(cols[i]); g.drawCircle(x + ox, y + oy, s * 0.08); g.endFill(); } } },
    ],
    // Î™∏ÌÜµ ÌòïÌÉú
    bodies: [
        { id: 'blob', name: 'Î¨ºÎ∞©Ïö∏', draw: (g, x, y, s, c) => { g.beginFill(c); g.drawEllipse(x, y + s * 0.3, s * 0.35, s * 0.5); g.endFill(); } },
        { id: 'humanoid', name: 'Ïù∏Í∞ÑÌòï', draw: (g, x, y, s, c) => { g.beginFill(c); g.drawRoundedRect(x - s * 0.25, y + s * 0.05, s * 0.5, s * 0.7, s * 0.1); g.endFill(); } },
        { id: 'reptile', name: 'ÌååÏ∂©Î•ò', draw: (g, x, y, s, c) => { g.beginFill(c); g.drawEllipse(x, y + s * 0.35, s * 0.45, s * 0.35); g.endFill(); } },
        { id: 'bird', name: 'Ï°∞Î•ò', draw: (g, x, y, s, c) => { g.beginFill(c); g.moveTo(x, y); g.quadraticCurveTo(x + s * 0.4, y + s * 0.3, x, y + s * 0.7); g.quadraticCurveTo(x - s * 0.4, y + s * 0.3, x, y); g.endFill(); } },
        { id: 'fish', name: 'Ïñ¥Î•ò', draw: (g, x, y, s, c) => { g.beginFill(c); g.drawEllipse(x, y + s * 0.35, s * 0.5, s * 0.25); g.endFill(); } },
        { id: 'insect', name: 'Í≥§Ï∂©', draw: (g, x, y, s, c) => { g.beginFill(c); g.drawEllipse(x, y + s * 0.15, s * 0.2, s * 0.2); g.drawEllipse(x, y + s * 0.45, s * 0.25, s * 0.3); g.endFill(); } },
    ],
    // Ìåî/ÏïûÎã§Î¶¨
    arms: [
        { id: 'none', name: 'ÏóÜÏùå', draw: () => {} },
        { id: 'human', name: 'Ïù∏Í∞ÑÌåî', draw: (g, x, y, s, c, t) => { g.lineStyle(s * 0.08, c); const swing = Math.sin(t * 8) * 0.3; g.moveTo(x - s * 0.25, y + s * 0.15); g.lineTo(x - s * 0.5, y + s * 0.4 + swing * s * 0.2); g.moveTo(x + s * 0.25, y + s * 0.15); g.lineTo(x + s * 0.5, y + s * 0.4 - swing * s * 0.2); g.lineStyle(0); } },
        { id: 'wing', name: 'ÎÇ†Í∞ú', draw: (g, x, y, s, c, t) => { g.beginFill(c, 0.7); const flap = Math.sin(t * 12) * 0.2; g.moveTo(x - s * 0.25, y + s * 0.1); g.lineTo(x - s * 0.7, y - s * 0.1 + flap * s); g.lineTo(x - s * 0.6, y + s * 0.3); g.closePath(); g.moveTo(x + s * 0.25, y + s * 0.1); g.lineTo(x + s * 0.7, y - s * 0.1 + flap * s); g.lineTo(x + s * 0.6, y + s * 0.3); g.closePath(); g.endFill(); } },
        { id: 'tentacle', name: 'Ï¥âÏàò', draw: (g, x, y, s, c, t) => { g.lineStyle(s * 0.06, c); for (let i = 0; i < 3; i++) { const wave = Math.sin(t * 6 + i) * 0.15; g.moveTo(x - s * 0.2 - i * s * 0.05, y + s * 0.2); g.quadraticCurveTo(x - s * 0.4, y + s * 0.4 + wave * s, x - s * 0.3 - i * s * 0.1, y + s * 0.6); g.moveTo(x + s * 0.2 + i * s * 0.05, y + s * 0.2); g.quadraticCurveTo(x + s * 0.4, y + s * 0.4 - wave * s, x + s * 0.3 + i * s * 0.1, y + s * 0.6); } g.lineStyle(0); } },
        { id: 'claw', name: 'ÏßëÍ≤å', draw: (g, x, y, s, c, t) => { g.beginFill(c); const snap = Math.sin(t * 4) * 0.1; [-1, 1].forEach(dir => { const bx = x + dir * s * 0.35; g.drawCircle(bx, y + s * 0.25, s * 0.12); g.moveTo(bx, y + s * 0.2); g.lineTo(bx + dir * s * 0.15, y + s * 0.05 - snap * s * dir); g.lineTo(bx + dir * s * 0.05, y + s * 0.15); g.lineTo(bx + dir * s * 0.2, y + s * 0.25 + snap * s * dir); g.lineTo(bx, y + s * 0.2); }); g.endFill(); } },
        { id: 'fin', name: 'ÏßÄÎäêÎü¨ÎØ∏', draw: (g, x, y, s, c, t) => { g.beginFill(c, 0.8); const wave = Math.sin(t * 6) * 0.1; g.moveTo(x - s * 0.3, y + s * 0.2); g.quadraticCurveTo(x - s * 0.6, y + s * 0.1 + wave * s, x - s * 0.5, y + s * 0.4); g.lineTo(x - s * 0.3, y + s * 0.35); g.moveTo(x + s * 0.3, y + s * 0.2); g.quadraticCurveTo(x + s * 0.6, y + s * 0.1 - wave * s, x + s * 0.5, y + s * 0.4); g.lineTo(x + s * 0.3, y + s * 0.35); g.endFill(); } },
    ],
    // Îã§Î¶¨
    legs: [
        { id: 'none', name: 'ÏóÜÏùå', draw: () => {} },
        { id: 'biped', name: 'ÎëêÎ∞ú', draw: (g, x, y, s, c, t) => { g.lineStyle(s * 0.1, c); const walk = Math.sin(t * 10); g.moveTo(x - s * 0.1, y + s * 0.7); g.lineTo(x - s * 0.15 + walk * s * 0.1, y + s * 1.1); g.moveTo(x + s * 0.1, y + s * 0.7); g.lineTo(x + s * 0.15 - walk * s * 0.1, y + s * 1.1); g.lineStyle(0); } },
        { id: 'quadruped', name: 'ÎÑ§Î∞ú', draw: (g, x, y, s, c, t) => { g.lineStyle(s * 0.07, c); const walk = Math.sin(t * 10); g.moveTo(x - s * 0.2, y + s * 0.6); g.lineTo(x - s * 0.25 + walk * s * 0.08, y + s * 0.95); g.moveTo(x + s * 0.2, y + s * 0.6); g.lineTo(x + s * 0.25 - walk * s * 0.08, y + s * 0.95); g.moveTo(x - s * 0.1, y + s * 0.65); g.lineTo(x - s * 0.12 - walk * s * 0.08, y + s * 0.95); g.moveTo(x + s * 0.1, y + s * 0.65); g.lineTo(x + s * 0.12 + walk * s * 0.08, y + s * 0.95); g.lineStyle(0); } },
        { id: 'tail', name: 'Íº¨Î¶¨', draw: (g, x, y, s, c, t) => { g.lineStyle(s * 0.12, c); const wave = Math.sin(t * 5) * 0.3; g.moveTo(x, y + s * 0.7); g.quadraticCurveTo(x + wave * s * 0.5, y + s * 0.9, x + wave * s * 0.3, y + s * 1.1); g.lineStyle(0); } },
        { id: 'multi', name: 'Îã§Î¶¨Â§ö', draw: (g, x, y, s, c, t) => { g.lineStyle(s * 0.04, c); for (let i = 0; i < 6; i++) { const phase = t * 12 + i * 0.5; const swing = Math.sin(phase) * 0.1; const ox = (i % 2 === 0 ? -1 : 1) * (s * 0.15 + (i % 3) * s * 0.08); g.moveTo(x + ox * 0.5, y + s * 0.4 + (i % 3) * s * 0.15); g.lineTo(x + ox + swing * s, y + s * 0.95); } g.lineStyle(0); } },
        { id: 'hover', name: 'Î∂ÄÏú†', draw: (g, x, y, s, c, t) => { g.beginFill(c, 0.4); for (let i = 0; i < 3; i++) { const pulse = Math.sin(t * 8 + i) * 0.05; g.drawEllipse(x, y + s * 0.85 + i * s * 0.08, s * (0.3 - i * 0.08) * (1 + pulse), s * 0.04); } g.endFill(); } },
    ],
    // Ïû•Ïãù (Îøî, Í∑Ä, ÏïàÌÖåÎÇò Îì±)
    decorations: [
        { id: 'none', name: 'ÏóÜÏùå', draw: () => {} },
        { id: 'horns', name: 'Îøî', draw: (g, x, y, s, c) => { g.beginFill(c); g.moveTo(x - s * 0.2, y - s * 0.3); g.lineTo(x - s * 0.3, y - s * 0.6); g.lineTo(x - s * 0.1, y - s * 0.35); g.moveTo(x + s * 0.2, y - s * 0.3); g.lineTo(x + s * 0.3, y - s * 0.6); g.lineTo(x + s * 0.1, y - s * 0.35); g.endFill(); } },
        { id: 'antenna', name: 'ÎçîÎì¨Ïù¥', draw: (g, x, y, s, c, t) => { g.lineStyle(s * 0.03, c); const sway = Math.sin(t * 4) * 0.1; g.moveTo(x - s * 0.1, y - s * 0.35); g.quadraticCurveTo(x - s * 0.15 + sway * s, y - s * 0.55, x - s * 0.2, y - s * 0.65); g.moveTo(x + s * 0.1, y - s * 0.35); g.quadraticCurveTo(x + s * 0.15 - sway * s, y - s * 0.55, x + s * 0.2, y - s * 0.65); g.lineStyle(0); g.beginFill(0xffff00); g.drawCircle(x - s * 0.2, y - s * 0.65, s * 0.05); g.drawCircle(x + s * 0.2, y - s * 0.65, s * 0.05); g.endFill(); } },
        { id: 'ears', name: 'Í∑Ä', draw: (g, x, y, s, c) => { g.beginFill(c); g.moveTo(x - s * 0.25, y - s * 0.2); g.lineTo(x - s * 0.35, y - s * 0.5); g.lineTo(x - s * 0.15, y - s * 0.25); g.moveTo(x + s * 0.25, y - s * 0.2); g.lineTo(x + s * 0.35, y - s * 0.5); g.lineTo(x + s * 0.15, y - s * 0.25); g.endFill(); } },
        { id: 'crest', name: 'Î≥è', draw: (g, x, y, s, c) => { g.beginFill(0xff4444); for (let i = 0; i < 5; i++) { g.drawCircle(x + (i - 2) * s * 0.08, y - s * 0.4 - Math.abs(i - 2) * s * 0.05, s * 0.06); } g.endFill(); } },
        { id: 'halo', name: 'ÌõÑÍ¥ë', draw: (g, x, y, s, c, t) => { g.lineStyle(s * 0.03, 0xffd700, 0.6 + Math.sin(t * 6) * 0.3); g.drawEllipse(x, y - s * 0.55, s * 0.3, s * 0.08); g.lineStyle(0); } },
        { id: 'shell', name: 'Îì±ÍªçÏßà', draw: (g, x, y, s, c) => { g.beginFill(c, 0.8); g.drawEllipse(x, y + s * 0.25, s * 0.4, s * 0.35); g.endFill(); g.lineStyle(s * 0.02, 0x000000, 0.3); for (let i = 0; i < 3; i++) { g.drawEllipse(x, y + s * 0.25, s * (0.35 - i * 0.1), s * (0.3 - i * 0.08)); } g.lineStyle(0); } },
        // ÌòÑÎåÄ Î¨∏Î™Ö Ïû•Ïãù
        { id: 'cyber_antenna', name: 'Í∏∞Í≥ÑÏïàÌÖåÎÇò', draw: (g, x, y, s, c, t) => { g.beginFill(0x444444); g.drawRect(x - s * 0.08, y - s * 0.5, s * 0.04, s * 0.2); g.drawRect(x + s * 0.04, y - s * 0.55, s * 0.04, s * 0.25); g.endFill(); const blink = Math.sin(t * 10) > 0.5; g.beginFill(blink ? 0x00ff00 : 0xff0000); g.drawCircle(x - s * 0.06, y - s * 0.52, s * 0.03); g.drawCircle(x + s * 0.06, y - s * 0.57, s * 0.03); g.endFill(); } },
        { id: 'headphones', name: 'Ìó§ÎìúÌè∞', draw: (g, x, y, s, c) => { g.lineStyle(s * 0.04, 0x333333); g.arc(x, y - s * 0.35, s * 0.32, Math.PI * 1.2, Math.PI * 1.8); g.lineStyle(0); g.beginFill(0x333333); g.drawEllipse(x - s * 0.32, y - s * 0.15, s * 0.1, s * 0.15); g.drawEllipse(x + s * 0.32, y - s * 0.15, s * 0.1, s * 0.15); g.endFill(); g.beginFill(0x666666); g.drawEllipse(x - s * 0.32, y - s * 0.15, s * 0.06, s * 0.1); g.drawEllipse(x + s * 0.32, y - s * 0.15, s * 0.06, s * 0.1); g.endFill(); } },
        { id: 'visor', name: 'Î∞îÏù¥Ï†Ä', draw: (g, x, y, s, c, t) => { const scan = (t * 2) % 1; g.beginFill(0x111111, 0.9); g.drawRoundedRect(x - s * 0.35, y - s * 0.15, s * 0.7, s * 0.18, s * 0.05); g.endFill(); g.beginFill(0x00ffff, 0.8); g.drawRect(x - s * 0.32 + scan * s * 0.5, y - s * 0.12, s * 0.12, s * 0.12); g.endFill(); } },
    ],
    // Ìå®ÌÑ¥/Î¨¥Îä¨
    patterns: [
        { id: 'none', name: 'ÏóÜÏùå', draw: () => {} },
        { id: 'stripes', name: 'Ï§ÑÎ¨¥Îä¨', draw: (g, x, y, s, c) => { g.lineStyle(s * 0.04, 0x000000, 0.3); for (let i = 0; i < 4; i++) { g.moveTo(x - s * 0.3, y + s * 0.1 + i * s * 0.15); g.lineTo(x + s * 0.3, y + s * 0.1 + i * s * 0.15); } g.lineStyle(0); } },
        { id: 'spots', name: 'Ï†êÎ¨¥Îä¨', draw: (g, x, y, s) => { g.beginFill(0x000000, 0.2); const spots = [[0, 0.2], [-0.15, 0.35], [0.15, 0.4], [0, 0.55], [-0.1, 0.65]]; spots.forEach(([ox, oy]) => g.drawCircle(x + ox * s, y + oy * s, s * 0.06)); g.endFill(); } },
        { id: 'scales', name: 'ÎπÑÎäò', draw: (g, x, y, s) => { g.lineStyle(s * 0.02, 0x000000, 0.2); for (let row = 0; row < 4; row++) { for (let col = 0; col < 3; col++) { const sx = x + (col - 1) * s * 0.2 + (row % 2) * s * 0.1; const sy = y + s * 0.15 + row * s * 0.12; g.drawEllipse(sx, sy, s * 0.08, s * 0.05); } } g.lineStyle(0); } },
        { id: 'glow', name: 'Î∞úÍ¥ë', draw: (g, x, y, s, c, t) => { const pulse = 0.3 + Math.sin(t * 6) * 0.2; g.beginFill(0xffffff, pulse); g.drawCircle(x, y + s * 0.3, s * 0.15); g.endFill(); } },
        // ÌòÑÎåÄ Î¨∏Î™Ö Ìå®ÌÑ¥
        { id: 'circuit', name: 'ÌöåÎ°ú', draw: (g, x, y, s, c, t) => { g.lineStyle(s * 0.02, 0x00ff88, 0.6); g.moveTo(x - s * 0.2, y + s * 0.1); g.lineTo(x - s * 0.1, y + s * 0.1); g.lineTo(x - s * 0.1, y + s * 0.3); g.lineTo(x + s * 0.1, y + s * 0.3); g.lineTo(x + s * 0.1, y + s * 0.5); g.lineTo(x + s * 0.2, y + s * 0.5); g.moveTo(x, y + s * 0.3); g.lineTo(x, y + s * 0.6); g.lineStyle(0); const blink = Math.sin(t * 8) > 0; g.beginFill(blink ? 0x00ff88 : 0x004422, 0.8); g.drawCircle(x - s * 0.1, y + s * 0.1, s * 0.04); g.drawCircle(x + s * 0.1, y + s * 0.5, s * 0.04); g.drawCircle(x, y + s * 0.6, s * 0.04); g.endFill(); } },
        { id: 'hologram', name: 'ÌôÄÎ°úÍ∑∏Îû®', draw: (g, x, y, s, c, t) => { const shift = Math.sin(t * 4) * s * 0.02; g.beginFill(0x00ffff, 0.2); g.drawRect(x - s * 0.25 + shift, y + s * 0.1, s * 0.5, s * 0.5); g.endFill(); g.beginFill(0xff00ff, 0.15); g.drawRect(x - s * 0.25 - shift, y + s * 0.15, s * 0.5, s * 0.5); g.endFill(); } },
        { id: 'digital', name: 'ÎîîÏßÄÌÑ∏', draw: (g, x, y, s, c, t) => { const pixels = [[0,0],[1,0],[0,1],[1,1],[2,1],[0,2],[2,2],[1,3],[2,3]]; pixels.forEach(([px, py], i) => { const on = Math.sin(t * 5 + i) > 0; g.beginFill(on ? 0x00ff00 : 0x003300, on ? 0.8 : 0.3); g.drawRect(x - s * 0.15 + px * s * 0.1, y + s * 0.15 + py * s * 0.12, s * 0.08, s * 0.1); g.endFill(); }); } },
    ]
};

// ÌôòÍ≤Ω Í∏∞Î∞ò ÌÅ¨Î¶¨Ï≤ò ÏÉùÏÑ± (Îã§ÏñëÏÑ± ÌôïÎåÄ)
function generateCreatureFromEnv(envId) {
    const env = getEnvById(envId);
    const seed = Date.now();
    const rng = seededRandom(seed);
    
    // ÌôòÍ≤ΩÎ≥Ñ ÏÉâÏÉÅ ÌåîÎ†àÌä∏ (Ïó¨Îü¨ Î≥ÄÌòï)
    const envPalettes = {
        ocean: [
            { primary: 0x00b4d8, secondary: 0x0077b6, accent: 0x90e0ef },
            { primary: 0x0077b6, secondary: 0x023e8a, accent: 0x48cae4 },
            { primary: 0x00f5d4, secondary: 0x00bbf9, accent: 0x9ef01a },
            { primary: 0x4cc9f0, secondary: 0x3a0ca3, accent: 0x7209b7 },
        ],
        hydrothermal: [
            { primary: 0xff6b35, secondary: 0xd62828, accent: 0xff9f1c },
            { primary: 0xf72585, secondary: 0x7209b7, accent: 0xff006e },
            { primary: 0xff4800, secondary: 0x9d0208, accent: 0xffba08 },
            { primary: 0xdc2f02, secondary: 0x6a040f, accent: 0xfaa307 },
        ],
        ice: [
            { primary: 0xa8dadc, secondary: 0x457b9d, accent: 0xf1faee },
            { primary: 0xcaf0f8, secondary: 0x90e0ef, accent: 0xffffff },
            { primary: 0xade8f4, secondary: 0x00b4d8, accent: 0xe0fbfc },
            { primary: 0xbde0fe, secondary: 0xa2d2ff, accent: 0xcdb4db },
        ],
        magma: [
            { primary: 0xff4800, secondary: 0xff8500, accent: 0xffd60a },
            { primary: 0xef233c, secondary: 0xd90429, accent: 0xffbe0b },
            { primary: 0xff5400, secondary: 0xff6d00, accent: 0xff9e00 },
            { primary: 0xf72585, secondary: 0xb5179e, accent: 0xffd60a },
        ],
        atmosphere: [
            { primary: 0xe0aaff, secondary: 0x9d4edd, accent: 0xc77dff },
            { primary: 0xb8c0ff, secondary: 0x7b2cbf, accent: 0xe7c6ff },
            { primary: 0xc8b6ff, secondary: 0x5a189a, accent: 0xff6d00 },
            { primary: 0xd8bbff, secondary: 0x7400b8, accent: 0x80ffdb },
        ],
        toxic: [
            { primary: 0x70e000, secondary: 0x38b000, accent: 0xccff33 },
            { primary: 0xaaff00, secondary: 0x80b918, accent: 0xd4ff00 },
            { primary: 0x55a630, secondary: 0x2b9348, accent: 0xbfd200 },
            { primary: 0x9ef01a, secondary: 0x70e000, accent: 0xffff3f },
        ]
    };
    
    // ÌôòÍ≤ΩÎ≥Ñ ÏÑ†Ìò∏ ÌååÏ∏† (Îã§ÏñëÏÑ± ÌôïÎåÄ)
    const envBodies = {
        ocean: [0, 1, 4], // blob, humanoid, fish
        hydrothermal: [0, 2, 5], // blob, reptile, insect
        ice: [0, 1, 3], // blob, humanoid, bird
        magma: [2, 3, 5], // reptile, bird, insect
        atmosphere: [0, 3, 4], // blob, bird, fish
        toxic: [0, 2, 5] // blob, reptile, insect
    };
    
    const envHeads = {
        ocean: [0, 1, 3], // round, oval, square
        hydrothermal: [2, 4, 5], // triangle, diamond, crescent
        ice: [0, 1, 3], // round, oval, square
        magma: [2, 3, 4], // triangle, square, diamond
        atmosphere: [0, 1, 5], // round, oval, crescent
        toxic: [0, 2, 4] // round, triangle, diamond
    };
    
    const envEyes = {
        ocean: [0, 1, 3], // round, big, alien
        hydrothermal: [2, 4, 5], // slit, cyclops, multi
        ice: [0, 1, 2], // round, big, slit
        magma: [2, 3, 4], // slit, alien, cyclops
        atmosphere: [0, 1, 3], // round, big, alien
        toxic: [2, 3, 5] // slit, alien, multi
    };
    
    const envArms = {
        ocean: [0, 3, 5], // none, tentacle, fin
        hydrothermal: [1, 3, 4], // human, tentacle, claw
        ice: [0, 1, 2], // none, human, wing
        magma: [1, 2, 4], // human, wing, claw
        atmosphere: [0, 2, 3], // none, wing, tentacle
        toxic: [1, 3, 4] // human, tentacle, claw
    };
    
    const envLegs = {
        ocean: [0, 3, 5], // none, tail, hover
        hydrothermal: [1, 2, 4], // biped, quadruped, multi
        ice: [1, 2, 5], // biped, quadruped, hover
        magma: [2, 3, 4], // quadruped, tail, multi
        atmosphere: [0, 1, 5], // none, biped, hover
        toxic: [1, 3, 4] // biped, tail, multi
    };
    
    const envDecorations = {
        ocean: [0, 2, 5], // none, antenna, halo
        hydrothermal: [1, 3, 6], // horns, ears, shell
        ice: [0, 4, 5], // none, crest, halo
        magma: [1, 3, 4], // horns, ears, crest
        atmosphere: [2, 4, 5], // antenna, crest, halo
        toxic: [1, 2, 6] // horns, antenna, shell
    };
    
    const envPatterns = {
        ocean: [0, 1, 4], // none, stripes, glow
        hydrothermal: [2, 3, 4], // spots, scales, glow
        ice: [0, 1, 4], // none, stripes, glow
        magma: [2, 3, 4], // spots, scales, glow
        atmosphere: [0, 1, 4], // none, stripes, glow
        toxic: [1, 2, 4] // stripes, spots, glow
    };
    
    const palettes = envPalettes[envId] || envPalettes.ocean;
    const palette = palettes[Math.floor(rng() * palettes.length)];
    
    const bodies = envBodies[envId] || [0];
    const heads = envHeads[envId] || [0];
    const eyes = envEyes[envId] || [0];
    const arms = envArms[envId] || [0];
    const legs = envLegs[envId] || [0];
    const decorations = envDecorations[envId] || [0];
    const patterns = envPatterns[envId] || [0];
    
    return {
        head: heads[Math.floor(rng() * heads.length)],
        eyes: eyes[Math.floor(rng() * eyes.length)],
        body: bodies[Math.floor(rng() * bodies.length)],
        arms: arms[Math.floor(rng() * arms.length)],
        legs: legs[Math.floor(rng() * legs.length)],
        decoration: decorations[Math.floor(rng() * decorations.length)],
        pattern: patterns[Math.floor(rng() * patterns.length)],
        // ÌòÑÎåÄ Î¨∏Î™Ö ÏßÑÌôîÏö© (1200mÏóêÏÑú Ï†ÅÏö©)
        modernDeco: 7 + Math.floor(rng() * 3), // cyber_antenna, headphones, visor
        modernPattern: 5 + Math.floor(rng() * 3), // circuit, hologram, digital
        colors: palette,
        envId: envId
    };
}

// ÏãúÎìú Í∏∞Î∞ò ÎûúÎç§
function seededRandom(seed) {
    let s = seed;
    return function() {
        s = (s * 9301 + 49297) % 233280;
        return s / 233280;
    };
}

// Í±∞Î¶¨ Í∏∞Î∞ò ÌÅ¨Î¶¨Ï≤ò ÏßÑÌôî (Ïó∞ÏÜç ÏßÑÌôî)
// 0~100m: Í∏∞Î≥∏ (Î®∏Î¶¨+Î™∏ÌÜµ+Îàà)
// 100~300m: +Îã§Î¶¨
// 300~600m: +Ìåî
// 600~1000m: +Ïû•Ïãù
// 1000m+: +Ìå®ÌÑ¥ (ÏôÑÏÑ±Ìòï)
function evolveCreatureByLevel(creature, level) {
    if (!creature) return creature;
    const evolved = JSON.parse(JSON.stringify(creature));
    
    // Î†àÎ≤® 0: Í∏∞Î≥∏Ìòï (Î®∏Î¶¨, Î™∏ÌÜµ, ÎààÎßå)
    // Î†àÎ≤® 1: Îã§Î¶¨ Ï∂îÍ∞Ä
    // Î†àÎ≤® 2: Ìåî Ï∂îÍ∞Ä
    // Î†àÎ≤® 3: Ïû•Ïãù Ï∂îÍ∞Ä
    // Î†àÎ≤® 4: ÏôÑÏ†Ñ ÏßÑÌôî (Ìå®ÌÑ¥ Ï∂îÍ∞Ä)
    // Î†àÎ≤® 5: Í∏∞Í≥Ñ ÏúµÌï© (ÏµúÏ¢Ö)
    
    if (level <= 0) {
        evolved.arms = 0;
        evolved.legs = 0;
        evolved.decoration = 0;
        evolved.pattern = 0;
    } else if (level === 1) {
        // Îã§Î¶¨Îßå Ï∂îÍ∞Ä - Îã§Î¶¨Í∞Ä ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ Îã§Î¶¨ Î∂ÄÏó¨
        evolved.arms = 0;
        evolved.decoration = 0;
        evolved.pattern = 0;
        if (evolved.legs === 0) evolved.legs = 1; // ÎëêÎ∞ú Îã§Î¶¨
    } else if (level === 2) {
        // Ìåî Ï∂îÍ∞Ä - ÌåîÏù¥ ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ Ìåî Î∂ÄÏó¨
        evolved.decoration = 0;
        evolved.pattern = 0;
        if (evolved.legs === 0) evolved.legs = 1;
        if (evolved.arms === 0) evolved.arms = 1; // Ïù∏Í∞Ñ Ìåî
    } else if (level === 3) {
        // Ïû•Ïãù Ï∂îÍ∞Ä
        evolved.pattern = 0;
        if (evolved.legs === 0) evolved.legs = 1;
        if (evolved.arms === 0) evolved.arms = 1;
    } else if (level === 4) {
        // ÏôÑÏ†Ñ ÏßÑÌôî - Î™®Îì† Í∏∞Î≥∏ ÌååÏ∏† Ïú†ÏßÄ (Ìå®ÌÑ¥ Ìè¨Ìï®)
        if (evolved.legs === 0) evolved.legs = 1;
        if (evolved.arms === 0) evolved.arms = 1;
    } else if (level >= 5) {
        // Í∏∞Í≥Ñ ÏúµÌï© - Í∏∞Í≥Ñ ÌååÏ∏† Ï†ÅÏö©
        if (evolved.legs === 0) evolved.legs = 1;
        if (evolved.arms === 0) evolved.arms = 1;
        if (evolved.modernDeco) {
            evolved.decoration = evolved.modernDeco;
        }
        if (evolved.modernPattern) {
            evolved.pattern = evolved.modernPattern;
        }
    }
    
    return evolved;
}

// Ïù¥Ï†Ñ Î≤ÑÏ†Ñ Ìò∏ÌôòÏö© (Í±∞Î¶¨ Í∏∞Î∞ò)
function evolveCreatureByDistance(creature, distance) {
    let level = 0;
    if (distance >= 1200) level = 5;
    else if (distance >= 1000) level = 4;
    else if (distance >= 600) level = 3;
    else if (distance >= 300) level = 2;
    else if (distance >= 100) level = 1;
    return evolveCreatureByLevel(creature, level);
}

// ÌõàÏû• ÌååÏ∏† Ï†ïÏùò (6Í∞ú Ïä¨Î°Ø)
const BADGE_PARTS = [
    { id: 'speed', icon: '‚ö°', name: 'ÏÜçÎèÑ', effect: 'ÏÜçÎèÑ +10%', color: 0xFFD700 },
    { id: 'jump', icon: 'ü¶ò', name: 'Ï†êÌîÑ', effect: 'Ï†êÌîÑÎ†• +15%', color: 0x00FF88 },
    { id: 'shield', icon: 'üõ°Ô∏è', name: 'Î∞©Ïñ¥', effect: 'HP +1', color: 0x4488FF },
    { id: 'magnet', icon: 'üß≤', name: 'ÏûêÏÑù', effect: 'ÏΩîÏù∏ ÏûêÏÑù', color: 0xFF4488 },
    { id: 'luck', icon: 'üçÄ', name: 'ÌñâÏö¥', effect: 'Ï£ºÏÇ¨ÏúÑ +5', color: 0x44FF44 },
    { id: 'star', icon: '‚≠ê', name: 'Î≥Ñ', effect: 'Ï†êÏàò +20%', color: 0xFFFF00 },
    { id: 'heart', icon: '‚ù§Ô∏è', name: 'ÏÉùÎ™Ö', effect: 'Î∂ÄÌôú 1Ìöå', color: 0xFF4444 },
    { id: 'bolt', icon: 'üî•', name: 'ÌôîÏóº', effect: 'Ïû•Ïï†Î¨º ÌååÍ¥¥', color: 0xFF6600 },
];

// ÌÅ¨Î¶¨Ï≤ò Í∑∏Î¶¨Í∏∞
function drawCreature(graphics, creature, x, y, size, time) {
    const c = creature.colors;
    const t = time;
    const s = size;
    
    // Í∑∏Î¶ºÏûê
    graphics.beginFill(0x000000, 0.2);
    graphics.drawEllipse(x, y + s * 1.05, s * 0.4, s * 0.1);
    graphics.endFill();
    
    // Î™∏ÌÜµ (Î®ºÏ†Ä)
    CREATURE_PARTS.bodies[creature.body]?.draw(graphics, x, y, s, c.primary);
    
    // Ìå®ÌÑ¥
    CREATURE_PARTS.patterns[creature.pattern]?.draw(graphics, x, y, s, c.secondary, t);
    
    // Îã§Î¶¨
    CREATURE_PARTS.legs[creature.legs]?.draw(graphics, x, y, s, c.secondary, t);
    
    // Ìåî
    CREATURE_PARTS.arms[creature.arms]?.draw(graphics, x, y, s, c.secondary, t);
    
    // Ïû•Ïãù (Îí§)
    if (creature.decoration === CREATURE_PARTS.decorations.findIndex(d => d.id === 'shell')) {
        CREATURE_PARTS.decorations[creature.decoration]?.draw(graphics, x, y, s, c.accent, t);
    }
    
    // Î®∏Î¶¨
    CREATURE_PARTS.heads[creature.head]?.draw(graphics, x, y, s, c.primary);
    
    // Îàà
    CREATURE_PARTS.eyes[creature.eyes]?.draw(graphics, x, y, s);
    
    // Ïû•Ïãù (Ïïû)
    if (creature.decoration !== CREATURE_PARTS.decorations.findIndex(d => d.id === 'shell')) {
        CREATURE_PARTS.decorations[creature.decoration]?.draw(graphics, x, y, s, c.accent, t);
    }
}

// ÌôòÍ≤Ω Ï†ïÏùò
const ENVIRONMENTS = [
    { id: 'ocean', name: 'ÏõêÏãú Ìï¥Ïñë', icon: 'üåä', range: [1, 16], 
      colors: { bg1: '#001a33', bg2: '#003366', particle: '#00aaff', primary: '#00b4d8', secondary: '#0077b6' },
      desc: 'Î∞îÎã§Îäî ÏÉùÎ™ÖÏùò ÏöîÎûå.', weak: 'Í±¥Ï°∞Ìï®ÏùÄ ÏπòÎ™ÖÏ†Å.', creatures: ['ü¶†','ü´ß','üíß','üåÄ'] },
    { id: 'hydrothermal', name: 'Ïó¥ÏàòÍµ¨', icon: 'üî•', range: [17, 32],
      colors: { bg1: '#1a0a00', bg2: '#4d1a00', particle: '#ff6600', primary: '#ff6b35', secondary: '#d62828' },
      desc: 'Í∑πÌïú ÌôòÍ≤ΩÏù¥ ÏùºÏÉÅ.', weak: 'ÌèâÏò®Ìï®Ïù¥ Î∂àÏïà.', creatures: ['üî¥','üü†','üí•','‚ö°'] },
    { id: 'ice', name: 'ÏñºÏùå Î∞îÎã§', icon: 'üßä', range: [33, 48],
      colors: { bg1: '#0a1a2e', bg2: '#1a3a5e', particle: '#88ddff', primary: '#a8dadc', secondary: '#457b9d' },
      desc: 'Ìö®Ïú®Ïùò Îã¨Ïù∏.', weak: 'Îú®Í±∞ÏõÄÏùÄ ÏπòÎ™ÖÏ†Å.', creatures: ['‚ùÑÔ∏è','üîµ','üí†','ü´ß'] },
    { id: 'magma', name: 'ÎßàÍ∑∏Îßà Ìò∏Ïàò', icon: 'üåã', range: [49, 64],
      colors: { bg1: '#1a0000', bg2: '#4d0000', particle: '#ff3300', primary: '#ff4800', secondary: '#ff8500' },
      desc: 'Ïö©ÏïîÏù¥ ÎÜÄÏù¥ÌÑ∞.', weak: 'ÏñºÏùåÏù¥ Î¨¥Îç§.', creatures: ['üî•','üü°','‚≠ê','üíõ'] },
    { id: 'atmosphere', name: 'ÎåÄÍ∏∞ Î∂ÄÏú†', icon: '‚òÅÔ∏è', range: [65, 80],
      colors: { bg1: '#1a1033', bg2: '#2d1a4d', particle: '#cc88ff', primary: '#e0aaff', secondary: '#9d4edd' },
      desc: 'ÌïòÎäòÏùÑ ÎÇòÎäî Ïûê.', weak: 'Î¨¥Í±∞ÏõÄÏù¥ Ï†Å.', creatures: ['üíú','üü£','‚ú®','üí´'] },
    { id: 'toxic', name: 'ÎèÖÏÑ± Îä™', icon: 'üíÄ', range: [81, 100],
      colors: { bg1: '#0a1a0a', bg2: '#1a3a1a', particle: '#88ff00', primary: '#70e000', secondary: '#38b000' },
      desc: 'ÎèÖÏù¥ Í≥ß ÏïΩ.', weak: 'Íπ®ÎÅóÌï®Ïù¥ Î∂àÌé∏.', creatures: ['üü¢','üíö','üß™','‚ò¢Ô∏è'] }
];

const getEnvByRoll = roll => ENVIRONMENTS.find(e => roll >= e.range[0] && roll <= e.range[1]);
const getEnvById = id => ENVIRONMENTS.find(e => e.id === id) || ENVIRONMENTS[0];

// ÌååÏ∏† Ï†ïÏùò
const BODY_PARTS = {
    // Phase 1
    eye: { icon: 'üëÅÔ∏è', name: 'Îàà', max: 3, fx: 'ÏãúÏïº +20%' },
    mouth: { icon: 'üëÑ', name: 'ÏûÖ', max: 2, fx: 'Ï†êÏàò +15%' },
    arm: { icon: 'ü¶æ', name: 'Ìåî', max: 4, fx: 'ÏûêÏÑù Ìö®Í≥º' },
    leg: { icon: 'ü¶ø', name: 'Îã§Î¶¨', max: 4, fx: 'ÏÜçÎèÑ +10%' },
    tail: { icon: 'üêç', name: 'Íº¨Î¶¨', max: 2, fx: 'ÎåÄÏãú ÏÇ¨Ïö©' },
    antenna: { icon: 'üì°', name: 'ÎçîÎì¨Ïù¥', max: 2, fx: 'Î≤îÏúÑ +15%' },
    // Phase 2
    wing: { icon: 'ü™Ω', name: 'ÎÇ†Í∞ú', max: 2, fx: 'ÎçîÎ∏îÏ†êÌîÑ' },
    shell: { icon: 'üõ°Ô∏è', name: 'ÍªçÏßà', max: 2, fx: 'ÌîºÌï¥ Í∞êÏÜå' },
    claw: { icon: 'ü¶Ä', name: 'Î∞úÌÜ±', max: 2, fx: 'Î≤ΩÌÉÄÍ∏∞' },
    lung: { icon: 'ü´Å', name: 'ÌóàÌåå', max: 1, fx: 'Ïú°ÏÉÅ Ï†ÅÏùë' }
};

// Îã§Íµ≠Ïñ¥
const TRANSLATIONS = {
    ko: {
        title: 'AROA',
        subtitle: 'A Road Of Adventure',
        startGame: 'Í≤åÏûÑ ÏãúÏûë',
        continueGame: 'Ïù¥Ïñ¥ÌïòÍ∏∞',
        settings: 'ÏÑ§Ï†ï',
        language: 'Ïñ∏Ïñ¥',
        sound: 'ÏÇ¨Ïö¥Îìú',
        skip: 'Í±¥ÎÑàÎõ∞Í∏∞ ‚Ä∫',
        next: 'Îã§Ïùå',
        intro: [
            { icon: 'üåå', title: 'ÌÉúÏ¥àÏóê...', text: 'ÎÅùÏóÜÏù¥ ÌéºÏ≥êÏßÑ <span class="hl">Ïö∞Ï£ºÏùò Ïã¨Ïó∞</span>...<br>ÏïÑÏ£º ÏûëÏùÄ <span class="gold">Î∂àÍΩÉ</span>Ïù¥ ÌîºÏñ¥Ïò§Î•¥Î†§ ÌïúÎã§.' },
            { icon: '‚ú®', title: 'ÏùòÏãùÏùò ÌÉÑÏÉù', text: 'ÎãπÏã†ÏùÄ ÏïÑÏßÅ <span class="hl">ÏïÑÎ¨¥Í≤ÉÎèÑ ÏïÑÎãàÎã§</span>.<br>Ïò§ÏßÅ <span class="gold">Ï°¥Ïû¨ÌïòÍ≥†Ïûê ÌïòÎäî ÏùòÏßÄ</span>ÎßåÏù¥ ÍπúÎπ°Ïù∏Îã§.' }
        ],
        dice: { title: 'üé≤ Ï∂úÏÉùÏßÄ Í≤∞Ï†ï', desc: 'Ï£ºÏÇ¨ÏúÑÍ∞Ä ÎãπÏã†Ïùò Ï∂úÏÉùÏßÄÎ•º Í≤∞Ï†ïÌï©ÎãàÎã§', roll: 'Ï£ºÏÇ¨ÏúÑ ÎçòÏßÄÍ∏∞', rolling: 'Í≤∞Ï†ï Ï§ë...', accept: 'Ïù¥ ÌôòÍ≤ΩÏóêÏÑú ÌÉúÏñ¥ÎÇòÍ∏∞' },
        afterBirth: env => [
            { icon: env.icon, title: env.name, text: `<span class="hl">${env.name}</span>ÏóêÏÑú ÌÉúÏñ¥ÎÇ¨Îã§.<br><br><span class="gold">"${env.desc}"</span><br><span class="danger">‚ö†Ô∏è ${env.weak}</span>` },
            { icon: 'ü¶†', title: 'Ï≤´ Î≤àÏß∏ ÏÉùÎ™Ö', text: 'ÏïÑÏ£º ÏûëÏùÄ <span class="hl">ÌïòÎÇòÏùò ÏÑ∏Ìè¨</span>.<br>ÏÇ¥ÏïÑÎÇ®ÏúºÎ†§Î©¥ <span class="gold">Î®πÏñ¥Ïïº ÌïúÎã§</span>.' },
            { icon: '‚öîÔ∏è', title: 'ÏÉùÏ°¥Ïùò ÏãúÏûë', text: '<span class="danger">Îçî ÌÅ∞ Ï°¥Ïû¨</span>Îì§Ïù¥ ÎãπÏã†ÏùÑ ÎÖ∏Î¶∞Îã§.<br><span class="hl">ÏûëÏùÄ Í≤É</span>ÏùÑ Î®πÍ≥† <span class="gold">ÏÑ±Ïû•</span>ÌïòÎùº.' }
        ],
        start: 'Î™®Ìóò ÏãúÏûëÌïòÍ∏∞',
        gameover: 'Ïû°ÏïÑÎ®πÌòîÎã§!',
        gameoverDesc: 'Îçî ÌÅ∞ Ï°¥Ïû¨ÏóêÍ≤å Ìè¨ÏãùÎãπÌñàÏäµÎãàÎã§.',
        retry: 'Îã§Ïãú ÌÉúÏñ¥ÎÇòÍ∏∞',
        home: 'ÌôàÏúºÎ°ú',
        clear: 'Îã§ÏÑ∏Ìè¨ ÏßÑÌôî!',
        clearDesc: 'Îã®Ïùº ÏÑ∏Ìè¨Ïùò ÌïúÍ≥ÑÎ•º ÎÑòÏñ¥ÏÑ∞ÏäµÎãàÎã§!',
        nextPhase: 'Phase 2Î°ú!',
        // Phase 2
        p2Intro: [
            { icon: 'üèîÔ∏è', title: 'Ïú°ÏßÄÎ°ú!', text: 'Î∞îÎã§Ïùò ÌïúÍ≥ÑÎ•º ÎÑòÏñ¥<br><span class="hl">Í¥ëÌôúÌïú Ïú°ÏßÄ</span>Í∞Ä ÌéºÏ≥êÏßÑÎã§.' },
            { icon: 'ü¶é', title: 'ÏÉàÎ°úÏö¥ ÎèÑÏ†Ñ', text: '<span class="danger">Ï§ëÎ†•</span>Ïù¥ÎùºÎäî ÏÉàÎ°úÏö¥ Ï†Å!<br><span class="gold">Ï†êÌîÑ</span>ÌïòÍ≥† <span class="hl">Ïò¨ÎùºÍ∞ÄÎùº</span>.' }
        ],
        p2DiceTitle: 'Ï†êÌîÑÎ†• Í≤∞Ï†ï',
        p2DiceDesc: 'Ï£ºÏÇ¨ÏúÑÍ∞Ä ÎãπÏã†Ïùò Ï†êÌîÑÎ†•ÏùÑ Í≤∞Ï†ïÌï©ÎãàÎã§',
        p2Go: 'Îì±Î∞ò ÏãúÏûë!',
        p2Start: 'Îì±Î∞ò ÏãúÏûë!',
        roll: 'Ï£ºÏÇ¨ÏúÑ ÎçòÏßÄÍ∏∞',
        p2Gameover: 'Ï∂îÎùΩÌñàÎã§!',
        p2GameoverDesc: 'ÎÑàÎ¨¥ ÏïÑÎûòÎ°ú Îñ®Ïñ¥Ï°åÏäµÎãàÎã§.',
        p2Clear: 'Ïú°ÏßÄ ÎèÑÎã¨!',
        p2ClearDesc: 'ÎìúÎîîÏñ¥ Ïú°ÏßÄÏóê ÎèÑÏ∞©ÌñàÏäµÎãàÎã§!',
        p2Retry: 'Îã§Ïãú ÏãúÏûë',
        p2Restart: 'Ï≤òÏùåÎ∂ÄÌÑ∞ Îã§Ïãú ÏãúÏûëÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
        goal: 'Î™©Ìëú',
        // Phase 3
        p3Intro: [
            { icon: 'üåç', title: 'Î¨∏Î™ÖÏùò Ïó¨Ï†ï!', text: 'Îã¨Î¶¨Î©∞ Î≥ÄÌïòÎäî <span class="hl">Î¨∏Î™ÖÏùò ÏÑ∏Í≥Ñ</span>Î•º ÎäêÍª¥Îùº!' },
            { icon: 'üß¨', title: 'ÏßÑÌôîÏùò ÌùîÏ†Å', text: '<span class="gold">‚ú® ÏßÑÌôî Í≤åÏù¥ÏßÄ</span>Î•º Î™®ÏïÑ<br>ÏÉàÎ°úÏö¥ Î™®ÏäµÏúºÎ°ú <span class="hl">ÏßÑÌôî</span>ÌïòÎùº!' },
            { icon: 'üëÄ', title: 'ÏßÑÌôîÏùò Í≤∞Í≥º', text: 'ÌôòÍ≤ΩÏóê Îî∞Îùº Îã¨ÎùºÏßÄÎäî<br><span class="hl">ÏßÑÌôîÏùò Í≤∞Í≥º</span>Î•º ÏßÄÏºúÎ¥êÎùº!' }
        ],
        p3Start: 'Îã¨Î¶¨Í∏∞ ÏãúÏûë!',
        p3Gameover: 'Ï∂îÎùΩ!',
        p3GameoverDesc: 'Í∞àÎùºÏßÑ ÌãàÏóê Îπ†Ï°åÏäµÎãàÎã§.',
        p3Clear: 'Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥!',
        p3ClearDesc: 'Îã§Ïùå ÏãúÎåÄÎ°ú ÏßÑÌôîÌï©ÎãàÎã§!',
        p3Final: 'üéâ ÌòÑÎåÄ ÎèÑÎã¨!',
        p3FinalDesc: 'Î™®Îì† ÏßÑÌôîÎ•º ÏôÑÎ£åÌñàÏäµÎãàÎã§!',
        p3Distance: 'Í±∞Î¶¨',
        p3Evolution: 'ÏßÑÌôî',
        p3SelectRemove: 'Ï†úÍ±∞Ìï† ÌååÏ∏† ÏÑ†ÌÉù',
        p3LosePart: 'ÌååÏ∏† ÌïòÎÇòÎ•º ÏûÉÏäµÎãàÎã§.',
        p3EvoDice: 'ÏßÑÌôî Ï£ºÏÇ¨ÏúÑ!',
        p3EvoSuccess: 'ÏßÑÌôî ÏÑ±Í≥µ!',
        p3EvoFail: 'ÏïÑÏâΩÎã§!',
        p3EvoNext: 'Îã§Ïùå Ï£ºÏÇ¨ÏúÑÎ•º ÎÖ∏Î†§Î≥¥Ïûê',
        p3PlacePart: 'ÌååÏ∏† Î∞∞ÏπòÌïòÍ∏∞',
        p3Continue: 'Í≥ÑÏÜç Îã¨Î¶¨Í∏∞',
        p3Stats: 'Ïä§ÌÖü Î≥¥Í∏∞',
        p3Edit: 'ÌååÏ∏† Ìé∏Ïßë',
        // Í≥µÌÜµ UI
        height: 'ÎÜíÏù¥',
        score: 'Ï†êÏàò',
        parts: 'Ïã†Ï≤¥ ÌååÏ∏†',
        stage2: 'Stage 2: ÎèÑÎßàÎ±Ä',
        sky: 'ÌïòÎäò',
        maxHeight: 'ÏµúÎåÄ ÎÜíÏù¥',
        none: 'ÏóÜÏùå',
        acquired: 'ÌöçÎìù!',
        confirmHome: 'ÌôàÏúºÎ°ú ÎèåÏïÑÍ∞ÄÏãúÍ≤†ÏäµÎãàÍπå?'
    },
    en: {
        title: 'AROA',
        subtitle: 'A Road Of Adventure',
        startGame: 'Start Game',
        continueGame: 'Continue',
        settings: 'Settings',
        language: 'Language',
        sound: 'Sound',
        skip: 'Skip ‚Ä∫',
        next: 'Next',
        intro: [
            { icon: 'üåå', title: 'In the beginning...', text: 'The endless <span class="hl">cosmic abyss</span>...<br>A tiny <span class="gold">spark</span> is about to ignite.' },
            { icon: '‚ú®', title: 'Birth of Consciousness', text: 'You are <span class="hl">nothing yet</span>.<br>Only the <span class="gold">will to exist</span> flickers.' }
        ],
        dice: { title: 'üé≤ Birthplace', desc: 'The dice determines where you are born', roll: 'Roll the Dice', rolling: 'Rolling...', accept: 'Accept this fate' },
        afterBirth: env => [
            { icon: env.icon, title: env.name, text: `Born in <span class="hl">${env.name}</span>.<br><br><span class="gold">"${env.desc}"</span><br><span class="danger">‚ö†Ô∏è ${env.weak}</span>` },
            { icon: 'ü¶†', title: 'First Life', text: 'A tiny <span class="hl">single cell</span>.<br>To survive, you must <span class="gold">eat</span>.' },
            { icon: '‚öîÔ∏è', title: 'Survival Begins', text: '<span class="danger">Bigger creatures</span> hunt you.<br>Eat <span class="hl">smaller ones</span> and <span class="gold">grow</span>.' }
        ],
        start: 'Start Adventure',
        gameover: 'Eaten!',
        gameoverDesc: 'You were consumed by a larger creature.',
        retry: 'Be Reborn',
        home: 'Home',
        clear: 'Multicellular Evolution!',
        clearDesc: 'You have transcended the limits of a single cell!',
        nextPhase: 'To Phase 2!',
        p2Intro: [
            { icon: 'üèîÔ∏è', title: 'To Land!', text: 'Beyond the sea,<br><span class="hl">vast land</span> awaits.' },
            { icon: 'ü¶é', title: 'New Challenge', text: '<span class="danger">Gravity</span> is the new enemy!<br><span class="gold">Jump</span> and <span class="hl">climb</span>.' }
        ],
        p2DiceTitle: 'Jump Power',
        p2DiceDesc: 'The dice determines your jump power',
        p2Go: 'Start Climbing!',
        p2Start: 'Start Climbing!',
        roll: 'Rolling...',
        p2Gameover: 'Fell!',
        p2GameoverDesc: 'You fell too far down.',
        p2Clear: 'Land Reached!',
        p2ClearDesc: 'You finally reached the land!',
        p2Retry: 'Retry',
        p2Restart: 'Restart from beginning?',
        goal: 'Goal',
        // Common UI
        height: 'Height',
        score: 'Score',
        parts: 'Body Parts',
        stage2: 'Stage 2: Lizard',
        sky: 'Sky',
        maxHeight: 'Max Height',
        none: 'None',
        acquired: 'Acquired!',
        confirmHome: 'Return to home?'
    },
    ja: {
        title: 'AROA',
        subtitle: 'A Road Of Adventure',
        startGame: '„Ç≤„Éº„É†ÈñãÂßã',
        continueGame: 'Á∂ö„Åç„Åã„Çâ',
        settings: 'Ë®≠ÂÆö',
        language: 'Ë®ÄË™û',
        sound: '„Çµ„Ç¶„É≥„Éâ',
        skip: '„Çπ„Ç≠„ÉÉ„Éó ‚Ä∫',
        next: 'Ê¨°„Å∏',
        intro: [
            { icon: 'üåå', title: 'Â§™Âàù„Å´...', text: 'Êûú„Å¶„Åó„Å™„ÅèÂ∫É„Åå„Çã<span class="hl">ÂÆáÂÆô„ÅÆÊ∑±Ê∑µ</span>...<br>Â∞è„Åï„Å™<span class="gold">ÁÅ´Ëä±</span>„ÅåÁÅØ„Çç„ÅÜ„Å®„Åó„Å¶„ÅÑ„Çã„ÄÇ' },
            { icon: '‚ú®', title: 'ÊÑèË≠ò„ÅÆË™ïÁîü', text: '„ÅÇ„Å™„Åü„ÅØ„Åæ„Å†<span class="hl">‰ΩïËÄÖ„Åß„ÇÇ„Å™„ÅÑ</span>„ÄÇ<br>„Åü„Å†<span class="gold">Â≠òÂú®„Åó„Çà„ÅÜ„Å®„Åô„ÇãÊÑèÂøó</span>„Å†„Åë„ÅåÁû¨„ÅÑ„Å¶„ÅÑ„Çã„ÄÇ' }
        ],
        dice: { title: 'üé≤ Âá∫ÁîüÂú∞Ê±∫ÂÆö', desc: '„Çµ„Ç§„Ç≥„É≠„Åå„ÅÇ„Å™„Åü„ÅÆÂá∫ÁîüÂú∞„ÇíÊ±∫„ÇÅ„Åæ„Åô', roll: '„Çµ„Ç§„Ç≥„É≠„ÇíÊåØ„Çã', rolling: 'Ê±∫ÂÆö‰∏≠...', accept: '„Åì„ÅÆÁí∞Â¢É„ÅßÁîü„Åæ„Çå„Çã' },
        afterBirth: env => [
            { icon: env.icon, title: env.name, text: `<span class="hl">${env.name}</span>„ÅßÁîü„Åæ„Çå„Åü„ÄÇ<br><br><span class="gold">"${env.desc}"</span><br><span class="danger">‚ö†Ô∏è ${env.weak}</span>` },
            { icon: 'ü¶†', title: 'ÊúÄÂàù„ÅÆÁîüÂëΩ', text: '„Å®„Å¶„ÇÇÂ∞è„Åï„Å™<span class="hl">‰∏Ä„Å§„ÅÆÁ¥∞ËÉû</span>„ÄÇ<br>Áîü„ÅçÊÆã„Çã„Å´„ÅØ<span class="gold">È£ü„Åπ„Å™„Åë„Çå„Å∞</span>„Å™„Çâ„Å™„ÅÑ„ÄÇ' },
            { icon: '‚öîÔ∏è', title: 'ÁîüÂ≠ò„ÅÆÂßã„Åæ„Çä', text: '<span class="danger">Â§ß„Åç„Å™Â≠òÂú®</span>„Åå„ÅÇ„Å™„Åü„ÇíÁãô„Å£„Å¶„ÅÑ„Çã„ÄÇ<br><span class="hl">Â∞è„Åï„ÅÑ„ÇÇ„ÅÆ</span>„ÇíÈ£ü„Åπ„Å¶<span class="gold">ÊàêÈï∑</span>„Åó„Çà„ÅÜ„ÄÇ' }
        ],
        start: 'ÂÜíÈô∫„ÇíÂßã„ÇÅ„Çã',
        gameover: 'È£ü„Åπ„Çâ„Çå„ÅüÔºÅ',
        gameoverDesc: '„Çà„ÇäÂ§ß„Åç„Å™Â≠òÂú®„Å´ÊçïÈ£ü„Åï„Çå„Åæ„Åó„Åü„ÄÇ',
        retry: '„É™„Éà„É©„Ç§',
        home: '„Éõ„Éº„É†',
        clear: 'Â§öÁ¥∞ËÉûÈÄ≤ÂåñÔºÅ',
        clearDesc: 'ÂçòÁ¥∞ËÉû„ÅÆÈôêÁïå„ÇíË∂Ö„Åà„Åæ„Åó„ÅüÔºÅ',
        nextPhase: 'Phase 2„Å∏ÔºÅ',
        p2Intro: [
            { icon: 'üèîÔ∏è', title: 'Èô∏„Å∏ÔºÅ', text: 'Êµ∑„ÇíË∂Ö„Åà„Å¶<br><span class="hl">Â∫ÉÂ§ß„Å™Èô∏Âú∞</span>„ÅåÂæÖ„Å£„Å¶„ÅÑ„Çã„ÄÇ' },
            { icon: 'ü¶é', title: 'Êñ∞„Åü„Å™ÊåëÊà¶', text: '<span class="danger">ÈáçÂäõ</span>„Å®„ÅÑ„ÅÜÊñ∞„Åü„Å™ÊïµÔºÅ<br><span class="gold">„Ç∏„É£„É≥„Éó</span>„Åó„Å¶<span class="hl">Áôª„Çå</span>„ÄÇ' }
        ],
        p2DiceTitle: '„Ç∏„É£„É≥„ÉóÂäõ',
        p2DiceDesc: '„Çµ„Ç§„Ç≥„É≠„Åå„Ç∏„É£„É≥„ÉóÂäõ„ÇíÊ±∫„ÇÅ„Çã',
        p2Go: 'ÁôªÊîÄÈñãÂßãÔºÅ',
        p2Start: 'ÁôªÊîÄÈñãÂßãÔºÅ',
        p2Gameover: 'ËêΩ‰∏ãÔºÅ',
        p2GameoverDesc: 'ËêΩ„Å°„Åô„Åé„Åæ„Åó„Åü„ÄÇ',
        p2Clear: 'Á©∫„Å∏ÔºÅ',
        p2ClearDesc: 'Èô∏Âú∞„ÇíÂæÅÊúç„Åó„Åæ„Åó„ÅüÔºÅ',
        p2Retry: '„É™„Éà„É©„Ç§',
        p2Restart: 'ÊúÄÂàù„Åã„Çâ„ÇÑ„ÇäÁõ¥„Åó„Åæ„Åô„ÅãÔºü',
        // ÂÖ±ÈÄöUI
        height: 'È´ò„Åï',
        score: '„Çπ„Ç≥„Ç¢',
        parts: '‰Ωì„Éë„Éº„ÉÑ',
        stage2: 'Stage 2: „Éà„Ç´„Ç≤',
        sky: 'Á©∫',
        maxHeight: 'ÊúÄÂ§ßÈ´ò„Åï',
        none: '„Å™„Åó',
        acquired: 'Áç≤ÂæóÔºÅ',
        confirmHome: '„Éõ„Éº„É†„Å´Êàª„Çä„Åæ„Åô„ÅãÔºü'
    },
    zh: {
        title: 'AROA',
        subtitle: 'A Road Of Adventure',
        startGame: 'ÂºÄÂßãÊ∏∏Êàè',
        continueGame: 'ÁªßÁª≠',
        settings: 'ËÆæÁΩÆ',
        language: 'ËØ≠Ë®Ä',
        sound: 'Â£∞Èü≥',
        skip: 'Ë∑≥Ëøá ‚Ä∫',
        next: '‰∏ã‰∏ÄÊ≠•',
        intro: [
            { icon: 'üåå', title: 'Â§™Âàù...', text: 'Êó†Â∞ΩÁöÑ<span class="hl">ÂÆáÂÆôÊ∑±Ê∏ä</span>...<br>‰∏Ä‰∏™ÂæÆÂ∞èÁöÑ<span class="gold">ÁÅ´Ëä±</span>Âç≥Â∞ÜÁÇπÁáÉ„ÄÇ' },
            { icon: '‚ú®', title: 'ÊÑèËØÜËØûÁîü', text: '‰Ω†Ëøò<span class="hl">‰ªÄ‰πàÈÉΩ‰∏çÊòØ</span>„ÄÇ<br>Âè™Êúâ<span class="gold">Â≠òÂú®ÁöÑÊÑèÂøó</span>Âú®Èó™ÁÉÅ„ÄÇ' }
        ],
        dice: { title: 'üé≤ Âá∫ÁîüÂú∞ÂÜ≥ÂÆö', desc: 'È™∞Â≠êÂÜ≥ÂÆö‰Ω†ÁöÑÂá∫ÁîüÂú∞', roll: 'Êé∑È™∞Â≠ê', rolling: 'ÂÜ≥ÂÆö‰∏≠...', accept: 'Êé•ÂèóËøô‰∏™ÂëΩËøê' },
        afterBirth: env => [
            { icon: env.icon, title: env.name, text: `Âú®<span class="hl">${env.name}</span>Âá∫Áîü‰∫Ü„ÄÇ<br><br><span class="gold">"${env.desc}"</span><br><span class="danger">‚ö†Ô∏è ${env.weak}</span>` },
            { icon: 'ü¶†', title: 'Á¨¨‰∏Ä‰∏™ÁîüÂëΩ', text: '‰∏Ä‰∏™ÂæÆÂ∞èÁöÑ<span class="hl">ÂçïÁªÜËÉû</span>„ÄÇ<br>Ë¶ÅÁîüÂ≠òÔºåÂ∞±ÂøÖÈ°ª<span class="gold">ËøõÈ£ü</span>„ÄÇ' },
            { icon: '‚öîÔ∏è', title: 'ÁîüÂ≠òÂºÄÂßã', text: '<span class="danger">Êõ¥Â§ßÁöÑÂ≠òÂú®</span>Âú®ÁåéÈ£ü‰Ω†„ÄÇ<br>ÂêÉÊéâ<span class="hl">Â∞èÁöÑ</span>ÔºåÁÑ∂Âêé<span class="gold">ÊàêÈïø</span>„ÄÇ' }
        ],
        start: 'ÂºÄÂßãÂÜíÈô©',
        gameover: 'Ë¢´ÂêÉÊéâ‰∫ÜÔºÅ',
        gameoverDesc: 'Ë¢´Êõ¥Â§ßÁöÑÂ≠òÂú®ÂêûÂô¨‰∫Ü„ÄÇ',
        retry: 'ÈáçËØï',
        home: '‰∏ªÈ°µ',
        clear: 'Â§öÁªÜËÉûËøõÂåñÔºÅ',
        clearDesc: 'Ë∂ÖË∂ä‰∫ÜÂçïÁªÜËÉûÁöÑÊûÅÈôêÔºÅ',
        nextPhase: 'ÂâçÂæÄPhase 2ÔºÅ',
        p2Intro: [
            { icon: 'üèîÔ∏è', title: 'ÂêëÈôÜÂú∞ÔºÅ', text: 'Ë∂ÖË∂äÂ§ßÊµ∑<br><span class="hl">ÂπøÈòîÁöÑÈôÜÂú∞</span>Âú®Á≠âÂæÖ„ÄÇ' },
            { icon: 'ü¶é', title: 'Êñ∞ÊåëÊàò', text: '<span class="danger">ÈáçÂäõ</span>ÊòØÊñ∞ÁöÑÊïå‰∫∫ÔºÅ<br><span class="gold">Ë∑≥Ë∑É</span>Âπ∂<span class="hl">ÊîÄÁôª</span>„ÄÇ' }
        ],
        p2Start: 'ÂºÄÂßãÊîÄÁôªÔºÅ',
        p2Gameover: 'Âù†ËêΩÔºÅ',
        p2GameoverDesc: 'ÊéâÂæóÂ§™Ê∑±‰∫Ü„ÄÇ',
        p2Clear: 'ÂêëÂ§©Á©∫ÔºÅ',
        p2ClearDesc: 'ÂæÅÊúç‰∫ÜÈôÜÂú∞ÔºÅ',
        // ÈÄöÁî®UI
        height: 'È´òÂ∫¶',
        score: 'ÂàÜÊï∞',
        parts: 'Ë∫´‰ΩìÈÉ®‰ª∂',
        stage2: 'Stage 2: Ëú•Ëú¥',
        sky: 'Â§©Á©∫',
        maxHeight: 'ÊúÄÂ§ßÈ´òÂ∫¶',
        none: 'Êó†',
        acquired: 'Ëé∑ÂæóÔºÅ',
        confirmHome: 'ËøîÂõû‰∏ªÈ°µÔºü'
    }
};

// ========================================
// Game State
// ========================================
const GameState = {
    currentLang: localStorage.getItem('aroa-lang') || 'ko',
    soundOn: localStorage.getItem('aroa-sound') !== 'false',
    prologueDone: localStorage.getItem('aroa-prologue-done') === 'true',
    envId: localStorage.getItem('aroa-env') || null,
    phase1Clear: localStorage.getItem('aroa-phase1-clear') === 'true',
    phase2Clear: localStorage.getItem('aroa-phase2-clear') === 'true',
    phase3Clear: localStorage.getItem('aroa-phase3-clear') === 'true',
    currentPhase: 1,
    score: 0,
    eaten: 0,
    maxSize: CONFIG.INITIAL_SIZE,
    parts: { eye: 0, mouth: 0, arm: 0, leg: 0, tail: 0, antenna: 0, wing: 0, shell: 0, claw: 0, lung: 0 },
    // Phase 2 Ï†ÑÏö© ÏÉÅÌÉú
    height: 0,
    maxHeight: 0,
    // Phase 3 Ï†ÑÏö© ÏÉÅÌÉú
    runnerStage: parseInt(localStorage.getItem('aroa-runner-stage')) || 0,
    runnerDist: parseFloat(localStorage.getItem('aroa-runner-dist')) || 0,
    creature: JSON.parse(localStorage.getItem('aroa-creature') || 'null'),
    evolutionGauge: parseInt(localStorage.getItem('aroa-evo-gauge')) || 0,
    evolutionLevel: parseInt(localStorage.getItem('aroa-evo-level')) || 0,
    // Phase 4 Ïö∞Ï£ºÏÑºÌÑ∞ ÏÉÅÌÉú
    creatureName: localStorage.getItem('aroa-creature-name') || null,
    spaceLuck: parseInt(localStorage.getItem('aroa-space-luck')) || 0,
    spaceRank: parseInt(localStorage.getItem('aroa-space-rank')) || 1,
    
    save() {
        localStorage.setItem('aroa-lang', this.currentLang);
        localStorage.setItem('aroa-sound', this.soundOn);
        localStorage.setItem('aroa-prologue-done', this.prologueDone);
        if (this.envId) localStorage.setItem('aroa-env', this.envId);
        localStorage.setItem('aroa-phase1-clear', this.phase1Clear);
        localStorage.setItem('aroa-phase2-clear', this.phase2Clear);
        localStorage.setItem('aroa-phase3-clear', this.phase3Clear);
        localStorage.setItem('aroa-parts', JSON.stringify(this.parts));
        localStorage.setItem('aroa-runner-stage', this.runnerStage);
        localStorage.setItem('aroa-runner-dist', this.runnerDist);
        localStorage.setItem('aroa-evo-gauge', this.evolutionGauge);
        localStorage.setItem('aroa-evo-level', this.evolutionLevel);
        if (this.creature) localStorage.setItem('aroa-creature', JSON.stringify(this.creature));
        // Ïö∞Ï£ºÏÑºÌÑ∞ Ï†ÄÏû•
        if (this.creatureName) localStorage.setItem('aroa-creature-name', this.creatureName);
        localStorage.setItem('aroa-space-luck', this.spaceLuck);
        localStorage.setItem('aroa-space-rank', this.spaceRank);
    },
    
    load() {
        const savedParts = localStorage.getItem('aroa-parts');
        if (savedParts) {
            try {
                const parsed = JSON.parse(savedParts);
                Object.assign(this.parts, parsed);
            } catch(e) {}
        }
        const savedCreature = localStorage.getItem('aroa-creature');
        if (savedCreature) {
            try { this.creature = JSON.parse(savedCreature); } catch(e) { this.creature = null; }
        }
        this.evolutionGauge = parseInt(localStorage.getItem('aroa-evo-gauge')) || 0;
        this.evolutionLevel = parseInt(localStorage.getItem('aroa-evo-level')) || 0;
        this.spaceLuck = parseInt(localStorage.getItem('aroa-space-luck')) || 0;
        this.creatureName = localStorage.getItem('aroa-creature-name') || null;
        this.spaceRank = parseInt(localStorage.getItem('aroa-space-rank')) || 1;
    },
    
    reset() {
        this.score = 0;
        this.eaten = 0;
        this.maxSize = CONFIG.INITIAL_SIZE;
    },
    
    resetP2() {
        this.score = 0;
        this.height = 0;
        this.maxHeight = 0;
    },
    
    resetP3() {
        // ÏßÑÌôî ÏÉÅÌÉú Ïú†ÏßÄ - Î¶¨ÏÖãÌïòÏßÄ ÏïäÏùå
    },
    
    resetParts() {
        this.parts = { eye: 0, mouth: 0, arm: 0, leg: 0, tail: 0, antenna: 0, wing: 0, shell: 0, claw: 0, lung: 0 };
    },
    
    t(key) {
        return TRANSLATIONS[this.currentLang]?.[key] || TRANSLATIONS.ko[key] || key;
    },
    
    // ÌòÑÏû¨ ÌôòÍ≤ΩÏùò ÏßÑÌôî ÌååÏ∏† Í∞ÄÏ†∏Ïò§Í∏∞
    getRegionTraits() {
        return EVOLUTION_TRAITS[this.envId] || EVOLUTION_TRAITS.ocean;
    },
    
    // IDÎ°ú ÌååÏ∏† Ï∞æÍ∏∞
    getTraitById(id) {
        for (const region of Object.values(EVOLUTION_TRAITS)) {
            const trait = region.find(t => t.id === id);
            if (trait) return trait;
        }
        return null;
    }
};

// ========================================
// PixiJS App
// ========================================
let pixiApp = null;
let gameLoop = null;

function initPixi(bgColor = 0x020010) {
    if (pixiApp) {
        pixiApp.destroy(true);
    }
    
    pixiApp = new PIXI.Application({
        width: window.innerWidth,
        height: window.innerHeight,
        backgroundColor: bgColor,
        resolution: Math.min(window.devicePixelRatio || 1, 2),
        autoDensity: true
    });
    
    document.getElementById('game-container').innerHTML = '';
    document.getElementById('game-container').appendChild(pixiApp.view);
    
    window.addEventListener('resize', () => {
        if (pixiApp) pixiApp.renderer.resize(window.innerWidth, window.innerHeight);
    });
    
    return pixiApp;
}

function createStarBackground(envColors = null) {
    if (!pixiApp) return;
    
    const colors = envColors ? [
        parseInt(envColors.bg1.replace('#', '0x')),
        parseInt(envColors.bg2.replace('#', '0x'))
    ] : [0x1a0030, 0x000830, 0x100020, 0x001040, 0x200040, 0x0a0025];
    
    // Nebula (Îçî ÎßéÏù¥, Îçî ÌôîÎ†§ÌïòÍ≤å)
    for (let i = 0; i < 8; i++) {
        const nebula = new PIXI.Graphics();
        const color = colors[i % colors.length];
        nebula.beginFill(color, 0.4);
        nebula.drawCircle(0, 0, 100 + Math.random() * 200);
        nebula.endFill();
        nebula.x = Math.random() * pixiApp.screen.width;
        nebula.y = Math.random() * pixiApp.screen.height;
        nebula.filters = [new PIXI.BlurFilter(50)];
        pixiApp.stage.addChild(nebula);
    }
    
    // Stars (Îçî ÎßéÏù¥, Îã§ÏñëÌïú ÏÉâÏÉÅ, Î∞òÏßùÏûÑ Ìö®Í≥º)
    const starColors = envColors ? 
        [parseInt(envColors.particle.replace('#', '0x'))] : 
        [0xffffff, 0xfff8dc, 0xadd8e6, 0xffb6c1, 0xe6e6fa, 0xffd700];
    
    const stars = [];
    for (let i = 0; i < 200; i++) {
        const star = new PIXI.Graphics();
        const size = Math.random() * 2 + 0.5;
        const color = starColors[Math.floor(Math.random() * starColors.length)];
        const isBright = Math.random() > 0.85;
        
        // Î∞ùÏùÄ Î≥ÑÏùÄ Í∏ÄÎ°úÏö∞ Ìö®Í≥º
        if (isBright) {
            star.beginFill(color, 0.2);
            star.drawCircle(0, 0, size * 4);
            star.endFill();
            star.beginFill(color, 0.4);
            star.drawCircle(0, 0, size * 2);
            star.endFill();
        }
        
        star.beginFill(color, 1);
        star.drawCircle(0, 0, size);
        star.endFill();
        
        star.x = Math.random() * pixiApp.screen.width;
        star.y = Math.random() * pixiApp.screen.height;
        star.baseAlpha = 0.3 + Math.random() * 0.7;
        star.alpha = star.baseAlpha;
        star.twinkleSpeed = 1.5 + Math.random() * 3;
        star.twinkleOffset = Math.random() * Math.PI * 2;
        star.isBright = isBright;
        
        pixiApp.stage.addChild(star);
        stars.push(star);
    }
    
    // Î≥Ñ Î∞òÏßùÏûÑ Ïï†ÎãàÎ©îÏù¥ÏÖò
    let time = 0;
    const twinkleLoop = (delta) => {
        time += delta * 0.02;
        stars.forEach(star => {
            const twinkle = Math.sin(time * star.twinkleSpeed + star.twinkleOffset);
            star.alpha = star.baseAlpha + twinkle * 0.4;
            if (star.isBright) {
                star.scale.set(1 + twinkle * 0.2);
            }
        });
    };
    pixiApp.ticker.add(twinkleLoop);
    
    // Ïú†ÏÑ± ÏÉùÏÑ± Ìï®Ïàò
    function createShootingStar() {
        const shootingStar = new PIXI.Graphics();
        
        // Ïú†ÏÑ± Íº¨Î¶¨
        for (let i = 0; i < 20; i++) {
            const alpha = 1 - (i / 20);
            shootingStar.beginFill(0xffffff, alpha * 0.6);
            shootingStar.drawCircle(-i * 3, i * 1.2, 2.5 - i * 0.1);
            shootingStar.endFill();
        }
        
        // Ïú†ÏÑ± Î®∏Î¶¨
        shootingStar.beginFill(0xffffff, 1);
        shootingStar.drawCircle(0, 0, 3);
        shootingStar.endFill();
        
        shootingStar.x = Math.random() * pixiApp.screen.width * 0.6;
        shootingStar.y = -30;
        shootingStar.rotation = Math.PI / 4;
        
        pixiApp.stage.addChild(shootingStar);
        
        const speed = 6 + Math.random() * 4;
        const animate = () => {
            shootingStar.x += speed;
            shootingStar.y += speed * 0.4;
            shootingStar.alpha -= 0.01;
            
            if (shootingStar.y > pixiApp.screen.height || shootingStar.alpha <= 0) {
                pixiApp.stage.removeChild(shootingStar);
                pixiApp.ticker.remove(animate);
            }
        };
        pixiApp.ticker.add(animate);
    }
    
    // Ïú†ÏÑ± Ï£ºÍ∏∞Ï†Å ÏÉùÏÑ±
    setInterval(() => {
        if (Math.random() > 0.6) createShootingStar();
    }, 2000);
}

// ========================================
// UI Helpers
// ========================================
const app = document.getElementById('app');

function showEvolution(icon, title, desc, fx) {
    const popup = document.getElementById('evo-popup');
    document.getElementById('evo-icon').textContent = icon;
    document.getElementById('evo-title').textContent = title;
    document.getElementById('evo-desc').textContent = desc;
    document.getElementById('evo-fx').textContent = '‚ú® ' + fx;
    popup.classList.add('show');
    setTimeout(() => popup.classList.remove('show'), 2000);
}

// ========================================
// Title Screen
// ========================================
function showTitle() {
    initPixi();
    createStarBackground();
    
    const t = GameState.t.bind(GameState);
    const lang = GameState.currentLang;
    
    // Îã§Íµ≠Ïñ¥ ÌÖçÏä§Ìä∏
    const titleTexts = {
        ko: {
            google: 'GoogleÎ°ú ÏãúÏûëÌïòÍ∏∞',
            guest: 'Í≤åÏä§Ìä∏Î°ú ÏãúÏûëÌïòÍ∏∞',
            langName: 'ÌïúÍµ≠Ïñ¥',
            guestTitle: 'Ïû†Íπê!',
            guestText: 'Í≤åÏä§Ìä∏ Î™®ÎìúÎäî <strong>Ï†ÄÏû•ÎêòÏßÄ ÏïäÏäµÎãàÎã§.</strong><br><br>Ïï±ÏùÑ Ï¢ÖÎ£åÌïòÎ©¥ Ï≤òÏùåÎ∂ÄÌÑ∞ Îã§Ïãú ÏãúÏûëÌï¥Ïïº Ìï¥Ïöî.<br><br>Í∞ÄÎä•ÌïòÎ©¥ <strong>Google Î°úÍ∑∏Ïù∏</strong>ÏùÑ Ï∂îÏ≤úÎìúÎ†§Ïöî! üôè',
            guestToGoogle: 'üîµ GoogleÎ°ú ÏãúÏûëÌïòÍ∏∞',
            guestContinue: 'Í∑∏ÎûòÎèÑ Í≤åÏä§Ìä∏Î°ú ÏãúÏûë',
            close: 'Îã´Í∏∞'
        },
        en: {
            google: 'Continue with Google',
            guest: 'Continue as Guest',
            langName: 'English',
            guestTitle: 'Wait!',
            guestText: 'Guest mode <strong>does not save progress.</strong><br><br>If you close the app, you\'ll have to start over.<br><br>We recommend <strong>Google login</strong> if possible! üôè',
            guestToGoogle: 'üîµ Continue with Google',
            guestContinue: 'Continue as Guest anyway',
            close: 'Close'
        }
    };
    const txt = titleTexts[lang] || titleTexts.ko;
    
    app.innerHTML = `
        <div class="title-screen">
            <!-- ÎîîÎ≤ÑÍ∑∏: Ïä§ÌÖåÏù¥ÏßÄ ÏÑ†ÌÉù (ÏµúÏÉÅÎã®) -->
            <div style="position: fixed; top: calc(10px + var(--safe-top)); left: 50%; transform: translateX(-50%); display: flex; gap: 8px; z-index: 100;">
                <button id="btn-phase1" style="background: rgba(0,180,216,0.5); border: 1px solid rgba(0,180,216,0.8); border-radius: 8px; padding: 6px 12px; color: #fff; font-size: 0.75rem;">ü¶† P1</button>
                <button id="btn-phase2" style="background: rgba(16,185,129,0.5); border: 1px solid rgba(16,185,129,0.8); border-radius: 8px; padding: 6px 12px; color: #fff; font-size: 0.75rem;">üèîÔ∏è P2</button>
                <button id="btn-phase3" style="background: rgba(157,78,221,0.5); border: 1px solid rgba(157,78,221,0.8); border-radius: 8px; padding: 6px 12px; color: #fff; font-size: 0.75rem;">üèÉ P3</button>
                <button id="btn-phase4" style="background: rgba(100,100,200,0.5); border: 1px solid rgba(100,100,200,0.8); border-radius: 8px; padding: 6px 12px; color: #fff; font-size: 0.75rem;">üöÄ P4</button>
            </div>
            
            <!-- Î°úÍ≥† -->
            <div class="logo-section">
                <div class="logo-icon">üöÄ</div>
                <h1 class="logo-title">AROA</h1>
                <p class="logo-subtitle">A Road Of Adventure</p>
            </div>
            
            <!-- Î°úÍ∑∏Ïù∏ Î≤ÑÌäº -->
            <div class="button-section">
                <button class="login-btn btn-google" id="btn-google">
                    <svg class="google-icon" viewBox="0 0 24 24">
                        <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                        <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                        <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                        <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                    </svg>
                    <span>${txt.google}</span>
                </button>
                
                <button class="login-btn btn-guest" id="btn-guest">
                    <span>üë§</span>
                    <span>${txt.guest}</span>
                </button>
            </div>
            
            <!-- ÌïòÎã® ÏÑ§Ï†ï -->
            <div class="settings-section">
                <button class="setting-btn" id="btn-language">
                    <span class="icon">üåç</span>
                    <span>${txt.langName}</span>
                </button>
                <button class="setting-btn" id="btn-sound">
                    <span class="icon">${GameState.soundOn ? 'üîä' : 'üîá'}</span>
                    <span>${GameState.soundOn ? 'ON' : 'OFF'}</span>
                </button>
            </div>
            
            <!-- Î≤ÑÏ†Ñ -->
            <div class="version-info">v1.0.0 | ¬© 2025 BOKLUCK</div>
        </div>
        
        <!-- Í≤åÏä§Ìä∏ Í≤ΩÍ≥† Î™®Îã¨ -->
        <div class="guest-modal-overlay" id="guest-modal">
            <div class="guest-modal-content">
                <div class="warning-icon">‚ö†Ô∏è</div>
                <h2 class="warning-title">${txt.guestTitle}</h2>
                <p class="warning-text">${txt.guestText}</p>
                <div class="warning-buttons">
                    <button class="warning-btn btn-recommend" id="guest-to-google">${txt.guestToGoogle}</button>
                    <button class="warning-btn btn-continue" id="guest-continue">${txt.guestContinue}</button>
                </div>
            </div>
        </div>
        
        <!-- Ïñ∏Ïñ¥ ÏÑ†ÌÉù Î™®Îã¨ -->
        <div class="lang-modal-overlay" id="lang-modal">
            <div class="lang-modal-content">
                <h2 class="lang-modal-title">üåç Language</h2>
                <div class="language-list">
                    <button class="language-btn ${lang === 'ko' ? 'active' : ''}" data-lang="ko">
                        <span class="flag">üá∞üá∑</span>
                        <span>ÌïúÍµ≠Ïñ¥</span>
                    </button>
                    <button class="language-btn ${lang === 'en' ? 'active' : ''}" data-lang="en">
                        <span class="flag">üá∫üá∏</span>
                        <span>English</span>
                    </button>
                </div>
                <button class="lang-modal-close" id="lang-modal-close">${txt.close}</button>
            </div>
        </div>
    `;
    
    // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
    document.getElementById('btn-google').onclick = () => {
        alert('Google Î°úÍ∑∏Ïù∏ (Firebase Ïó∞Îèô ÏòàÏ†ï)');
    };
    
    document.getElementById('btn-guest').onclick = () => {
        document.getElementById('guest-modal').classList.add('show');
    };
    
    document.getElementById('guest-to-google').onclick = () => {
        document.getElementById('guest-modal').classList.remove('show');
        alert('Google Î°úÍ∑∏Ïù∏ (Firebase Ïó∞Îèô ÏòàÏ†ï)');
    };
    
    document.getElementById('guest-continue').onclick = () => {
        document.getElementById('guest-modal').classList.remove('show');
        // Í≤åÏä§Ìä∏Î°ú ÏãúÏûë - ÌîÑÎ°§Î°úÍ∑∏Î°ú Ïù¥Îèô
        GameState.prologueDone = false;
        GameState.envId = null;
        GameState.phase1Clear = false;
        GameState.phase2Clear = false;
        GameState.evolutionGauge = 0;
        GameState.evolutionLevel = 0;
        GameState.creature = null;
        GameState.reset();
        GameState.save();
        showPrologueIntro();
    };
    
    document.getElementById('guest-modal').onclick = (e) => {
        if (e.target.id === 'guest-modal') {
            document.getElementById('guest-modal').classList.remove('show');
        }
    };
    
    document.getElementById('btn-language').onclick = () => {
        document.getElementById('lang-modal').classList.add('show');
    };
    
    document.getElementById('lang-modal-close').onclick = () => {
        document.getElementById('lang-modal').classList.remove('show');
    };
    
    document.getElementById('lang-modal').onclick = (e) => {
        if (e.target.id === 'lang-modal') {
            document.getElementById('lang-modal').classList.remove('show');
        }
    };
    
    document.querySelectorAll('.language-btn').forEach(btn => {
        btn.onclick = () => {
            GameState.currentLang = btn.dataset.lang;
            GameState.save();
            document.getElementById('lang-modal').classList.remove('show');
            showTitle(); // ÌôîÎ©¥ ÏÉàÎ°úÍ≥†Ïπ®
        };
    });
    
    document.getElementById('btn-sound').onclick = () => {
        GameState.soundOn = !GameState.soundOn;
        GameState.save();
        showTitle(); // ÌôîÎ©¥ ÏÉàÎ°úÍ≥†Ïπ®
    };
    
    // ÎîîÎ≤ÑÍ∑∏: Ïä§ÌÖåÏù¥ÏßÄ ÏßÅÏ†ë Ïù¥Îèô
    document.getElementById('btn-phase1').onclick = () => {
        if (!GameState.envId) {
            GameState.envId = 'ocean';
            GameState.design = { primary: '#00b4d8', secondary: '#0077b6', wobble: 0.7 };
        }
        GameState.phase1Clear = false;
        GameState.save();
        startPhase1();
    };
    
    document.getElementById('btn-phase2').onclick = () => {
        if (!GameState.envId) {
            GameState.envId = 'ocean';
            GameState.design = { primary: '#00b4d8', secondary: '#0077b6', wobble: 0.7 };
        }
        GameState.phase1Clear = true;
        GameState.phase2Clear = false;
        GameState.save();
        showClimbDice();
    };
    
    document.getElementById('btn-phase3').onclick = () => {
        if (!GameState.envId) {
            GameState.envId = 'ocean';
            GameState.design = { primary: '#00b4d8', secondary: '#0077b6', wobble: 0.7 };
        }
        GameState.phase1Clear = true;
        GameState.phase2Clear = true;
        GameState.phase3Clear = false;
        GameState.save();
        showPhase3Intro();
    };
    
    document.getElementById('btn-phase4').onclick = () => {
        if (!GameState.envId) {
            GameState.envId = 'ocean';
            GameState.design = { primary: '#00b4d8', secondary: '#0077b6', wobble: 0.7 };
        }
        if (!GameState.creature) {
            GameState.creature = generateCreatureFromEnv(GameState.envId);
        }
        GameState.phase1Clear = true;
        GameState.phase2Clear = true;
        GameState.phase3Clear = true;
        GameState.save();
        showSpaceIntro();
    };
}

// ========================================
// Settings
// ========================================
function showSettings() {
    const t = GameState.t.bind(GameState);
    
    app.innerHTML = `
        <div class="page-center">
            <div class="page-content" style="max-width: 340px;">
                <h2 class="page-title">‚öôÔ∏è ${t('settings')}</h2>
                
                <div style="background: var(--bg-surface); border-radius: 12px; padding: 16px; margin-bottom: 20px; text-align: left;">
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <span>üåç ${t('language')}</span>
                        <button class="btn btn-sm btn-ghost" id="btn-lang">${GameState.currentLang.toUpperCase()}</button>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px 0;">
                        <span>üîä ${t('sound')}</span>
                        <button class="btn btn-sm btn-ghost" id="btn-sound">${GameState.soundOn ? 'ON' : 'OFF'}</button>
                    </div>
                </div>
                
                <button class="btn btn-primary btn-block" id="btn-back">‚Üê Back</button>
            </div>
        </div>
    `;
    
    document.getElementById('btn-lang').onclick = showLanguageModal;
    document.getElementById('btn-sound').onclick = () => {
        GameState.soundOn = !GameState.soundOn;
        GameState.save();
        showSettings();
    };
    document.getElementById('btn-back').onclick = showTitle;
}

function showLanguageModal() {
    const modal = document.createElement('div');
    modal.className = 'lang-modal show';
    modal.innerHTML = `
        <div class="modal-box">
            <h2 class="page-title">üåç Language</h2>
            <div class="lang-options">
                <button class="lang-btn ${GameState.currentLang === 'ko' ? 'active' : ''}" data-lang="ko">üá∞üá∑ ÌïúÍµ≠Ïñ¥</button>
                <button class="lang-btn ${GameState.currentLang === 'en' ? 'active' : ''}" data-lang="en">üá∫üá∏ English</button>
                <button class="lang-btn ${GameState.currentLang === 'ja' ? 'active' : ''}" data-lang="ja">üáØüáµ Êó•Êú¨Ë™û</button>
                <button class="lang-btn ${GameState.currentLang === 'zh' ? 'active' : ''}" data-lang="zh">üá®üá≥ ‰∏≠Êñá</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    
    modal.querySelectorAll('.lang-btn').forEach(btn => {
        btn.onclick = () => {
            GameState.currentLang = btn.dataset.lang;
            GameState.save();
            modal.remove();
            showSettings();
        };
    });
    
    modal.onclick = e => { if (e.target === modal) modal.remove(); };
}

// ========================================
// Prologue - Intro Story
// ========================================
function showPrologueIntro() {
    initPixi();
    createStarBackground();
    
    const t = GameState.t.bind(GameState);
    const intro = TRANSLATIONS[GameState.currentLang].intro;
    let idx = 0;
    
    function render() {
        const s = intro[idx];
        const isLast = idx === intro.length - 1;
        
        app.innerHTML = `
            <button class="skip-btn" id="skip-btn">${t('skip')}</button>
            <div class="page-center">
                <div class="page-content">
                    <div class="page-icon">${s.icon}</div>
                    <h2 class="page-title">${s.title}</h2>
                    <p class="page-text">${s.text}</p>
                    <div class="dots">
                        ${intro.map((_, i) => `<div class="dot ${i < idx ? 'done' : ''} ${i === idx ? 'active' : ''}"></div>`).join('')}
                    </div>
                    <button class="btn btn-primary btn-block" id="btn-next">${isLast ? 'üé≤ ' + TRANSLATIONS[GameState.currentLang].dice.title : t('next')}</button>
                </div>
            </div>
        `;
        
        document.getElementById('btn-next').onclick = () => {
            if (isLast) showDice();
            else { idx++; render(); }
        };
        document.getElementById('skip-btn').onclick = () => {
            const roll = Math.floor(Math.random() * 100) + 1;
            const env = getEnvByRoll(roll);
            GameState.envId = env.id;
            GameState.prologueDone = true;
            GameState.save();
            startPhase1();
        };
    }
    
    render();
}

// ========================================
// Prologue - Dice
// ========================================
function showDice() {
    const t = GameState.t.bind(GameState);
    const dice = TRANSLATIONS[GameState.currentLang].dice;
    
    app.innerHTML = `
        <div class="page-center">
            <div class="page-content">
                <h2 class="page-title">${dice.title}</h2>
                <p class="page-text">${dice.desc}</p>
                
                <div class="env-ranges">
                    ${ENVIRONMENTS.map(e => `<div class="env-range"><span>${e.icon}</span><span>${e.range[0]}-${e.range[1]}</span></div>`).join('')}
                </div>
                
                <div class="dice-box" id="dice">üé≤</div>
                <div class="dice-result" id="result"></div>
                <button class="btn btn-primary btn-block" id="btn-roll">${dice.roll}</button>
            </div>
        </div>
    `;
    
    const diceEl = document.getElementById('dice');
    const resultEl = document.getElementById('result');
    const btn = document.getElementById('btn-roll');
    
    btn.onclick = () => {
        btn.disabled = true;
        btn.textContent = dice.rolling;
        diceEl.classList.add('rolling');
        SFX.play('dice'); // Ï£ºÏÇ¨ÏúÑ Ìö®Í≥ºÏùå
        
        const anim = setInterval(() => {
            diceEl.textContent = Math.floor(Math.random() * 100) + 1;
        }, 50);
        
        setTimeout(() => {
            clearInterval(anim);
            diceEl.classList.remove('rolling');
            
            const roll = Math.floor(Math.random() * 100) + 1;
            const env = getEnvByRoll(roll);
            
            diceEl.textContent = roll;
            diceEl.style.cssText = 'font-size: 3rem; font-weight: 900; color: var(--primary); text-shadow: 0 0 20px rgba(79, 195, 247, 0.8);';
            
            // Change background
            initPixi(parseInt(env.colors.bg1.replace('#', '0x')));
            createStarBackground(env.colors);
            
            resultEl.innerHTML = `
                <div class="result-icon">${env.icon}</div>
                <div class="result-name">${env.name}</div>
                <div class="result-desc">${env.desc}</div>
                <div class="result-weak">‚ö†Ô∏è ${env.weak}</div>
            `;
            
            btn.disabled = false;
            btn.textContent = dice.accept;
            btn.onclick = () => {
                GameState.envId = env.id;
                GameState.save();
                showAfterBirth(env);
            };
        }, 1500);
    };
}

// ========================================
// Prologue - After Birth Story
// ========================================
function showAfterBirth(env) {
    const t = GameState.t.bind(GameState);
    const story = TRANSLATIONS[GameState.currentLang].afterBirth(env);
    let idx = 0;
    
    function render() {
        const s = story[idx];
        const isLast = idx === story.length - 1;
        
        app.innerHTML = `
            <button class="skip-btn" id="skip-btn">${t('skip')}</button>
            <div class="page-center">
                <div class="page-content">
                    <div class="page-icon">${s.icon}</div>
                    <h2 class="page-title">${s.title}</h2>
                    <p class="page-text">${s.text}</p>
                    <div class="dots">
                        ${story.map((_, i) => `<div class="dot ${i < idx ? 'done' : ''} ${i === idx ? 'active' : ''}"></div>`).join('')}
                    </div>
                    <button class="btn btn-primary btn-block" id="btn-next">${isLast ? 'üöÄ ' + t('start') : t('next')}</button>
                </div>
            </div>
        `;
        
        document.getElementById('btn-next').onclick = () => {
            if (isLast) {
                GameState.prologueDone = true;
                GameState.save();
                startPhase1();
            } else { idx++; render(); }
        };
        document.getElementById('skip-btn').onclick = () => {
            GameState.prologueDone = true;
            GameState.save();
            startPhase1();
        };
    }
    
    render();
}

// ========================================
// Phase 1 - Cell Survival Game
// ========================================
let player, foods = [], enemies = [];
let joyPos = { x: 0, y: 0 }, joyActive = false, keys = {};
let lastEnemySpawn = 0, dashCooldown = 0, dashing = false;
let gameRunning = false, time = 0;
let currentEnv = null;

function startPhase1() {
    GameState.reset();
    currentEnv = getEnvById(GameState.envId);
    
    initPixi(parseInt(currentEnv.colors.bg1.replace('#', '0x')));
    createStarBackground(currentEnv.colors);
    
    const t = GameState.t.bind(GameState);
    
    app.innerHTML = `
        <div class="hud-top">
            <div class="hud-panel" style="min-width: 130px;">
                <div class="hud-name" id="player-name">${currentEnv.icon} ${currentEnv.name}</div>
                <div class="hud-row"><span>‚ö°</span><span class="hud-val" id="h-score">0</span><span class="hud-label">Ï†êÏàò</span></div>
                <div class="hud-row"><span>üç¥</span><span class="hud-val" id="h-eaten">0</span><span class="hud-label">ÏÑ≠Ï∑®</span></div>
                <div class="size-bar">
                    <span style="font-size: 0.65rem;">üìè</span>
                    <div class="size-track"><div class="size-fill" id="h-size" style="width: 15%;"></div></div>
                    <span class="size-num" id="h-sizeN">12</span>
                </div>
            </div>
            <div class="hud-panel parts-panel">
                <div class="parts-title">üß¨ Ïã†Ï≤¥ ÌååÏ∏†</div>
                <div class="parts-grid" id="h-parts"><span style="font-size: 0.65rem; color: #666;">ÏóÜÏùå</span></div>
                <div class="progress-section">
                    <div class="progress-label"><span class="progress-left">Îã§Ïùå ÌååÏ∏†</span><span class="progress-right" id="h-partP">0/15</span></div>
                    <div class="progress-track"><div class="progress-fill evo" id="h-partB" style="width: 0%;"></div></div>
                </div>
            </div>
            <div class="hud-btns">
                <button class="hud-btn" id="btn-skip-phase" title="ÌÖåÏä§Ìä∏: Îã§Ïùå Phase" style="background: linear-gradient(135deg, #ff6b6b, #feca57); font-size: 0.7rem;">‚è≠Ô∏è</button>
                <button class="hud-btn" id="btn-home" title="Ìôà">üè†</button>
                <button class="hud-btn" id="btn-pause" title="ÏùºÏãúÏ†ïÏßÄ">‚è∏Ô∏è</button>
            </div>
        </div>
        <div class="hud-bottom">
            <div class="stage-bar">
                <div class="stage-row">
                    <span class="stage-cur">ü¶† Stage 1: ÏÑ∏Ìè¨</span>
                    <span class="stage-next">Îã§ÏÑ∏Ìè¨: <span id="h-stageP">0/2000</span></span>
                </div>
                <div class="progress-track"><div class="progress-fill stage" id="h-stageB" style="width: 0%;"></div></div>
            </div>
        </div>
        <div class="controls">
            <div class="joystick" id="joystick"><div class="joy-base"></div><div class="joy-knob" id="joy-knob"></div></div>
            <button class="action-btn disabled" id="btn-dash" title="ÎåÄÏãú">üí®</button>
        </div>
        <div class="modal" id="modal-gameover">
            <div class="modal-box">
                <div class="modal-icon">üíÄ</div>
                <h2 class="modal-title fail">${t('gameover')}</h2>
                <p class="modal-desc">${t('gameoverDesc')}</p>
                <div class="modal-stats">
                    <div class="stat-row"><span class="stat-label">Ï†êÏàò</span><span class="stat-val" id="go-score">0</span></div>
                    <div class="stat-row"><span class="stat-label">ÏÑ≠Ï∑®</span><span class="stat-val" id="go-eaten">0</span></div>
                    <div class="stat-row"><span class="stat-label">ÏµúÎåÄ ÌÅ¨Í∏∞</span><span class="stat-val" id="go-maxsize">0</span></div>
                </div>
                <div class="modal-btns">
                    <button class="btn btn-primary btn-block" id="btn-retry">üîÑ ${t('retry')}</button>
                </div>
            </div>
        </div>
        <div class="modal" id="modal-clear">
            <div class="modal-box">
                <div class="modal-icon">üéâ</div>
                <h2 class="modal-title win">${t('clear')}</h2>
                <p class="modal-desc">${t('clearDesc')}</p>
                <div class="modal-stats">
                    <div class="stat-row"><span class="stat-label">ÏµúÏ¢Ö Ï†êÏàò</span><span class="stat-val" id="cl-score">0</span></div>
                    <div class="stat-row"><span class="stat-label">ÌöçÎìù ÌååÏ∏†</span><span class="stat-val" id="cl-parts">0</span></div>
                </div>
                <div class="modal-btns">
                    <button class="btn btn-primary btn-block" id="btn-next">üèîÔ∏è ${t('nextPhase')}</button>
                </div>
            </div>
        </div>
    `;
    
    // Create game objects
    createPlayer();
    spawnFoods(CONFIG.MAX_FOODS);
    
    setupControls();
    setupGameHUD();
    
    foods = [];
    enemies = [];
    lastEnemySpawn = Date.now();
    time = 0;
    
    spawnFoods(CONFIG.MAX_FOODS);
    
    gameLoop = delta => updateGame(delta);
    pixiApp.ticker.add(gameLoop);
    gameRunning = true;
}

function createPlayer() {
    player = new PIXI.Container();
    player.x = pixiApp.screen.width / 2;
    player.y = pixiApp.screen.height / 2;
    player.size = CONFIG.INITIAL_SIZE;
    player.vx = 0;
    player.vy = 0;
    
    const body = new PIXI.Graphics();
    player.body = body;
    player.addChild(body);
    
    pixiApp.stage.addChild(player);
}

function drawPlayerBody() {
    const gfx = player.body;
    const size = player.size;
    const p = GameState.parts;
    const t = time;
    
    const primary = parseInt(currentEnv.colors.primary.replace('#', '0x'));
    const secondary = parseInt(currentEnv.colors.secondary.replace('#', '0x'));
    
    gfx.clear();
    
    // Tail
    if (p.tail > 0) {
        gfx.lineStyle(Math.max(3, size * 0.08), primary);
        for (let i = 0; i < p.tail; i++) {
            const tw = Math.sin(t * 3 + i) * size * 0.3;
            const oy = (i - (p.tail - 1) / 2) * size * 0.15;
            gfx.moveTo(-size * 0.7, oy);
            gfx.bezierCurveTo(-size * 1.1, tw + oy, -size * 1.4, -tw * 0.4 + oy, -size * 1.7, tw * 0.3 + oy);
        }
        gfx.lineStyle(0);
    }
    
    // Arms
    if (p.arm > 0) {
        gfx.lineStyle(Math.max(2, size * 0.06), primary);
        for (let i = 0; i < p.arm; i++) {
            const baseAngle = (0.2 + i * 0.18) * (i % 2 === 0 ? 1 : -1) * Math.PI;
            const wave = Math.sin(t * 2.5 + i) * 0.15;
            gfx.moveTo(Math.cos(baseAngle) * size * 0.85, Math.sin(baseAngle) * size * 0.85);
            gfx.quadraticCurveTo(Math.cos(baseAngle) * size * 1.3, Math.sin(baseAngle + wave) * size * 1.1, Math.cos(baseAngle) * size * 1.5, Math.sin(baseAngle + wave * 2) * size * 0.85);
        }
        gfx.lineStyle(0);
    }
    
    // Legs
    if (p.leg > 0) {
        gfx.lineStyle(Math.max(2, size * 0.05), secondary);
        for (let i = 0; i < p.leg; i++) {
            const baseAngle = Math.PI * 0.5 + (i - (p.leg - 1) / 2) * 0.22;
            const wave = Math.sin(t * 4 + i) * 0.15;
            gfx.moveTo(Math.cos(baseAngle) * size * 0.7, Math.sin(baseAngle) * size * 0.7);
            gfx.lineTo(Math.cos(baseAngle + wave) * size * 1.3, Math.sin(baseAngle) * size * 1.25);
        }
        gfx.lineStyle(0);
    }
    
    // Antenna
    if (p.antenna > 0) {
        gfx.lineStyle(2, primary);
        for (let i = 0; i < p.antenna; i++) {
            const aa = -Math.PI * 0.35 + i * 0.35;
            const wave = Math.sin(t * 3) * 0.1;
            gfx.moveTo(Math.cos(aa) * size * 0.6, Math.sin(aa) * size * 0.6);
            gfx.quadraticCurveTo(Math.cos(aa) * size * 1.1, Math.sin(aa) * size * 1.0, Math.cos(aa) * size * 1.4, Math.sin(aa + wave) * size * 1.1);
            gfx.lineStyle(0);
            gfx.beginFill(primary);
            gfx.drawCircle(Math.cos(aa) * size * 1.4, Math.sin(aa + wave) * size * 1.1, 4);
            gfx.endFill();
            gfx.lineStyle(2, primary);
        }
        gfx.lineStyle(0);
    }
    
    // Body
    gfx.beginFill(primary, 0.9);
    gfx.moveTo(size, 0);
    for (let i = 0; i < 12; i++) {
        const ang = (i / 12) * Math.PI * 2;
        const wobble = Math.sin(t * 2 + i * 0.8) * 2.5;
        gfx.lineTo(Math.cos(ang) * (size + wobble), Math.sin(ang) * (size + wobble));
    }
    gfx.closePath();
    gfx.endFill();
    
    // Inner
    gfx.beginFill(secondary, 0.4);
    gfx.drawCircle(0, 0, size * 0.7);
    gfx.endFill();
    
    // Highlight
    gfx.beginFill(0xffffff, 0.35);
    gfx.drawCircle(-size * 0.25, -size * 0.25, size * 0.35);
    gfx.endFill();
    
    // Eyes
    const eyeCount = Math.max(1, p.eye);
    for (let i = 0; i < eyeCount; i++) {
        const ex = (i - (eyeCount - 1) / 2) * size * 0.35;
        gfx.beginFill(0xffffff);
        gfx.drawCircle(ex, -size * 0.15, size * 0.22);
        gfx.endFill();
        gfx.beginFill(0x222222);
        gfx.drawCircle(ex + size * 0.04, -size * 0.15, size * 0.11);
        gfx.endFill();
        gfx.beginFill(0xffffff, 0.8);
        gfx.drawCircle(ex - size * 0.05, -size * 0.21, size * 0.05);
        gfx.endFill();
    }
    
    // Mouth
    if (p.mouth > 0) {
        gfx.lineStyle(2.5, secondary);
        gfx.arc(0, size * 0.25, size * 0.13, 0.2, Math.PI - 0.2);
        gfx.lineStyle(0);
    }
}

function spawnFoods(count) {
    for (let i = 0; i < count; i++) {
        if (foods.length >= CONFIG.MAX_FOODS) return;
        
        const food = new PIXI.Container();
        food.size = 4 + Math.random() * 10;
        food.x = Math.random() * pixiApp.screen.width;
        food.y = Math.random() * pixiApp.screen.height;
        
        // Ìï≠ÏÉÅ ÏõÄÏßÅÏù¥ÎèÑÎ°ù ÏµúÏÜå ÏÜçÎèÑ Î≥¥Ïû•
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.3 + Math.random() * 0.5; // ÏµúÏÜå 0.3 ÏÜçÎèÑ
        food.vx = Math.cos(angle) * speed;
        food.vy = Math.sin(angle) * speed;
        food.glowPhase = Math.random() * Math.PI * 2;
        
        if (Math.random() > 0.5) {
            const emoji = new PIXI.Text(currentEnv.creatures[Math.floor(Math.random() * currentEnv.creatures.length)], { fontSize: food.size * 2 });
            emoji.anchor.set(0.5);
            food.addChild(emoji);
        } else {
            const gfx = new PIXI.Graphics();
            gfx.beginFill(parseInt(currentEnv.colors.primary.replace('#', '0x')), 0.9);
            gfx.drawCircle(0, 0, food.size);
            gfx.endFill();
            food.addChild(gfx);
        }
        
        foods.push(food);
        pixiApp.stage.addChild(food);
    }
}

function spawnEnemy() {
    if (enemies.length >= CONFIG.MAX_ENEMIES) return;
    
    const enemy = new PIXI.Container();
    const pSize = player.size;
    const smaller = Math.random() < 0.4;
    let size = smaller ? pSize * (0.3 + Math.random() * 0.5) : pSize * (1.2 + Math.random() * 0.8);
    size = Math.max(8, Math.min(size, 100));
    
    enemy.size = size;
    enemy.speed = 0.8 + Math.random() * 1.2;
    enemy.angle = Math.random() * Math.PI * 2;
    enemy.wobble = Math.random();
    
    const side = Math.floor(Math.random() * 4);
    if (side === 0) { enemy.x = -50; enemy.y = Math.random() * pixiApp.screen.height; }
    else if (side === 1) { enemy.x = pixiApp.screen.width + 50; enemy.y = Math.random() * pixiApp.screen.height; }
    else if (side === 2) { enemy.x = Math.random() * pixiApp.screen.width; enemy.y = -50; }
    else { enemy.x = Math.random() * pixiApp.screen.width; enemy.y = pixiApp.screen.height + 50; }
    
    const gfx = new PIXI.Graphics();
    enemy.gfx = gfx;
    enemy.addChild(gfx);
    
    drawEnemy(enemy);
    
    enemies.push(enemy);
    pixiApp.stage.addChild(enemy);
}

function drawEnemy(enemy) {
    const gfx = enemy.gfx;
    const size = enemy.size;
    const t = time + enemy.wobble * 10;
    
    const canEat = enemy.size < player.size;
    
    gfx.clear();
    
    // Î®πÏùÑ Ïàò ÏûàÎäî Ï†ÅÏóêÎßå ÌôîÎ†§Ìïú Í∏ÄÎ°úÏö∞ Ìö®Í≥º (Ìù∞ÏÉâ+Í∏àÏÉâ ÌéÑÏä§)
    if (canEat) {
        const pulse = Math.sin(t * 4) * 0.3 + 0.7;
        // Ïô∏Î∂Ä Í∏ÄÎ°úÏö∞
        gfx.beginFill(0xffffff, 0.2 * pulse);
        gfx.drawCircle(0, 0, size * 1.6);
        gfx.endFill();
        // Ï§ëÍ∞Ñ Í∏ÄÎ°úÏö∞
        gfx.beginFill(0xffdd00, 0.3 * pulse);
        gfx.drawCircle(0, 0, size * 1.35);
        gfx.endFill();
        // ÌÖåÎëêÎ¶¨ ÎßÅ
        gfx.lineStyle(3, 0xffdd00, 0.8 * pulse);
        gfx.drawCircle(0, 0, size * 1.15);
        gfx.lineStyle(0);
    }
    
    // Î™∏Ï≤¥ - Î®πÏùÑ Ïàò ÏûàÏúºÎ©¥ Î∞ùÏùÄ Ï¥àÎ°ù, ÏïÑÎãàÎ©¥ Îπ®Í∞ÑÏÉâ
    const bodyColor = canEat ? 0x44ff88 : 0xff4466;
    const shadowColor = canEat ? 0x22aa55 : 0xcc2244;
    
    gfx.beginFill(bodyColor, 0.85);
    for (let i = 0; i < 10; i++) {
        const ang = (i / 10) * Math.PI * 2;
        const wobble = Math.sin(t * 2 + i + enemy.wobble * 5) * size * 0.12;
        const r = size + wobble;
        if (i === 0) gfx.moveTo(Math.cos(ang) * r, Math.sin(ang) * r);
        else gfx.lineTo(Math.cos(ang) * r, Math.sin(ang) * r);
    }
    gfx.closePath();
    gfx.endFill();
    
    // ÎÇ¥Î∂Ä Í∑∏Î¶ºÏûê
    gfx.beginFill(shadowColor, 0.4);
    gfx.drawCircle(0, 0, size * 0.6);
    gfx.endFill();
    
    // ÌïòÏù¥ÎùºÏù¥Ìä∏
    gfx.beginFill(0xffffff, 0.3);
    gfx.drawCircle(-size * 0.2, -size * 0.2, size * 0.25);
    gfx.endFill();
    
    // Îàà
    gfx.beginFill(0xffffff);
    gfx.drawCircle(size * 0.15, -size * 0.15, size * 0.2);
    gfx.endFill();
    
    // ÎèôÍ≥µ - Î®πÏùÑ Ïàò ÏûàÏúºÎ©¥ Í≤ÄÏ†ï, ÏúÑÌóòÌïòÎ©¥ Îπ®Í∞ï
    gfx.beginFill(canEat ? 0x333333 : 0xff0000);
    gfx.drawCircle(size * 0.2, -size * 0.15, size * 0.1);
    gfx.endFill();
    
    // ÏúÑÌóòÌïú Ï†ÅÏóêÎäî Í≤ΩÍ≥† ÌëúÏãú
    if (!canEat) {
        gfx.lineStyle(2, 0xff0000, 0.6);
        gfx.drawCircle(0, 0, size * 1.2);
        gfx.lineStyle(0);
    }
}

function setupControls() {
    const joy = document.getElementById('joystick');
    const knob = document.getElementById('joy-knob');
    
    const handleMove = (clientX, clientY) => {
        const rect = joy.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const maxDist = rect.width / 2 - 25;
        
        let dx = clientX - centerX;
        let dy = clientY - centerY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > maxDist) { dx = dx / dist * maxDist; dy = dy / dist * maxDist; }
        
        knob.style.transform = `translate(${dx}px, ${dy}px)`;
        joyPos = { x: dx / maxDist, y: dy / maxDist };
    };
    
    const handleEnd = () => {
        joyActive = false;
        joy.classList.remove('active');
        knob.style.transform = '';
        joyPos = { x: 0, y: 0 };
    };
    
    joy.addEventListener('touchstart', e => { e.preventDefault(); joyActive = true; joy.classList.add('active'); handleMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    joy.addEventListener('touchmove', e => { e.preventDefault(); if (joyActive) handleMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    joy.addEventListener('touchend', handleEnd);
    joy.addEventListener('mousedown', e => { joyActive = true; joy.classList.add('active'); handleMove(e.clientX, e.clientY); });
    window.addEventListener('mousemove', e => { if (joyActive) handleMove(e.clientX, e.clientY); });
    window.addEventListener('mouseup', handleEnd);
    
    window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if (e.key === ' ') tryDash(); });
    window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
    
    document.getElementById('btn-dash').onclick = tryDash;
}

function tryDash() {
    if (GameState.parts.tail === 0 || dashCooldown > 0 || dashing) return;
    
    dashing = true;
    dashCooldown = CONFIG.DASH_COOLDOWN;
    
    const dir = {
        x: joyPos.x || (keys.d || keys.arrowright ? 1 : keys.a || keys.arrowleft ? -1 : 0),
        y: joyPos.y || (keys.s || keys.arrowdown ? 1 : keys.w || keys.arrowup ? -1 : 0)
    };
    const len = Math.sqrt(dir.x * dir.x + dir.y * dir.y) || 1;
    
    player.vx = dir.x / len * CONFIG.DASH_SPEED;
    player.vy = dir.y / len * CONFIG.DASH_SPEED;
    
    setTimeout(() => { dashing = false; }, CONFIG.DASH_DURATION);
}

function setupGameHUD() {
    document.getElementById('btn-home').onclick = () => {
        if (confirm('ÌôàÏúºÎ°ú ÎèåÏïÑÍ∞ÄÏãúÍ≤†ÏäµÎãàÍπå?')) {
            gameRunning = false;
            if (gameLoop) pixiApp.ticker.remove(gameLoop);
            showTitle();
        }
    };
    
    document.getElementById('btn-pause').onclick = () => {
        gameRunning = !gameRunning;
        document.getElementById('btn-pause').textContent = gameRunning ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è';
    };
    
    // ÌÖåÏä§Ìä∏Ïö©: Îã§Ïùå PhaseÎ°ú Ïä§ÌÇµ
    document.getElementById('btn-skip-phase').onclick = () => {
        gameRunning = false;
        if (gameLoop) pixiApp.ticker.remove(gameLoop);
        GameState.phase1Clear = true;
        GameState.save();
        showPhase2Intro();
    };
    
    // Í≤åÏûÑÏò§Î≤Ñ Ïãú Îã§Ïãú ÏãúÏûë -> Í∞ôÏùÄ Ï∂úÏÉùÏßÄÎ°ú Ïû¨ÏãúÏûë
    document.getElementById('btn-retry').onclick = () => {
        document.getElementById('modal-gameover').classList.remove('show');
        if (gameLoop) pixiApp.ticker.remove(gameLoop);
        GameState.reset();
        // Ï∂úÏÉùÏßÄ Ïú†ÏßÄ (envId Ï¥àÍ∏∞Ìôî Ïïà Ìï®)
        startPhase1(); // Î∞îÎ°ú Í≤åÏûÑ ÏãúÏûë
    };
    
    document.getElementById('btn-next').onclick = () => {
        document.getElementById('modal-clear').classList.remove('show');
        if (gameLoop) pixiApp.ticker.remove(gameLoop);
        showPhase2Intro();
    };
}

function updateHUD() {
    document.getElementById('h-score').textContent = GameState.score;
    document.getElementById('h-eaten').textContent = GameState.eaten;
    document.getElementById('h-sizeN').textContent = Math.round(player.size);
    document.getElementById('h-size').style.width = `${(player.size / CONFIG.MAX_SIZE) * 100}%`;
    
    // Phase 1 ÌååÏ∏†Îßå Ïπ¥Ïö¥Ìä∏
    const p1PartKeys = ['eye', 'mouth', 'arm', 'leg', 'tail', 'antenna'];
    const totalP1Parts = p1PartKeys.reduce((sum, k) => sum + GameState.parts[k], 0);
    const partBase = totalP1Parts * CONFIG.GROWTH_THRESHOLD;
    const partProgress = ((GameState.eaten - partBase) / CONFIG.GROWTH_THRESHOLD) * 100;
    document.getElementById('h-partB').style.width = `${Math.min(100, Math.max(0, partProgress))}%`;
    document.getElementById('h-partP').textContent = `${Math.max(0, GameState.eaten - partBase)}/${CONFIG.GROWTH_THRESHOLD}`;
    
    document.getElementById('h-stageB').style.width = `${Math.min(100, (GameState.score / CONFIG.STAGE_THRESHOLD) * 100)}%`;
    document.getElementById('h-stageP').textContent = `${GameState.score}/${CONFIG.STAGE_THRESHOLD}`;
    
    // Phase 1 ÌååÏ∏†Îßå ÌëúÏãú
    let partsHtml = '';
    p1PartKeys.forEach(k => {
        if (GameState.parts[k] > 0) {
            partsHtml += `<div class="part-badge active"><span>${BODY_PARTS[k].icon}</span><span class="part-cnt">√ó${GameState.parts[k]}</span></div>`;
        }
    });
    document.getElementById('h-parts').innerHTML = partsHtml || '<span style="font-size: 0.65rem; color: #666;">ÏóÜÏùå</span>';
    
    document.getElementById('btn-dash').classList.toggle('disabled', GameState.parts.tail === 0);
}

function checkPartEvolution() {
    const p1PartKeys = ['eye', 'mouth', 'arm', 'leg', 'tail', 'antenna']; // Phase 1 Ï†ÑÏö© ÌååÏ∏†
    const totalP1Parts = p1PartKeys.reduce((sum, k) => sum + GameState.parts[k], 0);
    const threshold = (totalP1Parts + 1) * CONFIG.GROWTH_THRESHOLD;
    
    if (GameState.eaten >= threshold) {
        const available = p1PartKeys.filter(k => GameState.parts[k] < BODY_PARTS[k].max);
        if (available.length === 0) return;
        
        const key = available[Math.floor(Math.random() * available.length)];
        GameState.parts[key]++;
        
        const part = BODY_PARTS[key];
        showEvolution(part.icon, `${part.name} ÌöçÎìù!`, `${part.name} √ó${GameState.parts[key]}`, part.fx);
    }
}

function updateGame(delta) {
    if (!gameRunning) return;
    
    time += delta * 0.016;
    if (dashCooldown > 0) dashCooldown -= 16;
    
    let ix = joyPos.x, iy = joyPos.y;
    if (keys.w || keys.arrowup) iy = -1;
    if (keys.s || keys.arrowdown) iy = 1;
    if (keys.a || keys.arrowleft) ix = -1;
    if (keys.d || keys.arrowright) ix = 1;
    
    const speed = 3 + GameState.parts.leg * 0.4;
    if (!dashing) { player.vx = ix * speed; player.vy = iy * speed; }
    else { player.vx *= 0.95; player.vy *= 0.95; }
    
    player.x += player.vx;
    player.y += player.vy;
    player.x = Math.max(player.size, Math.min(pixiApp.screen.width - player.size, player.x));
    player.y = Math.max(player.size, Math.min(pixiApp.screen.height - player.size, player.y));
    
    if (Date.now() - lastEnemySpawn > CONFIG.ENEMY_SPAWN_INTERVAL) {
        spawnEnemy();
        lastEnemySpawn = Date.now();
    }
    
    const magnetRange = GameState.parts.arm > 0 ? 60 + GameState.parts.arm * 20 : 0;
    
    for (let i = foods.length - 1; i >= 0; i--) {
        const food = foods[i];
        food.x += food.vx; food.y += food.vy;
        if (food.x < -30) food.x = pixiApp.screen.width + 30;
        if (food.x > pixiApp.screen.width + 30) food.x = -30;
        if (food.y < -30) food.y = pixiApp.screen.height + 30;
        if (food.y > pixiApp.screen.height + 30) food.y = -30;
        
        const dx = player.x - food.x, dy = player.y - food.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (magnetRange && dist < magnetRange) { food.x += dx * 0.04; food.y += dy * 0.04; }
        
        if (dist < player.size + food.size * 0.5) {
            player.size = Math.min(CONFIG.MAX_SIZE, player.size + food.size * 0.1);
            GameState.eaten++;
            GameState.score += Math.floor(food.size * 2 * (1 + GameState.parts.mouth * 0.15));
            GameState.maxSize = Math.max(GameState.maxSize, player.size);
            SFX.play('eat');
            checkPartEvolution();
            pixiApp.stage.removeChild(food);
            foods.splice(i, 1);
            setTimeout(() => spawnFoods(1), 500);
        }
    }
    
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const dx = player.x - enemy.x, dy = player.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        drawEnemy(enemy);
        
        const canEat = enemy.size < player.size;
        if (!canEat) {
            enemy.x += dx / dist * enemy.speed * 0.5;
            enemy.y += dy / dist * enemy.speed * 0.5;
        } else {
            enemy.x -= dx / dist * enemy.speed * 0.3;
            enemy.y -= dy / dist * enemy.speed * 0.3;
        }
        
        enemy.angle += (Math.random() - 0.5) * 0.1;
        enemy.x += Math.cos(enemy.angle) * enemy.speed * 0.3;
        enemy.y += Math.sin(enemy.angle) * enemy.speed * 0.3;
        
        if (enemy.x < -200 || enemy.x > pixiApp.screen.width + 200 || enemy.y < -200 || enemy.y > pixiApp.screen.height + 200) {
            pixiApp.stage.removeChild(enemy);
            enemies.splice(i, 1);
            continue;
        }
        
        if (dist < player.size + enemy.size * 0.6) {
            if (canEat) {
                player.size = Math.min(CONFIG.MAX_SIZE, player.size + enemy.size * 0.15);
                GameState.eaten++;
                GameState.score += Math.floor(enemy.size * 5 * (1 + GameState.parts.mouth * 0.15));
                GameState.maxSize = Math.max(GameState.maxSize, player.size);
                SFX.play('eat');
                checkPartEvolution();
                pixiApp.stage.removeChild(enemy);
                enemies.splice(i, 1);
            } else {
                SFX.play('hit');
                gameOver();
                return;
            }
        }
    }
    
    drawPlayerBody();
    updateHUD();
    
    // Phase 1 ÌååÏ∏†Îßå Ïπ¥Ïö¥Ìä∏Ìï¥ÏÑú ÌÅ¥Î¶¨Ïñ¥ Ï°∞Í±¥ Ï≤¥ÌÅ¨
    const p1PartKeys = ['eye', 'mouth', 'arm', 'leg', 'tail', 'antenna'];
    const totalP1Parts = p1PartKeys.reduce((sum, k) => sum + GameState.parts[k], 0);
    if (GameState.score >= CONFIG.STAGE_THRESHOLD && totalP1Parts >= 5) {
        stageClear();
    }
}

function gameOver() {
    gameRunning = false;
    SFX.play('gameover');
    const t = GameState.t.bind(GameState);
    document.getElementById('go-score').textContent = GameState.score;
    document.getElementById('go-eaten').textContent = GameState.eaten;
    document.getElementById('go-maxsize').textContent = Math.round(GameState.maxSize);
    document.getElementById('modal-gameover').classList.add('show');
}

function stageClear() {
    gameRunning = false;
    SFX.play('clear');
    GameState.phase1Clear = true;
    // Phase 3 ÏßÑÌôî ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî (ÏÉà Í≤åÏûÑ ÏãúÏûë)
    GameState.evolutionGauge = 0;
    GameState.evolutionLevel = 0;
    GameState.runnerDist = 0;
    GameState.creature = null; // ÏÉà ÌÅ¨Î¶¨Ï≤ò ÏÉùÏÑ± ÌïÑÏöî
    GameState.save();
    
    const p1PartKeys = ['eye', 'mouth', 'arm', 'leg', 'tail', 'antenna'];
    const totalP1Parts = p1PartKeys.reduce((sum, k) => sum + GameState.parts[k], 0);
    document.getElementById('cl-score').textContent = GameState.score;
    document.getElementById('cl-parts').textContent = totalP1Parts;
    document.getElementById('modal-clear').classList.add('show');
}


// ========================================
// Phase 2 - Climb Game (ÏÑ∏Ìè¨ ‚Üí Ïú°ÏßÄ ÏßÑÌôî)
// ÏãúÏûë Ï†Ñ Ï£ºÏÇ¨ÏúÑ: 80+ ÌÜ†ÎÑ§Ïù¥ÎèÑ, 60-79 Íµ¨Î¶Ñ, 59- ÏóÜÏùå
// ========================================
let climber = null, platforms = [], climbItems = [];
let camY = 0, curHeight = 0, canDoubleJump = false, wasOnGround = true;
let p2GameRunning = false, p2Time = 0;
let climbItem = null; // 'tornado', 'cloud', null
let landPlatform = null;
let lowestY = 0; // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÎèÑÎã¨Ìïú ÏµúÏ†ÄÏ†ê (Í∞ÄÏû• ÎÜíÏù¥ Ïò¨ÎùºÍ∞Ñ ÏúÑÏπò)
let deathLineY = 0; // Í≤åÏûÑÏò§Î≤Ñ ÎùºÏù∏ (ÏãúÏûë ÏúÑÏπò + Ïó¨Ïú†)
const LAND_HEIGHT = 3000; // Ïú°ÏßÄ ÎÜíÏù¥

function showPhase2Intro() {
    currentEnv = getEnvById(GameState.envId);
    initPixi(parseInt(currentEnv.colors.bg1.replace('#', '0x')));
    createStarBackground(currentEnv.colors);
    
    const appEl = document.getElementById('app');
    const t = GameState.t.bind(GameState);
    const intro = TRANSLATIONS[GameState.currentLang].p2Intro;
    let idx = 0;
    
    function render() {
        const s = intro[idx];
        const isLast = idx === intro.length - 1;
        
        appEl.innerHTML = `
            <button class="skip-btn" id="skip-btn">${t('skip')}</button>
            <div class="page-center">
                <div class="page-content">
                    <div class="page-icon">${s.icon}</div>
                    <h2 class="page-title">${s.title}</h2>
                    <p class="page-text">${s.text}</p>
                    <div class="dots">
                        ${intro.map((_, i) => `<div class="dot ${i < idx ? 'done' : ''} ${i === idx ? 'active' : ''}"></div>`).join('')}
                    </div>
                    <button class="btn btn-primary btn-block" id="btn-next">${isLast ? 'üé≤ ' + t('p2Start') : t('next')}</button>
                </div>
            </div>
        `;
        
        document.getElementById('btn-next').onclick = () => {
            if (isLast) showClimbDice();
            else { idx++; render(); }
        };
        document.getElementById('skip-btn').onclick = showClimbDice;
    }
    render();
}

// Phase 2 Ï£ºÏÇ¨ÏúÑ - ÏïÑÏù¥ÌÖú Í≤∞Ï†ï
function showClimbDice() {
    currentEnv = getEnvById(GameState.envId);
    initPixi(parseInt(currentEnv.colors.bg1.replace('#', '0x')));
    createStarBackground(currentEnv.colors);
    
    const appEl = document.getElementById('app');
    const t = GameState.t.bind(GameState);
    
    appEl.innerHTML = `
        <div class="page-center">
            <div class="page-content">
                <h2 class="page-title">üé≤ ${t('p2DiceTitle')}</h2>
                <p class="page-text">
                    60+ üå™Ô∏è ÌÜ†ÎÑ§Ïù¥ÎèÑ<br>
                    20-59 ‚òÅÔ∏è Íµ¨Î¶Ñ<br>
                    19- ÏóÜÏùå
                </p>
                <div class="dice-box" id="dice-box">üé≤</div>
                <div id="dice-result" style="min-height: 60px; margin: 15px 0;"></div>
                <button class="btn btn-primary btn-block" id="btn-roll">üé≤ ${t('roll')}</button>
            </div>
        </div>
    `;
    
    const diceBox = document.getElementById('dice-box');
    const result = document.getElementById('dice-result');
    const btn = document.getElementById('btn-roll');
    
    btn.onclick = () => {
        btn.disabled = true;
        btn.textContent = t('roll');
        diceBox.classList.add('rolling');
        SFX.play('dice'); // Ï£ºÏÇ¨ÏúÑ Ìö®Í≥ºÏùå
        
        let count = 0;
        const anim = setInterval(() => {
            diceBox.textContent = Math.floor(Math.random() * 100) + 1;
            count++;
        }, 50);
        
        setTimeout(() => {
            clearInterval(anim);
            diceBox.classList.remove('rolling');
            
            const roll = Math.floor(Math.random() * 100) + 1;
            diceBox.textContent = roll;
            
            let item = null, icon = '', msg = '';
            
            if (roll >= 60) {
                item = 'tornado';
                icon = 'üå™Ô∏è';
                msg = 'ÌÜ†ÎÑ§Ïù¥ÎèÑÏùò ÌûòÏùÑ ÏñªÏóàÎã§!';
                diceBox.style.color = '#ff6b6b';
                diceBox.style.textShadow = '0 0 20px #ff6b6b';
            } else if (roll >= 20) {
                item = 'cloud';
                icon = '‚òÅÔ∏è';
                msg = 'Íµ¨Î¶ÑÏùò ÌûòÏùÑ ÏñªÏóàÎã§!';
                diceBox.style.color = '#87CEEB';
                diceBox.style.textShadow = '0 0 20px #87CEEB';
            } else {
                item = null;
                icon = 'üò¢';
                msg = 'ÏïÑÎ¨¥Í≤ÉÎèÑ ÏñªÏßÄ Î™ªÌñàÎã§...';
                diceBox.style.color = '#ff4444';
                diceBox.style.textShadow = '0 0 15px #ff4444';
            }
            
            climbItem = item;
            
            result.innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 3rem; margin-bottom: 8px;">${icon}</div>
                    <div style="color: #ffd700; font-size: 1rem;">${msg}</div>
                </div>
            `;
            
            btn.disabled = false;
            btn.textContent = 'üèîÔ∏è ' + t('p2Go');
            btn.onclick = startPhase2;
        }, 1500);
    };
}

function startPhase2() {
    GameState.resetP2();
    currentEnv = getEnvById(GameState.envId);
    climbGraphics = null; // Graphics Í∞ùÏ≤¥ Ï¥àÍ∏∞Ìôî
    
    const bgColor = parseInt(currentEnv.colors.bg1.replace('#', '0x'));
    initPixi(bgColor);
    
    const appEl = document.getElementById('app');
    const t = GameState.t.bind(GameState);
    
    const itemIcon = climbItem === 'tornado' ? 'üå™Ô∏è' : climbItem === 'cloud' ? '‚òÅÔ∏è' : 'ü¶é';
    const itemText = climbItem === 'tornado' ? 'ÌÜ†ÎÑ§Ïù¥ÎèÑ' : climbItem === 'cloud' ? 'Íµ¨Î¶Ñ' : 'ÏóÜÏùå';
    
    appEl.innerHTML = `
        <div class="hud-top">
            <div class="hud-panel" style="min-width: 100px; text-align: center;">
                <div style="font-size: 1.8rem; font-weight: 900; color: #00f5d4;" id="h2-height">0m</div>
                <div style="font-size: 0.65rem; color: #666;">ÌòÑÏû¨ ÎÜíÏù¥</div>
            </div>
            <div class="hud-panel" style="min-width: 90px; text-align: center;">
                <div style="font-size: 0.65rem; color: #666;">üèîÔ∏è Ïú°ÏßÄ</div>
                <div style="font-size: 1rem; font-weight: 700; color: #10b981;">${LAND_HEIGHT}m</div>
                ${climbItem ? `<div style="font-size: 0.6rem; color: #ffd700; margin-top: 4px;">${itemIcon} ${itemText}</div>` : ''}
            </div>
            <div class="hud-btns">
                <button class="hud-btn" id="btn-skip-p2" title="ÌÖåÏä§Ìä∏: ÌÅ¥Î¶¨Ïñ¥" style="background: linear-gradient(135deg, #10b981, #059669);">‚úì</button>
                <button class="hud-btn" id="btn-restart-p2" title="Îã§Ïãú ÏãúÏûë">üîÑ</button>
                <button class="hud-btn" id="btn-home-p2" title="${t('home')}">üè†</button>
            </div>
        </div>
        <div class="controls">
            <div class="joystick" id="joystick"><div class="joy-base"></div><div class="joy-knob" id="joy-knob"></div></div>
            <button class="action-btn" id="btn-jump" title="Jump">‚¨ÜÔ∏è</button>
        </div>
        <div class="modal" id="modal-p2-gameover">
            <div class="modal-box">
                <div class="modal-icon">üíß</div>
                <h2 class="modal-title fail">${t('p2Gameover')}</h2>
                <p class="modal-desc">${t('p2GameoverDesc')}</p>
                <div class="modal-stats">
                    <div class="stat-row"><span class="stat-label">${t('maxHeight')}</span><span class="stat-val" id="p2go-height">0</span></div>
                </div>
                <div class="modal-btns">
                    <button class="btn btn-primary btn-block" id="btn-p2-retry">üîÑ ${t('p2Retry')}</button>
                </div>
            </div>
        </div>
        <div class="modal" id="modal-p2-clear">
            <div class="modal-box">
                <div class="modal-icon">üèùÔ∏è</div>
                <h2 class="modal-title win">${t('p2Clear')}</h2>
                <p class="modal-desc">${t('p2ClearDesc')}</p>
                <div class="modal-stats">
                    <div class="stat-row"><span class="stat-label">${t('maxHeight')}</span><span class="stat-val" id="p2cl-height">0</span></div>
                </div>
                <div class="modal-btns">
                    <button class="btn btn-primary btn-block" id="btn-p2-next">ü¶ñ Phase 3!</button>
                </div>
            </div>
        </div>
    `;
    
    // Í≤åÏûÑ Ï¥àÍ∏∞Ìôî
    platforms = [];
    climbItems = [];
    camY = 0;
    curHeight = 0;
    wasOnGround = true;
    p2Time = 0;
    GameState.height = 0;
    GameState.maxHeight = 0;
    
    // ÌîåÎ†àÏù¥Ïñ¥ ÏÉùÏÑ±
    const pSize = 28 + totalP1Parts() * 2;
    climber = {
        x: pixiApp.screen.width / 2,
        y: pixiApp.screen.height - 80,
        w: pSize,
        h: pSize,
        vx: 0,
        vy: 0,
        onGround: true
    };
    
    // Í≤åÏûÑÏò§Î≤Ñ ÎùºÏù∏ ÏÑ§Ï†ï (ÏãúÏûë ÏúÑÏπò + 200px ÏïÑÎûò)
    lowestY = climber.y;
    deathLineY = pixiApp.screen.height + 150;
    
    // Ïú°ÏßÄ y ÏúÑÏπò (Í≥†Ï†ï)
    const landY = -LAND_HEIGHT * 10;
    
    // ÏãúÏûë ÌîåÎû´Ìèº
    platforms.push({
        x: pixiApp.screen.width / 2 - 70,
        y: pixiApp.screen.height - 40,
        w: 140,
        h: 18,
        type: 'start'
    });
    
    // Ï¥àÍ∏∞ ÌîåÎû´Ìèº ÏÉùÏÑ± (ÌôîÎ©¥ ÏúÑÏ™ΩÏúºÎ°ú 5ÌôîÎ©¥ Ï†ïÎèÑ)
    generatePlatforms(pixiApp.screen.height - 50, -pixiApp.screen.height * 5);
    
    // Ïú°ÏßÄ ÌîåÎû´Ìèº
    landPlatform = {
        x: 0,
        y: landY,
        w: pixiApp.screen.width,
        h: 150,
        type: 'land'
    };
    platforms.push(landPlatform);
    
    setupClimbControls();
    setupClimbHUD();
    
    gameLoop = delta => updateClimb(delta);
    pixiApp.ticker.add(gameLoop);
    p2GameRunning = true;
}

function totalP1Parts() {
    const p1PartKeys = ['eye', 'mouth', 'arm', 'leg', 'tail', 'antenna'];
    return p1PartKeys.reduce((sum, k) => sum + (GameState.parts[k] || 0), 0);
}

function generatePlatforms(fromY, toY) {
    let y = fromY - 40;
    
    while (y > toY) {
        const num = 1 + Math.floor(Math.random() * 2);
        
        for (let i = 0; i < num; i++) {
            const w = 75 + Math.random() * 55;
            const x = Math.random() * (pixiApp.screen.width - w);
            let type = 'normal';
            
            const heightRatio = Math.abs(y) / (LAND_HEIGHT * 10);
            if (heightRatio > 0.3 && Math.random() < 0.1) type = 'moving';
            if (heightRatio > 0.5 && Math.random() < 0.06) type = 'breaking';
            if (heightRatio > 0.6 && Math.random() < 0.1) type = 'bouncy';
            
            platforms.push({
                x, y, w, h: 14, type,
                dir: Math.random() < 0.5 ? 1 : -1,
                speed: 1 + Math.random() * 1.2,
                broken: false,
                timer: 0
            });
            
            // ÏïÑÏù¥ÌÖú ÏÉùÏÑ± (Ï£ºÏÇ¨ÏúÑ Í≤∞Í≥ºÏóê Îî∞Îùº)
            if (climbItem && Math.random() < 0.12) {
                climbItems.push({
                    x: x + w / 2,
                    y: y - 45,
                    type: climbItem,
                    collected: false
                });
            }
        }
        // ÌîåÎû´Ìèº Í∞ÑÍ≤© Ï§ÑÏûÑ (35~55pxÎ°ú Ï°∞Ï†ï)
        y -= 35 + Math.random() * 20;
    }
}

let wasOnGroundLastFrame = false; // Ï∞©ÏßÄ Í∞êÏßÄÏö©

function setupClimbControls() {
    const joy = document.getElementById('joystick');
    const knob = document.getElementById('joy-knob');
    
    if (!joy || !knob) return;
    
    const handleMove = (clientX) => {
        const rect = joy.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const maxDist = rect.width / 2 - 25;
        
        let dx = clientX - centerX;
        if (Math.abs(dx) > maxDist) dx = dx > 0 ? maxDist : -maxDist;
        
        knob.style.transform = `translate(${dx}px, 0)`;
        joyPos = { x: dx / maxDist, y: 0 };
    };
    
    const handleEnd = () => {
        joyActive = false;
        joy.classList.remove('active');
        knob.style.transform = '';
        joyPos = { x: 0, y: 0 };
    };
    
    const jump = () => {
        if (!p2GameRunning) return;
        if (climber.onGround) {
            climber.vy = -16;
            climber.onGround = false;
            wasOnGround = false;
            canDoubleJump = GameState.parts.leg >= 2;
            SFX.play('jump');
        } else if (canDoubleJump) {
            climber.vy = -13;
            canDoubleJump = false;
            SFX.play('jump');
        }
    };
    
    joy.addEventListener('touchstart', e => { e.preventDefault(); joyActive = true; joy.classList.add('active'); handleMove(e.touches[0].clientX); }, { passive: false });
    joy.addEventListener('touchmove', e => { e.preventDefault(); if (joyActive) handleMove(e.touches[0].clientX); }, { passive: false });
    joy.addEventListener('touchend', handleEnd);
    joy.addEventListener('mousedown', e => { joyActive = true; joy.classList.add('active'); handleMove(e.clientX); });
    window.addEventListener('mousemove', e => { if (joyActive) handleMove(e.clientX); });
    window.addEventListener('mouseup', handleEnd);
    
    keys = {};
    window.addEventListener('keydown', e => { 
        keys[e.key.toLowerCase()] = true;
        if (e.key === ' ' || e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') {
            e.preventDefault();
            jump();
        }
    });
    window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
    
    document.getElementById('btn-jump').onclick = jump;
    document.getElementById('btn-jump').ontouchstart = e => { e.preventDefault(); jump(); };
}

function setupClimbHUD() {
    const t = GameState.t.bind(GameState);
    
    document.getElementById('btn-skip-p2').onclick = () => {
        climbWin();
    };
    
    document.getElementById('btn-restart-p2').onclick = () => {
        if (confirm(t('p2Restart'))) {
            p2GameRunning = false;
            if (gameLoop && pixiApp) pixiApp.ticker.remove(gameLoop);
            showClimbDice();
        }
    };
    
    document.getElementById('btn-home-p2').onclick = () => {
        if (confirm(t('confirmHome'))) {
            p2GameRunning = false;
            if (gameLoop && pixiApp) pixiApp.ticker.remove(gameLoop);
            showTitle();
        }
    };
    
    document.getElementById('btn-p2-retry').onclick = () => {
        document.getElementById('modal-p2-gameover').classList.remove('show');
        if (gameLoop && pixiApp) pixiApp.ticker.remove(gameLoop);
        showClimbDice();
    };
    
    document.getElementById('btn-p2-next').onclick = () => {
        alert('Phase 3 Coming Soon!');
    };
}

function updateClimb(delta) {
    if (!p2GameRunning || !climber) return;
    
    p2Time += delta * 0.016;
    
    // Ï¢åÏö∞ Ïù¥Îèô
    let mx = joyPos.x;
    if (keys.a || keys.arrowleft) mx = -1;
    if (keys.d || keys.arrowright) mx = 1;
    
    const speed = 5 + (GameState.parts.leg || 0) * 0.4;
    climber.vx = mx * speed;
    
    // Ï§ëÎ†•
    climber.vy += 0.55;
    if (climber.vy > 14) climber.vy = 14;
    
    // ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
    climber.x += climber.vx;
    climber.y += climber.vy;
    
    // Ï¢åÏö∞ Í≤ΩÍ≥Ñ
    if (climber.x < 0) climber.x = 0;
    if (climber.x + climber.w > pixiApp.screen.width) climber.x = pixiApp.screen.width - climber.w;
    
    // Ïú°ÏßÄ ÎèÑÎã¨ Ï≤¥ÌÅ¨
    if (landPlatform && climber.y + climber.h < landPlatform.y + 50) {
        climbWin();
        return;
    }
    
    const wasOnGroundBefore = climber.onGround;
    climber.onGround = false;
    
    // ÌîåÎû´Ìèº Ï∂©Îèå
    for (const p of platforms) {
        if (p.broken) continue;
        
        // ÏõÄÏßÅÏù¥Îäî ÌîåÎû´Ìèº
        if (p.type === 'moving') {
            p.x += p.dir * p.speed;
            if (p.x <= 0 || p.x + p.w >= pixiApp.screen.width) p.dir *= -1;
        }
        
        // Ï∂©Îèå Ï≤¥ÌÅ¨ (ÏúÑÏóêÏÑú ÏïÑÎûòÎ°ú Îñ®Ïñ¥Ïßà Îïå)
        if (climber.vy >= 0 &&
            climber.x + climber.w > p.x + 4 &&
            climber.x < p.x + p.w - 4 &&
            climber.y + climber.h >= p.y &&
            climber.y + climber.h <= p.y + p.h + 16) {
            
            climber.y = p.y - climber.h;
            climber.vy = 0;
            climber.onGround = true;
            canDoubleJump = GameState.parts.leg >= 2;
            
            // Ï∞©ÏßÄ Ìö®Í≥ºÏùå (Ï≤òÏùå Ï∞©ÏßÄÌï† ÎïåÎßå)
            if (!wasOnGroundBefore) {
                SFX.play('land');
            }
            
            if (p.type === 'bouncy') {
                climber.vy = -20;
                climber.onGround = false;
                SFX.play('bounce');
            } else if (p.type === 'breaking') {
                p.timer++;
                if (p.timer > 25) p.broken = true;
            } else if (p.type === 'land') {
                climbWin();
                return;
            }
            
            if (p.type === 'moving') climber.x += p.dir * p.speed;
        }
    }
    
    wasOnGround = climber.onGround;
    
    // ÏïÑÏù¥ÌÖú ÏàòÏßë
    for (const item of climbItems) {
        if (item.collected) continue;
        const dx = (climber.x + climber.w / 2) - item.x;
        const dy = (climber.y + climber.h / 2) - item.y;
        if (Math.sqrt(dx * dx + dy * dy) < 35) {
            item.collected = true;
            SFX.play('powerup');
            if (item.type === 'tornado') {
                climber.vy = -48;
            } else if (item.type === 'cloud') {
                climber.vy = -24;
            }
        }
    }
    
    // Ïπ¥Î©îÎùº Ï∂îÏ†Å
    const targetCam = -climber.y + pixiApp.screen.height * 0.6;
    camY += (targetCam - camY) * 0.1;
    
    // ÎÜíÏù¥ Í≥ÑÏÇ∞
    curHeight = Math.max(0, Math.floor(-climber.y / 10));
    GameState.height = curHeight;
    if (curHeight > GameState.maxHeight) {
        GameState.maxHeight = curHeight;
    }
    
    // ÏÉà ÌîåÎû´Ìèº ÏÉùÏÑ± - Îã®ÏàúÌôî
    const landY = -LAND_HEIGHT * 10;
    let highestPlatY = pixiApp.screen.height;
    for (const p of platforms) {
        if (p.type !== 'land' && p.y < highestPlatY) {
            highestPlatY = p.y;
        }
    }
    
    // ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏóê ÌîåÎû´ÌèºÏù¥ Î∂ÄÏ°±ÌïòÎ©¥ ÏÉùÏÑ±
    if (climber.y - pixiApp.screen.height * 2 < highestPlatY && highestPlatY > landY + 500) {
        generatePlatforms(highestPlatY - 30, highestPlatY - pixiApp.screen.height * 4);
    }
    
    // Í≤åÏûÑÏò§Î≤Ñ Ï≤¥ÌÅ¨ (ÏãúÏûë ÏúÑÏπò ÏïÑÎûòÎ°ú Îñ®Ïñ¥Ïßê)
    if (climber.y > deathLineY) {
        climbFail();
        return;
    }
    
    // Î†åÎçîÎßÅ
    renderClimb();
    
    // HUD ÏóÖÎç∞Ïù¥Ìä∏
    document.getElementById('h2-height').textContent = curHeight + 'm';
}

let climbGraphics = null; // Phase 2Ïö© Graphics Ïû¨ÏÇ¨Ïö©

function renderClimb() {
    if (!currentEnv || !currentEnv.colors) {
        currentEnv = getEnvById(GameState.envId) || ENVIRONMENTS[0];
    }
    
    const w = pixiApp.screen.width;
    const h = pixiApp.screen.height;
    const heightRatio = Math.min(1, curHeight / LAND_HEIGHT);
    const t = p2Time;
    
    // Í∏∞Î≥∏ Î∞∞Í≤ΩÏÉâ (ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞í)
    const defaultBg = 0x001a33;
    const defaultPrimary = 0x00b4d8;
    
    let envBg = defaultBg;
    let envPrimary = defaultPrimary;
    
    try {
        if (currentEnv && currentEnv.colors) {
            envBg = parseInt(currentEnv.colors.bg1.replace('#', ''), 16) || defaultBg;
            envPrimary = parseInt(currentEnv.colors.primary.replace('#', ''), 16) || defaultPrimary;
        }
    } catch (e) {
        envBg = defaultBg;
        envPrimary = defaultPrimary;
    }
    
    // Î∞∞Í≤Ω Í∑∏ÎùºÎç∞Ïù¥ÏÖò (ÎÜíÏù¥Ïóê Îî∞Îùº Î≥ÄÌôî)
    let bgColor;
    if (heightRatio < 0.3) {
        // ÍπäÏùÄ Î∞îÎã§ -> ÏñïÏùÄ Î∞îÎã§
        bgColor = lerpColor(0x000428, 0x004e92, heightRatio / 0.3);
    } else if (heightRatio < 0.6) {
        // ÏñïÏùÄ Î∞îÎã§ -> ÌïòÎäò
        bgColor = lerpColor(0x004e92, 0x2193b0, (heightRatio - 0.3) / 0.3);
    } else {
        // ÌïòÎäò -> Ïö∞Ï£º
        bgColor = lerpColor(0x2193b0, 0x6dd5ed, (heightRatio - 0.6) / 0.4);
    }
    pixiApp.renderer.background.color = bgColor;
    
    // Graphics Í∞ùÏ≤¥ Ïû¨ÏÇ¨Ïö©
    if (!climbGraphics) {
        climbGraphics = new PIXI.Graphics();
        pixiApp.stage.addChild(climbGraphics);
    }
    const graphics = climbGraphics;
    graphics.clear();
    
    // ====== Î∞∞Í≤Ω Ìö®Í≥º ======
    
    // 1. Î≥Ñ/ÌååÌã∞ÌÅ¥ (ÎÜíÏù¥Ïóê Îî∞Îùº Î≥ÄÌôî)
    const starCount = Math.floor(20 + heightRatio * 30);
    for (let i = 0; i < starCount; i++) {
        const seed = i * 12345.6789;
        const sx = ((seed * 9.8) % w);
        const sy = ((seed * 7.3 + camY * 0.1 * (1 + (i % 3) * 0.5)) % (h * 2)) - h * 0.5;
        const starSize = 1 + (i % 3);
        const twinkle = Math.sin(t * 2 + i) * 0.3 + 0.7;
        
        if (heightRatio < 0.4) {
            // Î∞îÎã§: Í∏∞Ìè¨/ÌîåÎûëÌÅ¨ÌÜ§
            graphics.beginFill(0x88ddff, twinkle * 0.5);
            graphics.drawCircle(sx, sy, starSize * 1.5);
            graphics.endFill();
        } else if (heightRatio < 0.7) {
            // ÌïòÎäò: ÎπõÎÇòÎäî ÌååÌã∞ÌÅ¥
            graphics.beginFill(0xffffff, twinkle * 0.6);
            graphics.drawCircle(sx, sy, starSize);
            graphics.endFill();
        } else {
            // ÎÜíÏùÄ ÌïòÎäò: Î≥Ñ
            graphics.beginFill(0xffffee, twinkle);
            graphics.drawCircle(sx, sy, starSize);
            graphics.endFill();
        }
    }
    
    // 2. Íµ¨Î¶Ñ (Ï§ëÍ∞Ñ ÎÜíÏù¥ÏóêÏÑú)
    if (heightRatio > 0.3 && heightRatio < 0.9) {
        const cloudAlpha = heightRatio < 0.5 ? (heightRatio - 0.3) * 2.5 : (0.9 - heightRatio) * 2.5;
        for (let i = 0; i < 5; i++) {
            const cx = ((i * 137 + t * 5) % (w + 200)) - 100;
            const cy = ((i * 97 + camY * 0.05) % h);
            const cloudScale = 0.5 + (i % 3) * 0.3;
            
            graphics.beginFill(0xffffff, cloudAlpha * 0.15);
            graphics.drawEllipse(cx, cy, 60 * cloudScale, 25 * cloudScale);
            graphics.drawEllipse(cx + 30 * cloudScale, cy - 10, 40 * cloudScale, 20 * cloudScale);
            graphics.drawEllipse(cx - 25 * cloudScale, cy + 5, 35 * cloudScale, 18 * cloudScale);
            graphics.endFill();
        }
    }
    
    // 3. ÎπõÏ§ÑÍ∏∞ (ÏúÑÏóêÏÑú ÏïÑÎûòÎ°ú)
    if (heightRatio > 0.2) {
        const rayAlpha = Math.min(0.08, heightRatio * 0.1);
        for (let i = 0; i < 3; i++) {
            const rx = w * 0.2 + i * w * 0.3;
            graphics.beginFill(0xffffff, rayAlpha);
            graphics.moveTo(rx - 30, -50);
            graphics.lineTo(rx + 30, -50);
            graphics.lineTo(rx + 80, h + 50);
            graphics.lineTo(rx - 80, h + 50);
            graphics.closePath();
            graphics.endFill();
        }
    }
    
    // 4. Î¨ºÍ≤∞ Ìö®Í≥º (ÎÇÆÏùÄ ÎÜíÏù¥)
    if (heightRatio < 0.4) {
        const waveAlpha = (0.4 - heightRatio) * 0.5;
        for (let i = 0; i < 3; i++) {
            graphics.lineStyle(2, 0x00d4ff, waveAlpha * (0.3 + i * 0.2));
            graphics.moveTo(0, h * (0.3 + i * 0.2));
            for (let x = 0; x <= w; x += 20) {
                const waveY = h * (0.3 + i * 0.2) + Math.sin(x * 0.02 + t * 2 + i) * 15;
                graphics.lineTo(x, waveY);
            }
            graphics.lineStyle(0);
        }
    }
    
    // ÌîåÎû´Ìèº Í∑∏Î¶¨Í∏∞
    for (const p of platforms) {
        if (p.broken) continue;
        const screenY = p.y + camY;
        if (screenY < -40 || screenY > h + 40) continue;
        
        if (p.type === 'land') {
            // Ïú°ÏßÄ
            graphics.beginFill(0x8B4513);
            graphics.drawRect(p.x, screenY, p.w, p.h);
            graphics.endFill();
            graphics.beginFill(0x228B22);
            graphics.drawRect(p.x, screenY, p.w, 20);
            graphics.endFill();
            // ÎÇòÎ¨¥Îì§
            for (let i = 0; i < 6; i++) {
                const tx = 30 + i * (p.w / 6);
                graphics.beginFill(0x654321);
                graphics.drawRect(tx, screenY - 40, 10, 40);
                graphics.endFill();
                graphics.beginFill(0x228B22);
                graphics.drawCircle(tx + 5, screenY - 50, 25);
                graphics.endFill();
            }
        } else if (p.type === 'start') {
            graphics.beginFill(envPrimary, 0.8);
            graphics.drawRoundedRect(p.x, screenY, p.w, p.h, 5);
            graphics.endFill();
        } else if (p.type === 'moving') {
            graphics.beginFill(0x9d4edd);
            graphics.drawRoundedRect(p.x, screenY, p.w, p.h, 5);
            graphics.endFill();
        } else if (p.type === 'breaking') {
            graphics.beginFill(0xef4444);
            graphics.drawRoundedRect(p.x, screenY, p.w, p.h, 5);
            graphics.endFill();
        } else if (p.type === 'bouncy') {
            graphics.beginFill(0x10b981);
            graphics.drawRoundedRect(p.x, screenY, p.w, p.h, 5);
            graphics.endFill();
        } else {
            // ÏùºÎ∞ò ÌîåÎû´Ìèº
            const platColor = heightRatio < 0.5 
                ? lerpColor(envPrimary, 0x48cae4, heightRatio * 2)
                : lerpColor(0x48cae4, 0xcaf0f8, (heightRatio - 0.5) * 2);
            graphics.beginFill(platColor);
            graphics.drawRoundedRect(p.x, screenY, p.w, p.h, 5);
            graphics.endFill();
        }
    }
    
    // ÏïÑÏù¥ÌÖú Í∑∏Î¶¨Í∏∞ (GraphicsÎ°ú ÏßÅÏ†ë Í∑∏Î¶¨Í∏∞)
    for (const item of climbItems) {
        if (item.collected) continue;
        const screenY = item.y + camY;
        if (screenY < -40 || screenY > h + 40) continue;
        
        const ix = item.x;
        const iy = screenY + Math.sin(t * 3) * 5;
        
        if (item.type === 'tornado') {
            // ÌÜ†ÎÑ§Ïù¥ÎèÑ ÏïÑÏù¥ÏΩò Í∑∏Î¶¨Í∏∞
            graphics.beginFill(0x888888, 0.8);
            const rot = t * 2;
            for (let i = 0; i < 3; i++) {
                const r = 12 - i * 3;
                const offsetY = i * 6;
                graphics.drawEllipse(ix, iy + offsetY, r, 4);
            }
            graphics.endFill();
        } else {
            // Íµ¨Î¶Ñ ÏïÑÏù¥ÏΩò Í∑∏Î¶¨Í∏∞
            graphics.beginFill(0xFFFFFF, 0.9);
            graphics.drawCircle(ix, iy, 10);
            graphics.drawCircle(ix - 8, iy + 3, 7);
            graphics.drawCircle(ix + 8, iy + 3, 7);
            graphics.endFill();
        }
    }
    
    // ÌîåÎ†àÏù¥Ïñ¥ Í∑∏Î¶¨Í∏∞
    drawClimber(graphics);
    
    // ÏßÑÌñâ Î∞î (Ïò§Î•∏Ï™Ω)
    const barH = h - 120;
    const barX = w - 25;
    const progress = Math.min(1, curHeight / LAND_HEIGHT);
    
    graphics.beginFill(0x000000, 0.25);
    graphics.drawRect(barX - 4, 60, 16, barH);
    graphics.endFill();
    
    graphics.beginFill(0x00f5d4);
    graphics.drawRect(barX - 2, 60 + barH * (1 - progress), 12, barH * progress);
    graphics.endFill();
    
    graphics.beginFill(0x228B22);
    graphics.drawRect(barX - 6, 55, 20, 8);
    graphics.endFill();
    
    // Îç∞Ïä§ÎùºÏù∏ ÌëúÏãú (Îπ®Í∞Ñ Ï†êÏÑ†)
    const deathScreenY = deathLineY + camY;
    if (deathScreenY > 0 && deathScreenY < h + 50) {
        graphics.lineStyle(3, 0xff4444, 0.6);
        for (let dx = 0; dx < w; dx += 20) {
            graphics.moveTo(dx, deathScreenY);
            graphics.lineTo(dx + 10, deathScreenY);
        }
        graphics.lineStyle(0);
        
        // Í≤ΩÍ≥† ÌÖçÏä§Ìä∏
        const warnText = new PIXI.Text('‚ò†Ô∏è', { fontSize: 20 });
        warnText.x = 10;
        warnText.y = deathScreenY - 25;
        pixiApp.stage.addChild(warnText);
    }
}

function drawClimber(graphics) {
    // ÌôòÍ≤Ω Í∏∞Î∞ò ÏÉâÏÉÅ ÏÇ¨Ïö©
    const env = getEnvById(GameState.envId);
    const envColors = env ? env.colors : { primary: '#00b4d8', secondary: '#0077b6' };
    const p = GameState.parts || {};
    const t = p2Time;
    const s = climber.w / 2;
    const screenY = climber.y + camY;
    
    const cx = climber.x + climber.w / 2;
    const cy = screenY + climber.h / 2;
    
    const primary = parseInt(envColors.primary.replace('#', '0x'));
    const secondary = parseInt(envColors.secondary.replace('#', '0x'));
    
    // Íº¨Î¶¨
    if (p.tail > 0) {
        graphics.lineStyle(Math.max(3, s * 0.08), secondary);
        const tailWave = Math.sin(t * 3) * s * 0.3;
        graphics.moveTo(cx - s * 0.8, cy);
        graphics.bezierCurveTo(cx - s * 1.2, cy + tailWave, cx - s * 1.5, cy - tailWave * 0.5, cx - s * 1.8, cy + tailWave * 0.3);
        graphics.lineStyle(0);
    }
    
    // Ìåî
    if (p.arm > 0) {
        graphics.lineStyle(Math.max(2, s * 0.06), primary);
        for (let i = 0; i < Math.min(p.arm, 4); i++) {
            const side = i % 2 === 0 ? 1 : -1;
            const wave = Math.sin(t * 2.5 + i) * 0.15;
            graphics.moveTo(cx + side * s * 0.7, cy);
            graphics.lineTo(cx + side * s * 1.4, cy + wave * s);
        }
        graphics.lineStyle(0);
    }
    
    // Îã§Î¶¨
    if (p.leg > 0) {
        graphics.lineStyle(Math.max(2, s * 0.05), secondary);
        const legWave = Math.sin(t * 4) * 0.2;
        for (let i = 0; i < Math.min(p.leg, 4); i++) {
            const baseAngle = Math.PI * 0.5 + (i - 1.5) * 0.25;
            graphics.moveTo(cx + Math.cos(baseAngle) * s * 0.6, cy + Math.sin(baseAngle) * s * 0.6);
            graphics.lineTo(cx + Math.cos(baseAngle + legWave) * s * 1.2, cy + s * 1.0);
        }
        graphics.lineStyle(0);
    }
    
    // ÎçîÎì¨Ïù¥
    if (p.antenna > 0) {
        graphics.lineStyle(2, primary);
        for (let i = 0; i < Math.min(p.antenna, 2); i++) {
            const aa = -Math.PI * 0.4 + i * 0.4;
            const wave = Math.sin(t * 3) * 0.1;
            graphics.moveTo(cx + Math.cos(aa) * s * 0.5, cy + Math.sin(aa) * s * 0.5);
            graphics.lineTo(cx + Math.cos(aa + wave) * s * 1.3, cy + Math.sin(aa + wave) * s * 1.0);
            graphics.lineStyle(0);
            graphics.beginFill(primary);
            graphics.drawCircle(cx + Math.cos(aa + wave) * s * 1.3, cy + Math.sin(aa + wave) * s * 1.0, 3);
            graphics.endFill();
            graphics.lineStyle(2, primary);
        }
        graphics.lineStyle(0);
    }
    
    // Î™∏ÌÜµ
    graphics.beginFill(primary, 0.9);
    graphics.moveTo(cx + s, cy);
    for (let i = 0; i < 10; i++) {
        const ang = (i / 10) * Math.PI * 2;
        const wobble = Math.sin(t + i) * 2;
        const r = s + wobble;
        graphics.lineTo(cx + Math.cos(ang) * r, cy + Math.sin(ang) * r);
    }
    graphics.closePath();
    graphics.endFill();
    
    // ÎÇ¥Î∂Ä
    graphics.beginFill(secondary, 0.4);
    graphics.drawCircle(cx, cy, s * 0.65);
    graphics.endFill();
    
    // ÌïòÏù¥ÎùºÏù¥Ìä∏
    graphics.beginFill(0xffffff, 0.35);
    graphics.drawCircle(cx - s * 0.2, cy - s * 0.2, s * 0.25);
    graphics.endFill();
    
    // Îàà
    const eyeCount = Math.max(1, p.eye || 1);
    for (let i = 0; i < eyeCount; i++) {
        const ex = cx + (i - (eyeCount - 1) / 2) * s * 0.35;
        const ey = cy - s * 0.15;
        graphics.beginFill(0xffffff);
        graphics.drawCircle(ex, ey, s * 0.2);
        graphics.endFill();
        graphics.beginFill(0x222222);
        graphics.drawCircle(ex + s * 0.03, ey, s * 0.1);
        graphics.endFill();
    }
    
    // ÏûÖ
    if (p.mouth > 0) {
        graphics.lineStyle(2, secondary);
        graphics.arc(cx, cy + s * 0.25, s * 0.12, 0.2, Math.PI - 0.2);
        graphics.lineStyle(0);
    }
}

function lerpColor(c1, c2, t) {
    const r1 = (c1 >> 16) & 0xff, g1 = (c1 >> 8) & 0xff, b1 = c1 & 0xff;
    const r2 = (c2 >> 16) & 0xff, g2 = (c2 >> 8) & 0xff, b2 = c2 & 0xff;
    const r = Math.round(r1 + (r2 - r1) * t);
    const g = Math.round(g1 + (g2 - g1) * t);
    const b = Math.round(b1 + (b2 - b1) * t);
    return (r << 16) | (g << 8) | b;
}

function climbFail() {
    p2GameRunning = false;
    if (gameLoop && pixiApp) pixiApp.ticker.remove(gameLoop);
    
    SFX.play('gameover');
    document.getElementById('p2go-height').textContent = GameState.maxHeight + 'm';
    document.getElementById('modal-p2-gameover').classList.add('show');
}

function climbWin() {
    p2GameRunning = false;
    if (gameLoop && pixiApp) pixiApp.ticker.remove(gameLoop);
    
    SFX.play('clear');
    GameState.phase2Clear = true;
    GameState.runnerStage = 0;
    GameState.evoTraits = [];
    GameState.runnerDist = 0;
    GameState.charScale = 1;
    // Phase 3 ÏßÑÌôî ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    GameState.evolutionGauge = 0;
    GameState.evolutionLevel = 0;
    GameState.save();
    
    document.getElementById('p2cl-height').textContent = GameState.maxHeight + 'm';
    document.getElementById('modal-p2-clear').classList.add('show');
    
    // Phase 3ÏúºÎ°ú Ïù¥Îèô Î≤ÑÌäº Ïó∞Í≤∞
    setTimeout(() => {
        const nextBtn = document.querySelector('#modal-p2-clear .btn-primary');
        if (nextBtn) {
            nextBtn.onclick = () => {
                document.getElementById('modal-p2-clear').classList.remove('show');
                showPhase3Intro();
            };
        }
    }, 100);
}


// ========================================
// Phase 3: Runner Game (v4 - Polished)
// ========================================
let runner, runnerGaps, runnerItems, runnerParticles;
let runnerSpeed, runnerDist, bgOffset;
let lastGapTime = 0;
let p3GameRunning = false;
let currentCreature = null;
let runnerHP = 3;
let invincibleUntil = 0;
let evolutionGauge = 0; // ÏßÑÌôî Í≤åÏù¥ÏßÄ (100Ïù¥ ÎêòÎ©¥ ÏßÑÌôî)
let evolutionLevel = 0; // ÌòÑÏû¨ ÏßÑÌôî Îã®Í≥Ñ (0~4)
let evolutionAnimating = false;
let sparkles = [];
let bgParticles = []; // Î∞∞Í≤Ω ÌååÌã∞ÌÅ¥
let currentZoneId = '';
let zoneTransitionTimer = 0;

// Í∞àÎùºÏßÑ Ìãà Ï†ïÏùò (Í∞Å Î¨∏Î™ÖÎ≥Ñ Î™®Ïñë)
const GAP_STYLES = {
    primitive: { color: 0x2d1b0e, edgeColor: 0x8B4513 },
    dinosaur: { color: 0x1a0a00, edgeColor: 0xff6b35 }, // Ïö©Ïïî ÎäêÎÇå
    ice: { color: 0x1a3a4a, edgeColor: 0x87ceeb },
    human: { color: 0x1a1a1a, edgeColor: 0x8B7355 },
    modern: { color: 0x0a0a15, edgeColor: 0x333355 }
};

// Î∞∞Í≤Ω ÌååÌã∞ÌÅ¥ Ï†ïÏùò (Í∞Å Î¨∏Î™ÖÎ≥Ñ)
const BG_PARTICLE_STYLES = {
    primitive: [
        { type: 'leaf', color: 0x228B22, count: 15 },
        { type: 'dust', color: 0xD2B48C, count: 20 },
        { type: 'butterfly', color: 0xFFD700, count: 5 }
    ],
    dinosaur: [
        { type: 'ash', color: 0x666666, count: 25 },
        { type: 'ember', color: 0xFF4500, count: 15 },
        { type: 'pterodactyl', color: 0x4a3728, count: 3 }
    ],
    ice: [
        { type: 'snow', color: 0xFFFFFF, count: 40 },
        { type: 'sparkle', color: 0xADD8E6, count: 20 },
        { type: 'mist', color: 0xE0FFFF, count: 10 }
    ],
    human: [
        { type: 'smoke', color: 0x888888, count: 15 },
        { type: 'spark', color: 0xFF6600, count: 10 },
        { type: 'dust', color: 0xC4A77D, count: 20 }
    ],
    modern: [
        { type: 'neon', color: 0x00FFFF, count: 8 },
        { type: 'data', color: 0x00FF00, count: 6 },
        { type: 'light', color: 0xFF00FF, count: 5 }
    ]
};

function showPhase3Intro() {
    initPixi();
    createStarBackground();
    
    const t = GameState.t.bind(GameState);
    const intro = t('p3Intro');
    let idx = 0;
    
    // ÌôòÍ≤Ω Í∏∞Î∞ò ÌÅ¨Î¶¨Ï≤ò ÏÉùÏÑ±
    const currentEnvId = GameState.envId || 'ocean';
    
    // Phase 3 Ï≤òÏùå ÏãúÏûë (runnerDistÍ∞Ä 0Ïù¥Í±∞ÎÇò ÌÅ¨Î¶¨Ï≤òÍ∞Ä ÏóÜÍ±∞ÎÇò ÌôòÍ≤ΩÏù¥ Îã§Î•¥Î©¥)
    const needNewCreature = !GameState.creature || 
                            GameState.creature.envId !== currentEnvId || 
                            (GameState.runnerDist || 0) === 0;
    
    if (needNewCreature) {
        console.log('Creating new creature, resetting evolution');
        GameState.creature = generateCreatureFromEnv(currentEnvId);
        GameState.badges = [];
        GameState.runnerDist = 0;
        GameState.evolutionGauge = 0;
        GameState.evolutionLevel = 0;
        GameState.save();
    }
    
    function renderSlide() {
        const slide = intro[idx];
        const isLast = idx === intro.length - 1;
        const env = getEnvById(currentEnvId);
        
        app.innerHTML = `
            <div class="page-center">
                <div class="page-content">
                    <div class="page-icon">${slide.icon}</div>
                    <h2 class="page-title">${slide.title}</h2>
                    <p class="page-text">${slide.text}</p>
                    <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin: 10px 0; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                        <span style="font-size: 1.5rem;">${env?.icon || 'üåä'}</span>
                        <span style="color: #aaa; font-size: 0.85rem;">Ï∂úÏÉùÏßÄ: ${env?.name || 'Ìï¥Ïñë'}</span>
                    </div>
                    <div id="creature-preview" style="width: 140px; height: 140px; margin: 15px auto; background: rgba(0,0,0,0.4); border-radius: 16px; border: 2px solid rgba(79,195,247,0.3);"></div>
                    <div class="dots">
                        ${intro.map((_, i) => `<div class="dot ${i < idx ? 'done' : ''} ${i === idx ? 'active' : ''}"></div>`).join('')}
                    </div>
                    <button class="btn btn-primary btn-block" id="btn-next">${isLast ? 'üèÉ ' + t('p3Start') : t('next')}</button>
                </div>
            </div>
        `;
        
        renderCreatureCanvasLevel('creature-preview', GameState.creature, GameState.evolutionLevel || 0);
        document.getElementById('btn-next').onclick = () => isLast ? startPhase3() : (idx++, renderSlide());
    }
    renderSlide();
}

function renderCreatureCanvas(containerId, creature, distance = 0) {
    const container = document.getElementById(containerId);
    if (!container || !creature) return;
    container.innerHTML = '';
    
    // Ïª®ÌÖåÏù¥ÎÑà ÌÅ¨Í∏∞Ïóê ÎßûÏ∂§
    const containerW = container.offsetWidth || 140;
    const containerH = container.offsetHeight || 140;
    
    const cvs = document.createElement('canvas');
    cvs.width = containerW;
    cvs.height = containerH;
    cvs.style.width = '100%';
    cvs.style.height = '100%';
    container.appendChild(cvs);
    
    const ctx = cvs.getContext('2d');
    const g = makeGraphicsWrapper(ctx);
    const evolved = evolveCreatureByDistance(creature, distance);
    
    const scale = Math.min(containerW, containerH) * 0.5;
    drawCreature(g, evolved, containerW / 2, containerH / 2, scale, Date.now() * 0.001);
}

// Î†àÎ≤® Í∏∞Î∞ò ÌÅ¨Î¶¨Ï≤ò Ï∫îÎ≤ÑÏä§ Î†åÎçîÎßÅ
function renderCreatureCanvasLevel(containerId, creature, level) {
    const container = document.getElementById(containerId);
    if (!container || !creature) return;
    container.innerHTML = '';
    
    // Ïª®ÌÖåÏù¥ÎÑà ÌÅ¨Í∏∞Ïóê ÎßûÏ∂§
    const containerW = container.offsetWidth || 100;
    const containerH = container.offsetHeight || 100;
    
    const cvs = document.createElement('canvas');
    cvs.width = containerW;
    cvs.height = containerH;
    cvs.style.width = '100%';
    cvs.style.height = '100%';
    container.appendChild(cvs);
    
    const ctx = cvs.getContext('2d');
    const g = makeGraphicsWrapper(ctx);
    const evolved = evolveCreatureByLevel(creature, level);
    
    // ÌÅ¨Í∏∞ Ï°∞Ï†ï (Ïª®ÌÖåÏù¥ÎÑà ÌÅ¨Í∏∞Ïóê ÎπÑÎ°Ä)
    const scale = Math.min(containerW, containerH) * 0.5;
    drawCreature(g, evolved, containerW / 2, containerH / 2, scale, Date.now() * 0.001);
}

function makeGraphicsWrapper(ctx) {
    return {
        _fa: 1, _lw: 0,
        beginFill(c, a = 1) { this._fa = a; ctx.fillStyle = `rgba(${(c>>16)&255},${(c>>8)&255},${c&255},${a})`; },
        endFill() {},
        lineStyle(w, c = 0, a = 1) { this._lw = w; ctx.strokeStyle = `rgba(${(c>>16)&255},${(c>>8)&255},${c&255},${a})`; ctx.lineWidth = w; },
        drawCircle(x, y, r) { ctx.beginPath(); ctx.arc(x, y, Math.max(0.1, r), 0, Math.PI * 2); if (this._fa > 0) ctx.fill(); if (this._lw > 0) ctx.stroke(); },
        drawEllipse(x, y, rx, ry) { ctx.beginPath(); ctx.ellipse(x, y, Math.max(0.1, rx), Math.max(0.1, ry), 0, 0, Math.PI * 2); if (this._fa > 0) ctx.fill(); if (this._lw > 0) ctx.stroke(); },
        drawRoundedRect(x, y, w, h, r) { ctx.beginPath(); ctx.roundRect(x, y, w, h, r); if (this._fa > 0) ctx.fill(); if (this._lw > 0) ctx.stroke(); },
        drawRect(x, y, w, h) { if (this._fa > 0) ctx.fillRect(x, y, w, h); if (this._lw > 0) ctx.strokeRect(x, y, w, h); },
        moveTo(x, y) { ctx.beginPath(); ctx.moveTo(x, y); },
        lineTo(x, y) { ctx.lineTo(x, y); if (this._lw > 0) ctx.stroke(); },
        quadraticCurveTo(cx, cy, x, y) { ctx.quadraticCurveTo(cx, cy, x, y); },
        arc(x, y, r, s, e, ccw) { ctx.arc(x, y, r, s, e, ccw); },
        closePath() { ctx.closePath(); if (this._fa > 0) ctx.fill(); },
        fillText(txt, x, y, size) { ctx.font = `${size}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(txt, x, y); }
    };
}

function drawBadges(g, cx, cy, size, badges) {
    if (!badges || badges.length === 0) return;
    const slots = [
        { x: -0.35, y: -0.1 }, { x: 0.35, y: -0.1 },
        { x: -0.2, y: 0.15 }, { x: 0.2, y: 0.15 },
        { x: -0.25, y: 0.4 }, { x: 0.25, y: 0.4 }
    ];
    badges.slice(0, 6).forEach((badgeId, i) => {
        const badge = BADGE_PARTS.find(b => b.id === badgeId);
        if (!badge) return;
        const slot = slots[i];
        const bx = cx + slot.x * size;
        const by = cy + slot.y * size;
        g.beginFill(badge.color, 0.4);
        g.drawCircle(bx, by, size * 0.12);
        g.endFill();
        g.beginFill(0xFFFFFF);
        g.fillText(badge.icon, bx, by, size * 0.15);
    });
}

function startPhase3() {
    // Phase 3 ÏãúÏûë Ïãú Ìï≠ÏÉÅ ÏßÑÌôî Î†àÎ≤® ÌôïÏù∏
    // runnerDistÍ∞Ä 0Ïù¥Î©¥ Ï≤òÏùå ÏãúÏûëÏù¥ÎØÄÎ°ú Î†àÎ≤® 0
    if ((GameState.runnerDist || 0) === 0) {
        GameState.evolutionGauge = 0;
        GameState.evolutionLevel = 0;
        GameState.save();
    }
    
    runnerDist = GameState.runnerDist || 0;
    bgOffset = 0;
    lastGapTime = 0;
    runnerHP = 3;
    invincibleUntil = 0;
    evolutionGauge = GameState.evolutionGauge || 0;
    evolutionLevel = GameState.evolutionLevel || 0;
    evolutionAnimating = false;
    sparkles = [];
    bgParticles = [];
    zoneTransitionTimer = 0;
    runnerGraphics = null; // Graphics Í∞ùÏ≤¥ Ï¥àÍ∏∞Ìôî
    
    // ÎîîÎ≤ÑÍ∑∏ Î°úÍ∑∏
    console.log('startPhase3: evolutionLevel =', evolutionLevel, 'runnerDist =', runnerDist);
    
    currentCreature = evolveCreatureByLevel(GameState.creature, evolutionLevel);
    
    const zone = getCurrentZone(runnerDist);
    currentZoneId = zone.id;
    const skyTop = parseInt(zone.sky[0].replace('#', ''), 16);
    initPixi(skyTop);
    
    runner = { x: 80, y: 0, w: 50, h: 70, vy: 0, onGround: true };
    runnerGaps = [];
    runnerItems = [];
    
    // Ï¥àÍ∏∞ Î∞∞Í≤Ω ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
    spawnBgParticles(zone.id);
    
    const t = GameState.t.bind(GameState);
    const birthEnv = getEnvById(GameState.envId);
    
    app.innerHTML = `
        <!-- Ï§ëÏïô ÏÉÅÎã®: ÏãúÎåÄ Ïù¥Î¶Ñ ÌÅ¨Í≤å -->
        <div id="era-display" style="position: fixed; top: calc(15px + var(--safe-top)); left: 50%; transform: translateX(-50%); 
            background: linear-gradient(135deg, rgba(0,0,0,0.7), rgba(30,30,60,0.8)); 
            border-radius: 16px; padding: 8px 24px; backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1); z-index: 100;">
            <div style="font-size: 1.4rem; font-weight: 900; color: #fff; text-shadow: 0 2px 8px rgba(0,0,0,0.5);" id="era-name">${zone.name}</div>
        </div>
        
        <!-- ÏãúÎåÄ Ï†ÑÌôò ÏïåÎ¶º -->
        <div id="zone-transition" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(255,215,0,0.9), rgba(255,165,0,0.9));
            border-radius: 20px; padding: 20px 40px; z-index: 200; display: none;
            box-shadow: 0 0 40px rgba(255,215,0,0.5);">
            <div style="font-size: 1.2rem; font-weight: 900; color: #000; text-align: center;">üåç Î¨∏Î™ÖÏù¥ Ï†ÑÌôòÎêòÏóàÏäµÎãàÎã§!</div>
            <div style="font-size: 1.6rem; font-weight: 900; color: #333; text-align: center; margin-top: 8px;" id="new-era-name"></div>
        </div>
        
        <!-- Ï¢åÏ∏° ÏÉÅÎã®: HP, ÏßÑÌôî Í≤åÏù¥ÏßÄ -->
        <div class="hud-top" style="display: flex; justify-content: space-between; align-items: flex-start; padding: 12px 16px; padding-top: calc(55px + var(--safe-top));">
            <div style="background: rgba(0,0,0,0.6); border-radius: 12px; padding: 10px 14px; backdrop-filter: blur(8px);">
                <div style="display: flex; gap: 3px; margin-bottom: 6px;" id="hp-display">${'‚ù§Ô∏è'.repeat(runnerHP)}${'üñ§'.repeat(Math.max(0, 3 - runnerHP))}</div>
                <!-- ÏßÑÌôî Í≤åÏù¥ÏßÄ -->
                <div>
                    <div style="font-size: 0.65rem; color: #aaa; margin-bottom: 2px;">üß¨ ÏßÑÌôî <span id="evo-count">${Math.floor(evolutionGauge / 5)}</span>/20</div>
                    <div style="width: 100px; height: 8px; background: rgba(0,0,0,0.5); border-radius: 4px; overflow: hidden;">
                        <div id="evo-gauge-bar" style="width: ${evolutionGauge}%; height: 100%; background: linear-gradient(90deg, #9d4edd, #ff6b6b); transition: width 0.3s;"></div>
                    </div>
                    <div style="font-size: 0.6rem; color: #c77dff; margin-top: 2px;">Î¨∏Î™Ö Lv.${evolutionLevel + 1}/5</div>
                </div>
            </div>
            
            <!-- Ïö∞Ï∏° ÏÉÅÎã®: Ï∂úÏÉùÏßÄ + Ìôà -->
            <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 8px;">
                <div style="display: flex; gap: 6px; align-items: center;">
                    <div style="background: rgba(0,0,0,0.6); border-radius: 10px; padding: 6px 10px; backdrop-filter: blur(8px); display: flex; align-items: center; gap: 6px;">
                        <span style="font-size: 1.2rem;">${birthEnv?.icon || 'üåä'}</span>
                        <span style="font-size: 0.7rem; color: #aaa;">${birthEnv?.name || 'Ìï¥Ïñë'}</span>
                    </div>
                    <button class="hud-btn" id="btn-home-p3" style="width: 36px; height: 36px; font-size: 1rem;">üè†</button>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button class="action-btn" id="btn-duck" style="font-size: 1rem;">‚¨áÔ∏è</button>
            <button class="action-btn" id="btn-jump-p3">‚¨ÜÔ∏è</button>
        </div>
        <div class="modal" id="modal-p3-gameover">
            <div class="modal-box">
                <div class="modal-icon">üï≥Ô∏è</div>
                <h2 class="modal-title fail">${t('p3Gameover')}</h2>
                <p class="modal-desc">${t('p3GameoverDesc')}</p>
                <div class="modal-stats"><div class="stat-row"><span class="stat-label">${t('p3Distance')}</span><span class="stat-val" id="p3go-dist">0m</span></div></div>
                <div class="modal-btns"><button class="btn btn-primary btn-block" id="btn-p3-retry">üîÑ ${t('retry')}</button></div>
            </div>
        </div>
        <div class="modal" id="modal-evolution">
            <div class="modal-box">
                <div class="modal-icon">‚ú®</div>
                <h2 class="modal-title" style="color: #ffd700;">ÏßÑÌôî!</h2>
                <p class="modal-desc" id="evo-desc">ÏÉàÎ°úÏö¥ ÌòïÌÉúÎ°ú ÏßÑÌôîÌñàÏäµÎãàÎã§!</p>
                <div id="evo-preview" style="width: 140px; height: 140px; margin: 15px auto; background: rgba(0,0,0,0.4); border-radius: 16px;"></div>
                <div class="modal-btns"><button class="btn btn-primary btn-block" id="btn-evo-continue">Í≥ÑÏÜç ‚Üí</button></div>
            </div>
        </div>
        <div class="modal" id="modal-dice">
            <div class="modal-box">
                <div class="modal-icon">üé≤</div>
                <h2 class="modal-title">ÏßÑÌôî Ï£ºÏÇ¨ÏúÑ!</h2>
                <p class="modal-desc">51 Ïù¥ÏÉÅÏù¥Î©¥ ÏÉàÎ°úÏö¥ ÌõàÏû• ÌöçÎìù!</p>
                <div id="dice-number" style="font-size: 3rem; font-weight: 900; color: #ffd700; margin: 20px 0;">?</div>
                <div id="dice-result"></div>
            </div>
        </div>
        <div class="modal" id="modal-p3-clear">
            <div class="modal-box">
                <div class="modal-icon">üéâ</div>
                <h2 class="modal-title win">${t('p3Final')}</h2>
                <p class="modal-desc">${t('p3FinalDesc')}</p>
                <div id="final-preview" style="width: 140px; height: 140px; margin: 15px auto; background: rgba(0,0,0,0.4); border-radius: 16px;"></div>
                <div class="modal-btns"><button class="btn btn-primary btn-block" id="btn-p3-finish">üéâ ÏôÑÎ£å!</button></div>
            </div>
        </div>
    `;
    
    setupRunnerControls();
    setupRunnerHUD();
    
    gameLoop = delta => updateRunner(delta);
    pixiApp.ticker.add(gameLoop);
    p3GameRunning = true;
}

function setupRunnerControls() {
    const jumpPower = CONFIG.P3_JUMP_POWER * (GameState.badges.includes('jump') ? 1.15 : 1);
    const jump = () => { if (runner.onGround) { runner.vy = jumpPower; runner.onGround = false; SFX.play('jump'); } };
    const duckStart = () => { if (runner.onGround) runner.h = 35; };
    const duckEnd = () => { runner.h = 70; };
    
    document.getElementById('btn-jump-p3').onclick = jump;
    document.getElementById('btn-jump-p3').ontouchstart = e => { e.preventDefault(); jump(); };
    document.getElementById('btn-duck').ontouchstart = e => { e.preventDefault(); duckStart(); };
    document.getElementById('btn-duck').ontouchend = duckEnd;
    document.getElementById('btn-duck').onmousedown = duckStart;
    document.getElementById('btn-duck').onmouseup = duckEnd;
    
    const keyDown = e => {
        if (!p3GameRunning) return;
        if (e.key === ' ' || e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') jump();
        if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') duckStart();
    };
    const keyUp = e => {
        if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') duckEnd();
    };
    window.removeEventListener('keydown', keyDown);
    window.removeEventListener('keyup', keyUp);
    window.addEventListener('keydown', keyDown);
    window.addEventListener('keyup', keyUp);
}

function setupRunnerHUD() {
    const t = GameState.t.bind(GameState);
    document.getElementById('btn-home-p3').onclick = () => {
        if (confirm(t('confirmHome'))) {
            p3GameRunning = false;
            if (gameLoop && pixiApp) pixiApp.ticker.remove(gameLoop);
            GameState.runnerDist = runnerDist;
            GameState.save();
            showTitle();
        }
    };
    document.getElementById('btn-p3-retry').onclick = () => {
        document.getElementById('modal-p3-gameover').classList.remove('show');
        startPhase3();
    };
    document.getElementById('btn-evo-continue').onclick = () => {
        document.getElementById('modal-evolution').classList.remove('show');
        evolutionAnimating = false;
        p3GameRunning = true;
    };
    document.getElementById('btn-p3-finish').onclick = () => {
        document.getElementById('modal-p3-clear').classList.remove('show');
        showEnding();
    };
}

function updateRunner(delta) {
    if (!p3GameRunning || !pixiApp || evolutionAnimating) return;
    
    const zone = getCurrentZone(runnerDist);
    const groundY = pixiApp.screen.height - 80;
    const now = Date.now();
    const baseSpeed = CONFIG.P3_BASE_SPEED;
    
    // Î¨ºÎ¶¨
    runner.vy += CONFIG.P3_GRAVITY;
    runner.y += runner.vy;
    
    // Í∞àÎùºÏßÑ Ìãà ÏúÑÏóê ÏûàÎäîÏßÄ ÌôïÏù∏
    let onGap = false;
    for (const gap of runnerGaps) {
        if (runner.x + runner.w > gap.x + 10 && runner.x < gap.x + gap.w - 10) {
            onGap = true;
            break;
        }
    }
    
    // ÎïÖÏóê Ï∞©ÏßÄ (Ìãà ÏúÑÍ∞Ä ÏïÑÎãê ÎïåÎßå)
    if (!onGap && runner.y >= groundY - runner.h) {
        runner.y = groundY - runner.h;
        runner.vy = 0;
        runner.onGround = true;
    } else if (onGap && runner.y >= groundY - runner.h && runner.onGround) {
        // ÌãàÏóê Îπ†Ïßê!
        runner.onGround = false;
        SFX.play('fall');
    }
    
    // ÌãàÏóê Îπ†Ï†∏ÏÑú ÌôîÎ©¥ ÏïÑÎûòÎ°ú Îñ®Ïñ¥ÏßÄÎ©¥ Í≤åÏûÑÏò§Î≤Ñ
    if (runner.y > pixiApp.screen.height + 100) {
        runnerFail();
        return;
    }
    
    // Í±∞Î¶¨ ÏßÑÌñâ
    runnerDist += baseSpeed * 0.05;
    bgOffset += baseSpeed;
    
    // ÏãúÎåÄ Ï†ÑÌôò Ï≤¥ÌÅ¨
    if (zone.id !== currentZoneId) {
        currentZoneId = zone.id;
        showZoneTransition(zone.name);
        spawnBgParticles(zone.id); // ÏÉà ÏãúÎåÄ ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
    }
    
    // ÏãúÎåÄ Ï†ÑÌôò ÌÉÄÏù¥Î®∏
    if (zoneTransitionTimer > 0) {
        zoneTransitionTimer--;
        if (zoneTransitionTimer === 0) {
            const transEl = document.getElementById('zone-transition');
            if (transEl) transEl.style.display = 'none';
        }
    }
    
    // ÏãúÎåÄ Ïù¥Î¶Ñ ÏóÖÎç∞Ïù¥Ìä∏
    const eraNameEl = document.getElementById('era-name');
    if (eraNameEl) eraNameEl.textContent = zone.name;
    
    // Í∞àÎùºÏßÑ Ìãà ÏÉùÏÑ± (Îã§ÏñëÌïú Î™®Ïñë)
    if (now - lastGapTime > 2200 + Math.random() * 1200) {
        const gapW = 55 + Math.random() * 45;
        const gapType = Math.floor(Math.random() * 4); // 0-3: Îã§ÏñëÌïú Î™®Ïñë
        runnerGaps.push({ 
            x: pixiApp.screen.width + 50, 
            w: gapW, 
            zoneId: zone.id,
            type: gapType,
            seed: Math.random(), // Í∑†Ïó¥ Ìå®ÌÑ¥Ïö©
            depth: 0.6 + Math.random() * 0.4 // ÍπäÏù¥Í∞ê
        });
        lastGapTime = now;
    }
    
    // ÏïÑÏù¥ÌÖú ÏÉùÏÑ± (ÏßÑÌôî Í≤åÏù¥ÏßÄ ÏïÑÏù¥ÌÖú) - Ï∂úÌòÑÏú® ÎÜíÏûÑ
    if (Math.random() < 0.035) {
        runnerItems.push({ 
            x: pixiApp.screen.width + 50, 
            y: groundY - 80 - Math.random() * 60, 
            type: 'evo'
        });
    }
    
    // Í∞àÎùºÏßÑ Ìãà Ïù¥Îèô
    for (let i = runnerGaps.length - 1; i >= 0; i--) {
        const gap = runnerGaps[i];
        gap.x -= baseSpeed * 1.8;
        if (gap.x < -100) { 
            runnerGaps.splice(i, 1); 
        }
    }
    
    // ÏïÑÏù¥ÌÖú ÏàòÏßë
    for (let i = runnerItems.length - 1; i >= 0; i--) {
        const item = runnerItems[i];
        item.x -= baseSpeed * 1.8;
        if (item.x < -50) { runnerItems.splice(i, 1); continue; }
        
        const dx = (runner.x + runner.w / 2) - item.x;
        const dy = (runner.y + runner.h / 2) - item.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 45) {
            runnerItems.splice(i, 1);
            if (item.type === 'evo') {
                SFX.play('coin');
                
                // Ïù¥ÎØ∏ ÏµúÎåÄ Î†àÎ≤®Ïù¥Î©¥ Í≤åÏù¥ÏßÄ ÏàòÏßë Î¨¥Ïãú
                if (evolutionLevel >= 5) continue;
                
                evolutionGauge += 5; // 20Í∞ú Î™®ÏúºÎ©¥ 100% (5% x 20)
                
                // 100% Ï¥àÍ≥º Î∞©ÏßÄ
                if (evolutionGauge > 100) evolutionGauge = 100;
                
                GameState.evolutionGauge = evolutionGauge;
                
                // Í≤åÏù¥ÏßÄ Î∞î Î∞è Ïπ¥Ïö¥Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
                const gaugeBar = document.getElementById('evo-gauge-bar');
                const evoCount = document.getElementById('evo-count');
                if (gaugeBar) gaugeBar.style.width = `${evolutionGauge}%`;
                if (evoCount) evoCount.textContent = Math.floor(evolutionGauge / 5);
                
                // ÏßÑÌôî Í≤åÏù¥ÏßÄ Í∞ÄÎìù Ï∞®Î©¥ ÏßÑÌôî + Îã§Ïùå Î¨∏Î™ÖÏúºÎ°ú!
                if (evolutionGauge >= 100 && evolutionLevel < 5) {
                    evolutionGauge = 0;
                    evolutionLevel++;
                    GameState.evolutionLevel = evolutionLevel;
                    GameState.evolutionGauge = 0;
                    
                    // Îã§Ïùå Î¨∏Î™Ö ÏãúÏûë Í±∞Î¶¨Î°ú Ï†êÌîÑ
                    // Î†àÎ≤® 5Îäî ÌòÑÎåÄ Î¨∏Î™ÖÏóêÏÑú ÌÅ¥Î¶¨Ïñ¥ÌïòÎØÄÎ°ú 1200 Ïú†ÏßÄ
                    const zoneStarts = [0, 300, 600, 900, 1200, 1200];
                    runnerDist = zoneStarts[Math.min(evolutionLevel, 5)];
                    GameState.runnerDist = runnerDist;
                    GameState.save();
                    triggerEvolution(evolutionLevel);
                    return;
                }
            }
        }
    }
    
    // Î∞∞Í≤Ω ÌååÌã∞ÌÅ¥ ÏóÖÎç∞Ïù¥Ìä∏
    updateBgParticles(baseSpeed);
    
    // Î∞òÏßùÏù¥ ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
    if (Math.random() < 0.03) {
        sparkles.push({
            x: Math.random() * pixiApp.screen.width,
            y: Math.random() * (groundY - 50),
            life: 1,
            size: 2 + Math.random() * 3,
            speed: 0.5 + Math.random() * 1
        });
    }
    
    // ÌÅ¨Î¶¨Ï≤ò ÏóÖÎç∞Ïù¥Ìä∏
    try {
        currentCreature = evolveCreatureByLevel(GameState.creature, evolutionLevel);
    } catch(e) {
        console.error('Creature evolution error:', e);
    }
    
    // Î†åÎçîÎßÅ
    try {
        renderRunnerScene(zone, groundY);
    } catch(e) {
        console.error('Render error:', e);
    }
    
    // Î†àÎ≤® 5 ÎèÑÎã¨ÌïòÎ©¥ ÌÅ¥Î¶¨Ïñ¥ (triggerEvolutionÏóêÏÑú Ï≤òÎ¶¨)
}

// Î∞∞Í≤Ω ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
function spawnBgParticles(zoneId) {
    try {
        bgParticles = [];
        const styles = BG_PARTICLE_STYLES[zoneId] || BG_PARTICLE_STYLES.primitive;
        if (!styles) return;
        
        const screenW = pixiApp?.screen?.width || 400;
        const screenH = pixiApp?.screen?.height || 600;
        
        styles.forEach(style => {
            for (let i = 0; i < style.count; i++) {
                bgParticles.push({
                    x: Math.random() * screenW,
                    y: Math.random() * (screenH - 100),
                    type: style.type,
                    color: style.color,
                size: 3 + Math.random() * 5,
                speedX: -0.5 - Math.random() * 2,
                speedY: style.type === 'snow' ? 0.5 + Math.random() : (Math.random() - 0.5) * 0.5,
                phase: Math.random() * Math.PI * 2,
                alpha: 0.4 + Math.random() * 0.4
            });
        }
    });
    } catch(e) {
        console.error('spawnBgParticles error:', e);
    }
}

// Î∞∞Í≤Ω ÌååÌã∞ÌÅ¥ ÏóÖÎç∞Ïù¥Ìä∏
function updateBgParticles(baseSpeed) {
    try {
    const screenW = pixiApp?.screen?.width || 400;
    const screenH = pixiApp?.screen?.height || 600;
    
    for (const p of bgParticles) {
        p.x += p.speedX - baseSpeed * 0.3;
        p.y += p.speedY;
        p.phase += 0.05;
        
        // ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎ©¥ Ïû¨ÏÉùÏÑ±
        if (p.x < -20) {
            p.x = screenW + 20;
            p.y = Math.random() * (screenH - 100);
        }
        if (p.y > screenH - 80) {
            p.y = -10;
            p.x = Math.random() * screenW;
        }
    }
    } catch(e) {
        console.error('updateBgParticles error:', e);
    }
}

function showZoneTransition(zoneName) {
    const transEl = document.getElementById('zone-transition');
    const newEraEl = document.getElementById('new-era-name');
    if (transEl && newEraEl) {
        newEraEl.textContent = zoneName;
        transEl.style.display = 'block';
        zoneTransitionTimer = 120; // ÏïΩ 2Ï¥à
    }
}

function triggerEvolution(level) {
    p3GameRunning = false;
    evolutionAnimating = true;
    SFX.play('evolve');
    GameState.save();
    
    const evoNames = {
        1: 'ü¶µ Îã§Î¶¨Í∞Ä ÏûêÎûêÏäµÎãàÎã§!',
        2: 'üí™ ÌåîÏù¥ ÏûêÎûêÏäµÎãàÎã§!',
        3: '‚ú® ÌäπÏßïÏù¥ ÎÇòÌÉÄÎÇ¨ÏäµÎãàÎã§!',
        4: 'üåü ÏôÑÏ†ÑÌûà ÏßÑÌôîÌñàÏäµÎãàÎã§!',
        5: 'ü§ñ Í∏∞Í≥ÑÏôÄ ÏúµÌï©ÌñàÏäµÎãàÎã§!'
    };
    
    // Î†àÎ≤® 5Î©¥ Í≤åÏûÑ ÌÅ¥Î¶¨Ïñ¥!
    if (level >= 5) {
        setTimeout(() => {
            document.getElementById('modal-evolution').classList.remove('show');
            runnerComplete();
        }, 2000);
    }
    
    document.getElementById('evo-desc').textContent = evoNames[level] || 'ÏßÑÌôîÌñàÏäµÎãàÎã§!';
    setTimeout(() => {
        renderCreatureCanvasLevel('evo-preview', GameState.creature, level);
    }, 100);
    document.getElementById('modal-evolution').classList.add('show');
}

function rollEvoDice() {
    document.getElementById('modal-dice').classList.add('show');
    const diceEl = document.getElementById('dice-number');
    const resultEl = document.getElementById('dice-result');
    SFX.play('dice'); // Ï£ºÏÇ¨ÏúÑ Ìö®Í≥ºÏùå
    
    let count = 0;
    const anim = setInterval(() => {
        diceEl.textContent = Math.floor(Math.random() * 100) + 1;
        count++;
        if (count > 20) {
            clearInterval(anim);
            const luckBonus = GameState.badges.includes('luck') ? 5 : 0;
            const roll = Math.floor(Math.random() * 100) + 1 + luckBonus;
            diceEl.textContent = Math.min(100, roll);
            
            if (roll >= 51) {
                diceEl.style.color = '#10b981';
                const owned = GameState.badges || [];
                const available = BADGE_PARTS.filter(b => !owned.includes(b.id));
                
                if (available.length > 0) {
                    const badge = available[Math.floor(Math.random() * available.length)];
                    GameState.badges.push(badge.id);
                    GameState.save();
                    
                    resultEl.innerHTML = `
                        <div style="margin: 15px 0; text-align: center;">
                            <div style="font-size: 2.5rem;">${badge.icon}</div>
                            <div style="font-size: 1rem; font-weight: 700; color: #10b981; margin: 6px 0;">${badge.name} ÌöçÎìù!</div>
                            <div style="font-size: 0.8rem; color: #ffd700;">${badge.effect}</div>
                        </div>
                        <button class="btn btn-primary btn-block" id="btn-dice-ok">ÌôïÏù∏</button>
                    `;
                } else {
                    resultEl.innerHTML = `<p style="color: #888; margin: 15px 0;">Î™®Îì† ÌõàÏû•ÏùÑ ÌöçÎìùÌñàÏäµÎãàÎã§!</p><button class="btn btn-primary btn-block" id="btn-dice-ok">ÌôïÏù∏</button>`;
                }
            } else {
                diceEl.style.color = '#ff4466';
                resultEl.innerHTML = `
                    <div style="margin: 15px 0; text-align: center;">
                        <div style="font-size: 2rem;">üò¢</div>
                        <div style="font-size: 0.9rem; color: #888;">Îã§Ïùå Í∏∞ÌöåÏóê...</div>
                    </div>
                    <button class="btn btn-outline btn-block" id="btn-dice-ok">Í≥ÑÏÜç</button>
                `;
            }
            
            document.getElementById('btn-dice-ok').onclick = () => {
                document.getElementById('modal-dice').classList.remove('show');
                diceEl.style.color = '#ffd700';
                p3GameRunning = true;
            };
        }
    }, 50);
}

let runnerGraphics = null; // Ïû¨ÏÇ¨Ïö©Ìï† Graphics Í∞ùÏ≤¥

function renderRunnerScene(zone, groundY) {
    if (!pixiApp) return;
    const w = pixiApp.screen.width, h = pixiApp.screen.height, t = Date.now() * 0.001, now = Date.now();
    
    // Graphics Í∞ùÏ≤¥ Ïû¨ÏÇ¨Ïö©
    if (!runnerGraphics) {
        runnerGraphics = new PIXI.Graphics();
        pixiApp.stage.addChild(runnerGraphics);
    }
    const g = runnerGraphics;
    g.clear(); // Ïù¥Ï†Ñ ÌîÑÎ†àÏûÑ ÏßÄÏö∞Í∏∞
    
    // ÌïòÎäò Í∑∏ÎùºÎç∞Ïù¥ÏÖò
    const skyTop = parseInt(zone.sky[0].replace('#', ''), 16);
    const skyBot = parseInt(zone.sky[1].replace('#', ''), 16);
    for (let i = 0; i < 20; i++) {
        g.beginFill(lerpColor(skyTop, skyBot, i / 20));
        g.drawRect(0, i * (groundY / 20), w, groundY / 20 + 1);
        g.endFill();
    }
    
    // Î∞∞Í≤Ω ÌååÌã∞ÌÅ¥ Î†åÎçîÎßÅ
    for (const p of bgParticles) {
        const px = p.x;
        const py = p.y + Math.sin(p.phase) * 3;
        g.beginFill(p.color, p.alpha);
        
        switch(p.type) {
            case 'leaf':
            case 'butterfly':
                // ÎÇòÎ≠áÏûé/ÎÇòÎπÑ - ÌöåÏ†ÑÌïòÎäî ÌÉÄÏõê
                const rot = t * 2 + p.phase;
                g.drawEllipse(px, py, p.size * Math.abs(Math.cos(rot)), p.size * 0.5);
                break;
            case 'snow':
            case 'sparkle':
                // Îàà/Î∞òÏßùÏù¥ - Ïõê
                g.drawCircle(px, py, p.size * (0.5 + Math.sin(p.phase) * 0.3));
                break;
            case 'ash':
            case 'dust':
                // Ïû¨/Î®ºÏßÄ - ÏûëÏùÄ Ïõê
                g.drawCircle(px, py, p.size * 0.5);
                break;
            case 'ember':
            case 'spark':
                // Î∂àÍΩÉ - Í∏ÄÎ°úÏö∞ Ìö®Í≥º
                g.endFill();
                g.beginFill(p.color, p.alpha * 0.3);
                g.drawCircle(px, py, p.size * 1.5);
                g.endFill();
                g.beginFill(0xFFFFFF, p.alpha);
                g.drawCircle(px, py, p.size * 0.4);
                break;
            case 'mist':
            case 'smoke':
                // ÏïàÍ∞ú/Ïó∞Í∏∞ - ÌÅ∞ ÌùêÎ¶∞ Ïõê
                g.drawCircle(px, py, p.size * 2);
                break;
            case 'neon':
            case 'data':
            case 'light':
                // ÎÑ§Ïò®/Îç∞Ïù¥ÌÑ∞ - ÏÇ¨Í∞ÅÌòï
                g.endFill();
                g.beginFill(p.color, p.alpha * 0.5);
                g.drawRect(px - 1, py - p.size, 2, p.size * 2);
                break;
            case 'pterodactyl':
                // ÏùµÎ£° Ïã§Î£®Ïó£
                g.moveTo(px, py);
                g.lineTo(px - p.size * 2, py + p.size);
                g.lineTo(px, py + p.size * 0.3);
                g.lineTo(px + p.size * 2, py + p.size);
                g.closePath();
                break;
            default:
                g.drawCircle(px, py, p.size);
        }
        g.endFill();
    }
    
    // Î∞òÏßùÏù¥ ÌååÌã∞ÌÅ¥
    for (let i = sparkles.length - 1; i >= 0; i--) {
        const sp = sparkles[i];
        sp.life -= 0.02;
        sp.y -= sp.speed;
        if (sp.life <= 0) { sparkles.splice(i, 1); continue; }
        
        const alpha = sp.life * 0.8;
        const pulse = 0.5 + Math.sin(t * 8 + i) * 0.5;
        g.beginFill(0xFFFFFF, alpha * pulse);
        g.drawCircle(sp.x, sp.y, sp.size * sp.life);
        g.endFill();
    }
    
    // Î∞∞Í≤Ω Ïû•Ïãù
    drawStageBg(g, zone, w, groundY, t);
    
    // ÎïÖ (Í∞àÎùºÏßÑ Ìãà Ï†úÏô∏ÌïòÍ≥† Í∑∏Î¶¨Í∏∞)
    const groundCol = parseInt(zone.ground.replace('#', ''), 16);
    const groundDark = lerpColor(groundCol, 0x000000, 0.3);
    
    // Í∞àÎùºÏßÑ Ìãà Î†åÎçîÎßÅ (Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ)
    const gapStyle = GAP_STYLES[zone.id] || GAP_STYLES.primitive;
    for (const gap of runnerGaps) {
        const gType = gap.type || 0;
        const seed = gap.seed || 0.5;
        const depth = gap.depth || 0.8;
        
        // Ìãà ÎÇ¥Î∂Ä Í∑∏ÎùºÎç∞Ïù¥ÏÖò (ÍπäÏù¥Í∞ê)
        for (let layer = 0; layer < 4; layer++) {
            const layerAlpha = 0.3 + layer * 0.2;
            const layerInset = layer * 3;
            g.beginFill(gapStyle.color, layerAlpha * depth);
            g.drawRect(gap.x + layerInset, groundY + layer * 10, gap.w - layerInset * 2, h - groundY);
            g.endFill();
        }
        
        // Í∑†Ïó¥ Ìå®ÌÑ¥ (ÌÉÄÏûÖÎ≥ÑÎ°ú Îã§Î•∏ Î™®Ïñë)
        g.lineStyle(2, gapStyle.edgeColor, 0.7);
        
        if (gType === 0) {
            // ÏßÄÍ∑∏Ïû¨Í∑∏ Í∑†Ïó¥
            const points = 5 + Math.floor(seed * 4);
            for (let side = 0; side < 2; side++) {
                const baseX = side === 0 ? gap.x : gap.x + gap.w;
                g.moveTo(baseX, groundY);
                for (let i = 1; i <= points; i++) {
                    const zigzag = (side === 0 ? -1 : 1) * (seed * 8 + Math.sin(i * seed * 10) * 5);
                    g.lineTo(baseX + zigzag, groundY + (i / points) * (h - groundY) * 0.6);
                }
            }
        } else if (gType === 1) {
            // Í±∞ÎØ∏Ï§Ñ Í∑†Ïó¥
            const cx = gap.x + gap.w / 2;
            for (let i = 0; i < 6; i++) {
                const angle = -Math.PI / 2 + (i - 2.5) * 0.3 + seed * 0.5;
                const len = 15 + seed * 20;
                g.moveTo(cx, groundY);
                g.lineTo(cx + Math.cos(angle) * len, groundY + Math.sin(angle) * len);
            }
        } else if (gType === 2) {
            // Í≥ÑÎã®Ïãù Í∑†Ïó¥
            for (let side = 0; side < 2; side++) {
                const baseX = side === 0 ? gap.x : gap.x + gap.w;
                const dir = side === 0 ? -1 : 1;
                g.moveTo(baseX, groundY);
                for (let i = 0; i < 4; i++) {
                    const stepY = groundY + i * 20 + 10;
                    g.lineTo(baseX + dir * (5 + seed * 10), stepY);
                    g.lineTo(baseX + dir * (5 + seed * 10), stepY + 15);
                }
            }
        } else {
            // Î∂àÍ∑úÏπô Í∑†Ïó¥
            for (let i = 0; i < 4; i++) {
                const sx = gap.x + seed * gap.w * 0.3 + i * gap.w * 0.2;
                const ex = sx + (Math.random() - 0.5) * 15;
                g.moveTo(sx, groundY);
                g.bezierCurveTo(sx - 5, groundY - 10, ex + 5, groundY - 15, ex, groundY - 20 - i * 3);
            }
        }
        g.lineStyle(0);
        
        // Ìãà Í∞ÄÏû•ÏûêÎ¶¨ ÌïòÏù¥ÎùºÏù¥Ìä∏
        g.lineStyle(3, gapStyle.edgeColor, 0.9);
        g.moveTo(gap.x, groundY);
        g.lineTo(gap.x, groundY + 30);
        g.moveTo(gap.x + gap.w, groundY);
        g.lineTo(gap.x + gap.w, groundY + 30);
        g.lineStyle(0);
        
        // ÌãàÏóêÏÑú ÎÇòÏò§Îäî Ïù¥ÌéôÌä∏ (Î¨∏Î™ÖÎ≥Ñ)
        if (zone.id === 'dinosaur') {
            // Ïö©Ïïî Î∂àÎπõ
            const glowPulse = 0.3 + Math.sin(t * 4 + gap.x * 0.01) * 0.2;
            g.beginFill(0xFF4500, glowPulse);
            g.drawEllipse(gap.x + gap.w / 2, groundY + 15, gap.w * 0.4, 8);
            g.endFill();
            // Ïó∞Í∏∞
            for (let s = 0; s < 3; s++) {
                const smokeY = groundY - 10 - s * 15 - (t * 20 + s * 10) % 40;
                const smokeAlpha = Math.max(0, 0.3 - s * 0.1);
                g.beginFill(0x333333, smokeAlpha);
                g.drawCircle(gap.x + gap.w / 2 + Math.sin(t + s) * 5, smokeY, 6 + s * 2);
                g.endFill();
            }
        } else if (zone.id === 'ice') {
            // ÏñºÏùå Î∞òÏßùÏûÑ
            for (let i = 0; i < 3; i++) {
                const sparkle = Math.sin(t * 6 + i * 2 + gap.x * 0.02) > 0.7;
                if (sparkle) {
                    g.beginFill(0xFFFFFF, 0.8);
                    g.drawCircle(gap.x + 5 + i * gap.w * 0.4, groundY + 5, 2);
                    g.endFill();
                }
            }
            // ÏïàÍ∞ú
            g.beginFill(0xE0FFFF, 0.2);
            g.drawEllipse(gap.x + gap.w / 2, groundY - 5, gap.w * 0.6, 10);
            g.endFill();
        } else if (zone.id === 'modern') {
            // Ï†ÑÍ∏∞ Ïä§ÌååÌÅ¨
            if (Math.random() < 0.1) {
                g.lineStyle(1, 0x00FFFF, 0.8);
                const sx = gap.x + Math.random() * gap.w;
                g.moveTo(sx, groundY);
                g.lineTo(sx + (Math.random() - 0.5) * 10, groundY - 15);
                g.lineTo(sx + (Math.random() - 0.5) * 15, groundY - 25);
                g.lineStyle(0);
            }
            // ÎÑ§Ïò® Í∏ÄÎ°úÏö∞
            g.beginFill(0x00FFFF, 0.15 + Math.sin(t * 8) * 0.1);
            g.drawRect(gap.x, groundY, gap.w, 5);
            g.endFill();
        } else {
            // Í∏∞Î≥∏: Î®ºÏßÄ ÌååÌã∞ÌÅ¥
            for (let d = 0; d < 2; d++) {
                const dustY = groundY - 5 - ((t * 15 + d * 20 + gap.x) % 30);
                g.beginFill(0x8B7355, 0.3);
                g.drawCircle(gap.x + gap.w * 0.3 + d * gap.w * 0.4, dustY, 3);
                g.endFill();
            }
        }
    }
    
    // ÎïÖ Í∑∏Î¶¨Í∏∞ (Ìãà ÏúÑÏóê ÎßàÏä§ÌÅ¨)
    g.beginFill(groundCol);
    let lastX = 0;
    const sortedGaps = [...runnerGaps].sort((a, b) => a.x - b.x);
    for (const gap of sortedGaps) {
        if (gap.x > lastX) {
            g.drawRect(lastX, groundY, gap.x - lastX, (h - groundY) * 0.4);
        }
        lastX = gap.x + gap.w;
    }
    if (lastX < w) {
        g.drawRect(lastX, groundY, w - lastX, (h - groundY) * 0.4);
    }
    g.endFill();
    
    // ÎïÖ ÏïÑÎûòÏ™Ω (Ïñ¥ÎëêÏö¥ Î∂ÄÎ∂Ñ)
    g.beginFill(groundDark);
    lastX = 0;
    for (const gap of sortedGaps) {
        if (gap.x > lastX) {
            g.drawRect(lastX, groundY + (h - groundY) * 0.4, gap.x - lastX, (h - groundY) * 0.6);
        }
        lastX = gap.x + gap.w;
    }
    if (lastX < w) {
        g.drawRect(lastX, groundY + (h - groundY) * 0.4, w - lastX, (h - groundY) * 0.6);
    }
    g.endFill();
    
    // ÎïÖ Ìå®ÌÑ¥ (Í∑∏Î¶ºÏûê)
    g.beginFill(0x000000, 0.08);
    for (let dx = -bgOffset % 80; dx < w; dx += 80) {
        let inGap = false;
        for (const gap of runnerGaps) {
            if (dx + 20 > gap.x && dx + 20 < gap.x + gap.w) { inGap = true; break; }
        }
        if (!inGap) g.drawEllipse(dx + 20, groundY + 8, 25, 4);
    }
    g.endFill();
    
    // ÏßÑÌôî Í≤åÏù¥ÏßÄ ÏïÑÏù¥ÌÖú
    for (const item of runnerItems) {
        if (item.type === 'evo') {
            const bobY = Math.sin(t * 5 + item.x * 0.01) * 4;
            const pulse = 0.8 + Math.sin(t * 6) * 0.2;
            
            // Í∏ÄÎ°úÏö∞ Ìö®Í≥º
            g.beginFill(0x9d4edd, 0.2);
            g.drawCircle(item.x, item.y + bobY, 22 * pulse);
            g.endFill();
            
            // Ïô∏Î∂Ä Ïõê
            g.beginFill(0x9d4edd, 0.8);
            g.drawCircle(item.x, item.y + bobY, 14);
            g.endFill();
            
            // ÎÇ¥Î∂Ä Ïõê
            g.beginFill(0xc77dff);
            g.drawCircle(item.x, item.y + bobY, 9);
            g.endFill();
            
            // DNA Ïù¥Ï§ëÎÇòÏÑ† Ìö®Í≥º
            g.lineStyle(2, 0xFFFFFF, 0.8);
            for (let i = 0; i < 3; i++) {
                const angle = t * 4 + i * Math.PI * 2 / 3;
                const sx = Math.cos(angle) * 5;
                const sy = Math.sin(angle) * 3;
                g.moveTo(item.x + sx, item.y + bobY - 4 + sy);
                g.lineTo(item.x - sx, item.y + bobY + 4 - sy);
            }
            g.lineStyle(0);
            
            // ‚ú® Î∞òÏßùÏù¥
            g.beginFill(0xFFFFFF, 0.8);
            g.drawCircle(item.x - 4, item.y + bobY - 4, 2);
            g.endFill();
        }
    }
    
    // Ï∫êÎ¶≠ÌÑ∞
    const isInvincible = now < invincibleUntil;
    const blink = isInvincible && Math.floor(now / 100) % 2 === 0;
    if (!blink && currentCreature) {
        drawCreature(g, currentCreature, runner.x + runner.w / 2, runner.y + runner.h / 2 - 10, runner.h * 0.9, t);
    }
    if (isInvincible && !blink) {
        g.lineStyle(3, 0x00F5D4, 0.4 + Math.sin(t * 10) * 0.2);
        g.drawCircle(runner.x + runner.w / 2, runner.y + runner.h / 2, runner.w * 0.75);
        g.lineStyle(0);
    }
}

function hslToHex(h, s, l) {
    s /= 100; l /= 100;
    const a = s * Math.min(l, 1 - l);
    const f = n => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * color);
    };
    return (f(0) << 16) | (f(8) << 8) | f(4);
}

function drawBadgesPixi(g, cx, cy, size, badges) {
    if (!badges || badges.length === 0) return;
    const slots = [
        { x: -0.35, y: -0.1 }, { x: 0.35, y: -0.1 },
        { x: -0.2, y: 0.15 }, { x: 0.2, y: 0.15 },
        { x: -0.25, y: 0.4 }, { x: 0.25, y: 0.4 }
    ];
    badges.slice(0, 6).forEach((badgeId, i) => {
        const badge = BADGE_PARTS.find(b => b.id === badgeId);
        if (!badge) return;
        const slot = slots[i];
        const bx = cx + slot.x * size;
        const by = cy + slot.y * size;
        g.beginFill(badge.color, 0.5); g.drawCircle(bx, by, size * 0.1); g.endFill();
        const text = new PIXI.Text(badge.icon, { fontSize: size * 0.15, fontFamily: 'Arial' });
        text.anchor.set(0.5); text.x = bx; text.y = by;
        pixiApp.stage.addChild(text);
    });
}

function drawStageBg(g, zone, w, groundY, t) {
    const id = zone.id;
    
    // Î∞∞Í≤Ω Î†àÏù¥Ïñ¥ (Í∞ÄÏû• Î®º Í≥≥ - ÌùêÎ¶øÌïòÍ≥† ÏûëÏùå)
    // Ï§ëÍ∞Ñ Î†àÏù¥Ïñ¥ (Ï§ëÍ∞Ñ Í±∞Î¶¨ - ÏïΩÍ∞Ñ ÌùêÎ¶º)
    // Ï†ÑÍ≤Ω Î†àÏù¥Ïñ¥Îäî ÏÑ†Î™ÖÌïòÍ≤å
    
    if (id === 'primitive') {
        // Í∞ÄÏû• Î®º ÏÇ∞Îì§ (ÏïÑÏ£º ÌùêÎ¶º)
        g.beginFill(0x2d4a2d, 0.15);
        for (let i = 0; i < 4; i++) {
            const mx = ((w + 800) - (bgOffset * 0.02 + i * 400)) % (w + 800);
            g.moveTo(mx - 200, groundY - 50); g.lineTo(mx - 100, groundY - 180); g.lineTo(mx + 100, groundY - 150); g.lineTo(mx + 180, groundY - 50); g.closePath();
        }
        g.endFill();
        
        // Ï§ëÍ∞Ñ ÏÇ∞Îì§ (ÏïΩÍ∞Ñ ÌùêÎ¶º)
        g.beginFill(0x3d5c3d, 0.25);
        for (let i = 0; i < 3; i++) {
            const mx = ((w + 500) - (bgOffset * 0.04 + i * 350)) % (w + 500);
            g.moveTo(mx - 150, groundY); g.lineTo(mx - 50, groundY - 120 - i * 15); g.lineTo(mx + 50, groundY - 100); g.lineTo(mx + 120, groundY); g.closePath();
        }
        g.endFill();
        
        // Ïñ∏Îçï (Ï§ëÍ∞Ñ ÌùêÎ¶º)
        g.beginFill(0x4a6741, 0.35);
        for (let i = 0; i < 4; i++) { const hx = ((w + 350) - (bgOffset * 0.1 + i * 250)) % (w + 350); g.drawEllipse(hx, groundY, 100, 40); }
        g.endFill();
        
        // ÎÇòÎ¨¥ (Ï†ÑÍ≤Ω - ÏÑ†Î™Ö)
        for (let i = 0; i < 3; i++) {
            const tx = ((w + 220) - (bgOffset * 0.4 + i * 220)) % (w + 220);
            g.beginFill(0x000000, 0.15); g.drawEllipse(tx, groundY + 3, 25, 6); g.endFill();
            g.beginFill(0x5D4037); g.drawRect(tx - 6, groundY - 60, 12, 60); g.endFill();
            g.beginFill(0x2E7D32, 0.9); g.drawCircle(tx, groundY - 75, 30); g.endFill();
            g.beginFill(0x388E3C, 0.8); g.drawCircle(tx - 15, groundY - 65, 22); g.drawCircle(tx + 15, groundY - 65, 22); g.endFill();
        }
    } else if (id === 'dinosaur') {
        // ÏïÑÏ£º Î®º ÌôîÏÇ∞ (Ìù¨ÎØ∏)
        for (let i = 0; i < 3; i++) {
            const vx = ((w + 900) - (bgOffset * 0.03 + i * 600)) % (w + 900);
            g.beginFill(0x3d2817, 0.2);
            g.moveTo(vx - 150, groundY); g.lineTo(vx - 50, groundY - 200); g.lineTo(vx + 50, groundY - 200); g.lineTo(vx + 150, groundY); g.closePath(); g.endFill();
            g.beginFill(0xFF4500, 0.1); g.drawEllipse(vx, groundY - 190, 30, 15); g.endFill();
        }
        
        // Í∞ÄÍπåÏö¥ ÌôîÏÇ∞ (ÏÑ†Î™Ö)
        for (let i = 0; i < 2; i++) {
            const vx = ((w + 600) - (bgOffset * 0.08 + i * 500)) % (w + 600);
            g.beginFill(0x5D4037, 0.7);
            g.moveTo(vx - 100, groundY); g.lineTo(vx - 30, groundY - 130); g.lineTo(vx + 30, groundY - 130); g.lineTo(vx + 100, groundY); g.closePath(); g.endFill();
            g.beginFill(0xFF4500, 0.3 + Math.sin(t * 2 + i) * 0.15); g.drawEllipse(vx, groundY - 120, 25, 15); g.endFill();
            g.beginFill(0x424242, 0.3 + Math.sin(t * 3) * 0.1);
            g.drawEllipse(vx + Math.sin(t + i) * 10, groundY - 145, 20, 12);
            g.drawEllipse(vx + Math.sin(t * 1.5 + i) * 15, groundY - 160, 15, 10);
            g.endFill();
        }
    } else if (id === 'ice') {
        // Î®º ÎπôÏÇ∞ (ÌùêÎ¶º)
        g.beginFill(0x87CEEB, 0.15);
        for (let i = 0; i < 4; i++) {
            const ix = ((w + 700) - (bgOffset * 0.03 + i * 450)) % (w + 700);
            g.moveTo(ix - 120, groundY - 30); g.lineTo(ix - 60, groundY - 150); g.lineTo(ix + 60, groundY - 130); g.lineTo(ix + 100, groundY - 30); g.closePath();
        }
        g.endFill();
        
        // Í∞ÄÍπåÏö¥ ÎπôÏÇ∞ (ÏÑ†Î™Ö)
        g.beginFill(0xB3E5FC, 0.5);
        for (let i = 0; i < 3; i++) {
            const ix = ((w + 450) - (bgOffset * 0.1 + i * 350)) % (w + 450);
            g.moveTo(ix - 80, groundY); g.lineTo(ix - 40, groundY - 90); g.lineTo(ix + 20, groundY - 70); g.lineTo(ix + 60, groundY); g.closePath();
        }
        g.endFill();
        
        // Îàà (Ï†ÑÍ≤Ω)
        g.beginFill(0xFFFFFF, 0.6);
        for (let i = 0; i < 20; i++) {
            const sx = (i * 89 + bgOffset * 0.3 + Math.sin(t + i) * 30) % w;
            const sy = (i * 67 + t * 15) % (groundY - 30);
            g.drawCircle(sx, sy, 2 + (i % 3));
        }
        g.endFill();
    } else if (id === 'human') {
        // Î®º ÎèôÍµ¥ (ÌùêÎ¶º)
        for (let i = 0; i < 3; i++) {
            const cx = ((w + 700) - (bgOffset * 0.04 + i * 500)) % (w + 700);
            g.beginFill(0x4a3528, 0.2); g.arc(cx, groundY - 30, 100, Math.PI, 0); g.endFill();
        }
        
        // Í∞ÄÍπåÏö¥ ÎèôÍµ¥
        for (let i = 0; i < 2; i++) {
            const cx = ((w + 500) - (bgOffset * 0.12 + i * 400)) % (w + 500);
            g.beginFill(0x5D4037, 0.6); g.arc(cx, groundY, 70, Math.PI, 0); g.endFill();
            g.beginFill(0x3E2723, 0.8); g.arc(cx, groundY, 45, Math.PI, 0); g.endFill();
        }
        
        // Î™®Îã•Î∂à
        const fx = ((w + 350) - (bgOffset * 0.25)) % (w + 350);
        g.beginFill(0xFF6F00, 0.15 + Math.sin(t * 6) * 0.1); g.drawCircle(fx, groundY - 20, 40); g.endFill();
        g.beginFill(0xFF5722, 0.8);
        g.moveTo(fx, groundY); g.quadraticCurveTo(fx - 12, groundY - 25, fx - 8, groundY - 35 - Math.sin(t * 10) * 5);
        g.quadraticCurveTo(fx, groundY - 30, fx, groundY - 45 - Math.sin(t * 12) * 8);
        g.quadraticCurveTo(fx, groundY - 30, fx + 8, groundY - 35 - Math.sin(t * 11) * 5);
        g.quadraticCurveTo(fx + 12, groundY - 25, fx, groundY); g.endFill();
        g.beginFill(0xFFEB3B, 0.9); g.drawEllipse(fx, groundY - 15, 8, 15); g.endFill();
    } else if (id === 'modern') {
        // Î®º Í±¥Î¨º (ÌùêÎ¶º - Ïã§Î£®Ïó£) - Í∞úÏàò Ï§ÑÏûÑ
        for (let i = 0; i < 5; i++) {
            const bx = ((w + 400) - (bgOffset * 0.1 + i * 250)) % (w + 400);
            const bh = 100 + (i * 47) % 80;
            g.beginFill(0x0a0a1a, 0.3); g.drawRect(bx - 30, groundY - bh - 50, 60, bh + 50); g.endFill();
        }
        
        // Í∞ÄÍπåÏö¥ Í±¥Î¨º (ÏÑ†Î™Ö) - Ï∞ΩÎ¨∏ Îã®ÏàúÌôî
        for (let i = 0; i < 4; i++) {
            const bx = ((w + 250) - (bgOffset * 0.3 + i * 180)) % (w + 250);
            const bh = 70 + (i * 37) % 60, bw = 35 + (i * 17) % 20;
            g.beginFill(0x1a1a2e, 0.85); g.drawRect(bx - bw / 2, groundY - bh, bw, bh); g.endFill();
            // Ï∞ΩÎ¨∏ Îã®ÏàúÌôî - 4Í∞úÎßå
            for (let r = 0; r < 3; r++) {
                const lit = Math.sin(t * 0.5 + i * 3 + r * 2) > 0.2;
                g.beginFill(lit ? 0xFFF59D : 0x0d0d1a, lit ? 0.8 : 0.5);
                g.drawRect(bx - 8, groundY - bh + 8 + r * 20, 16, 12); g.endFill();
            }
        }
        
        // Î≥Ñ
        g.beginFill(0xFFFFFF, 0.5);
        for (let i = 0; i < 6; i++) { g.drawCircle((i * 150 + t * 5) % w, 30 + (i * 60) % (groundY - 100), 1.5); }
        g.endFill();
    }
}

function drawObstacle(g, o, t) {
    const cx = o.x + o.w / 2;
    const cy = o.y + o.h / 2;
    
    // Í∑∏Î¶ºÏûê
    g.beginFill(0x000000, 0.15);
    g.drawEllipse(cx, o.y + o.h + 4, o.w * 0.4, 6);
    g.endFill();
    
    const type = o.type;
    
    // === ÏõêÏãú Ïú°ÏßÄ ===
    if (type === 'rock') {
        // ÌÅ∞ Î∞îÏúÑ
        g.beginFill(0x6B5B4F);
        g.moveTo(o.x + 5, o.y + o.h);
        g.lineTo(o.x + 10, o.y + o.h * 0.3);
        g.lineTo(o.x + o.w * 0.4, o.y);
        g.lineTo(o.x + o.w * 0.7, o.y + o.h * 0.15);
        g.lineTo(o.x + o.w - 5, o.y + o.h * 0.4);
        g.lineTo(o.x + o.w, o.y + o.h);
        g.closePath(); g.endFill();
        // ÌïòÏù¥ÎùºÏù¥Ìä∏
        g.beginFill(0x8B7B6B, 0.6);
        g.moveTo(o.x + 12, o.y + o.h * 0.5);
        g.lineTo(o.x + 15, o.y + o.h * 0.35);
        g.lineTo(o.x + o.w * 0.35, o.y + o.h * 0.25);
        g.lineTo(o.x + o.w * 0.3, o.y + o.h * 0.45);
        g.closePath(); g.endFill();
        // Ïù¥ÎÅº
        g.beginFill(0x4A6741, 0.7);
        g.drawEllipse(o.x + o.w * 0.3, o.y + o.h * 0.7, 8, 5);
        g.drawEllipse(o.x + o.w * 0.6, o.y + o.h * 0.8, 6, 4);
        g.endFill();
    } else if (type === 'bush') {
        // Îç§Î∂à
        g.beginFill(0x2D5A27);
        g.drawEllipse(cx, o.y + o.h * 0.7, o.w * 0.5, o.h * 0.35);
        g.endFill();
        g.beginFill(0x3D7A37);
        g.drawEllipse(cx - 8, o.y + o.h * 0.5, o.w * 0.35, o.h * 0.3);
        g.drawEllipse(cx + 8, o.y + o.h * 0.55, o.w * 0.3, o.h * 0.28);
        g.endFill();
        g.beginFill(0x4D8A47);
        g.drawEllipse(cx, o.y + o.h * 0.4, o.w * 0.25, o.h * 0.2);
        g.endFill();
        // Ïó¥Îß§
        g.beginFill(0xFF6B6B);
        g.drawCircle(cx - 5, o.y + o.h * 0.6, 3);
        g.drawCircle(cx + 8, o.y + o.h * 0.5, 2.5);
        g.endFill();
    } else if (type === 'mushroom') {
        // Î≤ÑÏÑØ Ï§ÑÍ∏∞
        g.beginFill(0xF5DEB3);
        g.drawRect(cx - 6, o.y + o.h * 0.5, 12, o.h * 0.5);
        g.endFill();
        // Î≤ÑÏÑØ Í∞ì
        g.beginFill(0xDC143C);
        g.drawEllipse(cx, o.y + o.h * 0.35, o.w * 0.45, o.h * 0.35);
        g.endFill();
        // Ï†êÎ¨¥Îä¨
        g.beginFill(0xFFFFFF);
        g.drawCircle(cx - 8, o.y + o.h * 0.3, 4);
        g.drawCircle(cx + 6, o.y + o.h * 0.25, 3);
        g.drawCircle(cx, o.y + o.h * 0.4, 3.5);
        g.endFill();
    }
    // === Í≥µÎ£° ÏãúÎåÄ ===
    else if (type === 'dino_skull') {
        // ÎëêÍ∞úÍ≥®
        g.beginFill(0xF5F5DC);
        g.drawEllipse(cx, cy, o.w * 0.4, o.h * 0.35);
        g.endFill();
        // ÌÑ±
        g.beginFill(0xE8E8D0);
        g.moveTo(cx - o.w * 0.3, cy + 5);
        g.lineTo(cx - o.w * 0.35, o.y + o.h - 5);
        g.lineTo(cx + o.w * 0.35, o.y + o.h - 5);
        g.lineTo(cx + o.w * 0.3, cy + 5);
        g.closePath(); g.endFill();
        // ÎààÍµ¨Î©ç
        g.beginFill(0x2A2A2A);
        g.drawEllipse(cx - 10, cy - 5, 8, 10);
        g.drawEllipse(cx + 10, cy - 5, 8, 10);
        g.endFill();
        // Ïù¥Îπ®
        g.beginFill(0xFFFFFF);
        for (let i = 0; i < 5; i++) {
            g.moveTo(cx - 15 + i * 8, o.y + o.h - 8);
            g.lineTo(cx - 12 + i * 8, o.y + o.h);
            g.lineTo(cx - 18 + i * 8, o.y + o.h);
            g.closePath();
        }
        g.endFill();
    } else if (type === 'dino_egg') {
        // Ïïå
        g.beginFill(0xFFFACD);
        g.drawEllipse(cx, cy + 5, o.w * 0.38, o.h * 0.45);
        g.endFill();
        // Î¨¥Îä¨
        g.beginFill(0xE0D5A0, 0.5);
        g.drawEllipse(cx - 5, cy, 6, 8);
        g.drawEllipse(cx + 8, cy + 8, 5, 6);
        g.endFill();
        // ÌïòÏù¥ÎùºÏù¥Ìä∏
        g.beginFill(0xFFFFFF, 0.4);
        g.drawEllipse(cx - 8, cy - 10, 6, 8);
        g.endFill();
        // Í∏à
        g.lineStyle(2, 0x8B7355, 0.6);
        g.moveTo(cx + 5, o.y + 5);
        g.lineTo(cx + 2, o.y + 15);
        g.lineTo(cx + 8, o.y + 20);
        g.lineStyle(0);
    } else if (type === 'fern') {
        // ÏñëÏπò Ï§ÑÍ∏∞
        g.beginFill(0x228B22);
        g.drawRect(cx - 3, o.y + o.h * 0.6, 6, o.h * 0.4);
        g.endFill();
        // Ïûé
        g.beginFill(0x32CD32);
        for (let i = 0; i < 6; i++) {
            const ly = o.y + 10 + i * 8;
            const lw = 15 - i * 2;
            g.drawEllipse(cx - lw, ly, lw, 4);
            g.drawEllipse(cx + lw, ly, lw, 4);
        }
        g.endFill();
    }
    // === ÎπôÌïòÍ∏∞ ===
    else if (type === 'iceberg') {
        // ÎπôÏÇ∞
        g.beginFill(0xE0FFFF);
        g.moveTo(o.x + 5, o.y + o.h);
        g.lineTo(o.x + o.w * 0.3, o.y + 5);
        g.lineTo(o.x + o.w * 0.5, o.y + o.h * 0.2);
        g.lineTo(o.x + o.w * 0.7, o.y);
        g.lineTo(o.x + o.w - 5, o.y + o.h);
        g.closePath(); g.endFill();
        // ÏùåÏòÅ
        g.beginFill(0xADD8E6, 0.5);
        g.moveTo(o.x + o.w * 0.5, o.y + o.h * 0.2);
        g.lineTo(o.x + o.w * 0.7, o.y);
        g.lineTo(o.x + o.w - 5, o.y + o.h);
        g.lineTo(o.x + o.w * 0.5, o.y + o.h);
        g.closePath(); g.endFill();
        // Î∞òÏßùÏûÑ
        g.beginFill(0xFFFFFF, 0.7);
        g.drawCircle(o.x + o.w * 0.35, o.y + o.h * 0.3, 3);
        g.endFill();
    } else if (type === 'snowman') {
        // ÎààÏÇ¨Îûå
        g.beginFill(0xFFFFFF);
        g.drawCircle(cx, o.y + o.h - 12, 12);
        g.drawCircle(cx, o.y + o.h - 30, 10);
        g.drawCircle(cx, o.y + o.h - 45, 8);
        g.endFill();
        // Îàà
        g.beginFill(0x000000);
        g.drawCircle(cx - 3, o.y + o.h - 47, 2);
        g.drawCircle(cx + 3, o.y + o.h - 47, 2);
        g.endFill();
        // ÏΩî
        g.beginFill(0xFF6600);
        g.moveTo(cx, o.y + o.h - 44);
        g.lineTo(cx + 8, o.y + o.h - 42);
        g.lineTo(cx, o.y + o.h - 40);
        g.closePath(); g.endFill();
        // Î≤ÑÌäº
        g.beginFill(0x333333);
        g.drawCircle(cx, o.y + o.h - 28, 2);
        g.drawCircle(cx, o.y + o.h - 22, 2);
        g.endFill();
    } else if (type === 'ice_spike') {
        // ÏñºÏùå Í∏∞Îë•
        g.beginFill(0xB0E0E6, 0.9);
        g.moveTo(cx, o.y);
        g.lineTo(o.x + o.w - 5, o.y + o.h);
        g.lineTo(o.x + 5, o.y + o.h);
        g.closePath(); g.endFill();
        // ÌïòÏù¥ÎùºÏù¥Ìä∏
        g.beginFill(0xFFFFFF, 0.5);
        g.moveTo(cx - 3, o.y + 10);
        g.lineTo(cx + 5, o.y + o.h * 0.7);
        g.lineTo(cx - 5, o.y + o.h * 0.6);
        g.closePath(); g.endFill();
    }
    // === ÏõêÏãúÏù∏ ===
    else if (type === 'campfire') {
        // ÎÇòÎ¨¥
        g.beginFill(0x5D4037);
        g.drawRect(cx - 15, o.y + o.h - 10, 8, 10);
        g.drawRect(cx + 7, o.y + o.h - 10, 8, 10);
        g.drawRect(cx - 4, o.y + o.h - 8, 8, 8);
        g.endFill();
        // Î∂àÍΩÉ
        const flicker = Math.sin(t * 10) * 3;
        g.beginFill(0xFF4500, 0.9);
        g.moveTo(cx, o.y + 10 + flicker);
        g.quadraticCurveTo(cx + 20, o.y + o.h * 0.5, cx + 10, o.y + o.h - 15);
        g.lineTo(cx - 10, o.y + o.h - 15);
        g.quadraticCurveTo(cx - 20, o.y + o.h * 0.5, cx, o.y + 10 + flicker);
        g.endFill();
        g.beginFill(0xFFD700, 0.9);
        g.moveTo(cx, o.y + 20 + flicker);
        g.quadraticCurveTo(cx + 10, o.y + o.h * 0.6, cx + 5, o.y + o.h - 15);
        g.lineTo(cx - 5, o.y + o.h - 15);
        g.quadraticCurveTo(cx - 10, o.y + o.h * 0.6, cx, o.y + 20 + flicker);
        g.endFill();
    } else if (type === 'spear') {
        // Ï∞ΩÎåÄ
        g.beginFill(0x8B4513);
        g.drawRect(cx - 3, o.y + 15, 6, o.h - 15);
        g.endFill();
        // Ï∞ΩÎÅù
        g.beginFill(0x808080);
        g.moveTo(cx, o.y);
        g.lineTo(cx + 8, o.y + 18);
        g.lineTo(cx - 8, o.y + 18);
        g.closePath(); g.endFill();
        // Î¨∂Ïùå
        g.beginFill(0xD2691E);
        g.drawRect(cx - 5, o.y + 15, 10, 6);
        g.endFill();
    } else if (type === 'tent') {
        // Ï≤úÎßâ
        g.beginFill(0xD2B48C);
        g.moveTo(cx, o.y);
        g.lineTo(o.x + o.w, o.y + o.h);
        g.lineTo(o.x, o.y + o.h);
        g.closePath(); g.endFill();
        // ÏûÖÍµ¨
        g.beginFill(0x2A2A2A);
        g.moveTo(cx, o.y + o.h * 0.4);
        g.lineTo(cx + 10, o.y + o.h);
        g.lineTo(cx - 10, o.y + o.h);
        g.closePath(); g.endFill();
        // ÏßÄÏßÄÎåÄ
        g.beginFill(0x5D4037);
        g.drawRect(cx - 2, o.y - 5, 4, o.h + 5);
        g.endFill();
    }
    // === ÌòÑÎåÄ ===
    else if (type === 'car') {
        // Ï∞®Ï≤¥
        g.beginFill(0x4169E1);
        g.drawRoundedRect(o.x, o.y + o.h * 0.35, o.w, o.h * 0.45, 5);
        g.endFill();
        g.beginFill(0x4169E1);
        g.drawRoundedRect(o.x + o.w * 0.15, o.y + o.h * 0.1, o.w * 0.55, o.h * 0.35, 5);
        g.endFill();
        // Ï∞ΩÎ¨∏
        g.beginFill(0x87CEEB, 0.8);
        g.drawRoundedRect(o.x + o.w * 0.2, o.y + o.h * 0.15, o.w * 0.22, o.h * 0.22, 3);
        g.drawRoundedRect(o.x + o.w * 0.45, o.y + o.h * 0.15, o.w * 0.2, o.h * 0.22, 3);
        g.endFill();
        // Î∞îÌÄ¥
        g.beginFill(0x1A1A1A);
        g.drawCircle(o.x + o.w * 0.22, o.y + o.h, 9);
        g.drawCircle(o.x + o.w * 0.78, o.y + o.h, 9);
        g.endFill();
        g.beginFill(0x808080);
        g.drawCircle(o.x + o.w * 0.22, o.y + o.h, 5);
        g.drawCircle(o.x + o.w * 0.78, o.y + o.h, 5);
        g.endFill();
        // Ìó§ÎìúÎùºÏù¥Ìä∏
        g.beginFill(0xFFFF00, 0.8);
        g.drawRect(o.x + o.w - 5, o.y + o.h * 0.45, 5, 8);
        g.endFill();
    } else if (type === 'hydrant') {
        // ÏÜåÌôîÏ†Ñ
        g.beginFill(0xDC143C);
        g.drawRoundedRect(cx - 10, o.y + 10, 20, o.h - 15, 5);
        g.endFill();
        // Î®∏Î¶¨
        g.beginFill(0xDC143C);
        g.drawEllipse(cx, o.y + 10, 12, 8);
        g.endFill();
        // Ï∂úÍµ¨
        g.beginFill(0x8B0000);
        g.drawRect(o.x + 3, o.y + o.h * 0.4, 10, 8);
        g.drawRect(o.x + o.w - 13, o.y + o.h * 0.4, 10, 8);
        g.endFill();
        // Î≥ºÌä∏
        g.beginFill(0xC0C0C0);
        g.drawCircle(cx, o.y + 8, 5);
        g.endFill();
    } else if (type === 'trash') {
        // Ïì∞Î†àÍ∏∞ÌÜµ
        g.beginFill(0x2E8B57);
        g.drawRect(o.x + 5, o.y + 10, o.w - 10, o.h - 10);
        g.endFill();
        // ÎöúÍªë
        g.beginFill(0x228B22);
        g.drawEllipse(cx, o.y + 10, o.w * 0.45, 8);
        g.endFill();
        // ÏÜêÏû°Ïù¥
        g.beginFill(0x1A5A1A);
        g.drawRect(cx - 5, o.y + 3, 10, 8);
        g.endFill();
        // Ï§ÑÎ¨¥Îä¨
        g.beginFill(0x1A5A1A, 0.5);
        g.drawRect(o.x + 8, o.y + 25, o.w - 16, 4);
        g.drawRect(o.x + 8, o.y + 35, o.w - 16, 4);
        g.endFill();
    }
    // Í∏∞Î≥∏
    else {
        g.beginFill(0x888888);
        g.drawRect(o.x, o.y, o.w, o.h);
        g.endFill();
    }
}

function runnerFail() {
    p3GameRunning = false;
    SFX.play('gameover');
    if (gameLoop && pixiApp) pixiApp.ticker.remove(gameLoop);
    GameState.runnerDist = runnerDist;
    GameState.save();
    document.getElementById('p3go-dist').textContent = `${Math.floor(runnerDist)}m`;
    document.getElementById('modal-p3-gameover').classList.add('show');
}

function runnerComplete() {
    p3GameRunning = false;
    SFX.play('clear');
    if (gameLoop && pixiApp) pixiApp.ticker.remove(gameLoop);
    GameState.phase3Clear = true;
    GameState.runnerDist = runnerDist;
    GameState.save();
    
    setTimeout(() => {
        renderCreatureCanvasLevel('final-preview', GameState.creature, evolutionLevel);
    }, 100);
    document.getElementById('modal-p3-clear').classList.add('show');
}

function showEnding() {
    app.innerHTML = `
        <div class="page-center">
            <div class="page-content">
                <div class="page-icon">üéâ</div>
                <h2 class="page-title">Ï∂ïÌïòÌï©ÎãàÎã§!</h2>
                <p class="page-text">Îã®ÏÑ∏Ìè¨ ÏÉùÎ¨ºÏóêÏÑú<br><span class="hl">ÏôÑÏ†ÑÌïú ÏßÑÌôî</span>Î•º Ïù¥Î£®ÏóàÏäµÎãàÎã§!</p>
                <div id="final-creature" style="width: 150px; height: 150px; margin: 20px auto; background: rgba(0,0,0,0.4); border-radius: 16px;"></div>
                <div style="color: #c77dff; font-size: 1rem; margin-bottom: 16px;">üß¨ ÏßÑÌôî ÏôÑÎ£å!</div>
                <button class="btn btn-primary btn-block" id="btn-space" style="background: linear-gradient(135deg, #1a1a3e, #4a1a6e);">üöÄ Ïö∞Ï£ºÏÑºÌÑ∞Î°ú Ï∂úÎ∞ú</button>
                <button class="btn btn-block" id="btn-home" style="margin-top: 10px; background: rgba(255,255,255,0.1);">üè† ÌôàÏúºÎ°ú</button>
            </div>
        </div>
    `;
    setTimeout(() => { if (GameState.creature) renderCreatureCanvasLevel('final-creature', GameState.creature, evolutionLevel); }, 100);
    document.getElementById('btn-space').onclick = () => showSpaceIntro();
    document.getElementById('btn-home').onclick = () => showTitle();
}

// ========================================
// Phase 4: Ïö∞Ï£ºÏÑºÌÑ∞ (Space Center)
// ========================================

// ÎûúÎç§ Ïù¥Î¶Ñ ÏÉùÏÑ±
function generateCreatureName() {
    const prefixes = ['ÌÉêÌóòÍ∞Ä', 'Í∞úÏ≤ôÏûê', 'Ìï≠Ìï¥Ïûê', 'Î™®ÌóòÍ∞Ä', 'Ïó¨ÌñâÏûê', 'ÏÑ†Íµ¨Ïûê', 'Î∞úÍ≤¨Ïûê', 'Ï†ïÎ≥µÏûê'];
    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    const number = Math.floor(Math.random() * 9000) + 1000;
    return `${prefix}-${number}`;
}

// Í≥ÑÍ∏â Ï†ïÎ≥¥
const SPACE_RANKS = [
    { level: 1, name: 'üßπ Ï≤≠ÏÜåÎ∂Ä', luckRequired: 0 },
    { level: 2, name: 'üì¶ ÌôîÎ¨º Îã¥Îãπ', luckRequired: 500 },
    { level: 3, name: 'üîß ÏàòÏäµ Ï†ïÎπÑÍ≥µ', luckRequired: 2000 },
    { level: 4, name: 'üöÄ Í≤¨Ïäµ Ï°∞Ï¢ÖÏÇ¨', luckRequired: 10000 },
    { level: 5, name: '‚≠ê Ï†ïÏãù Ï°∞Ï¢ÖÏÇ¨', luckRequired: 50000 },
    { level: 6, name: 'üåü Ìï≠Ìï¥ÏÇ¨', luckRequired: 200000 },
    { level: 7, name: 'üí´ Î∂ÄÏÑ†Ïû•', luckRequired: 1000000 },
    { level: 8, name: 'üë®‚Äç‚úàÔ∏è ÏÑ†Ïû•', luckRequired: 5000000 },
    { level: 9, name: 'üè¥ Ìï®ÎåÄÏû•', luckRequired: 50000000 },
    { level: 10, name: 'üëë Ï†úÎèÖ', luckRequired: 100000000 }
];

// ÌòÑÏû¨ Í≥ÑÍ∏â Í∞ÄÏ†∏Ïò§Í∏∞
function getCurrentRank(luck) {
    for (let i = SPACE_RANKS.length - 1; i >= 0; i--) {
        if (luck >= SPACE_RANKS[i].luckRequired) {
            return SPACE_RANKS[i];
        }
    }
    return SPACE_RANKS[0];
}

// Îã§Ïùå Í≥ÑÍ∏â Í∞ÄÏ†∏Ïò§Í∏∞
function getNextRank(luck) {
    for (let i = 0; i < SPACE_RANKS.length; i++) {
        if (luck < SPACE_RANKS[i].luckRequired) {
            return SPACE_RANKS[i];
        }
    }
    return null; // ÏµúÍ≥† Í≥ÑÍ∏â
}

// Ïö∞Ï£ºÏÑºÌÑ∞ Ïù∏Ìä∏Î°ú Ïä§ÌÜ†Î¶¨
function showSpaceIntro() {
    initPixi(0x0a0a1a);
    createStarBackground();
    
    const t = GameState.t.bind(GameState);
    const env = getEnvById(GameState.envId);
    const envName = env?.name || 'Ìï¥Ïñë';
    
    // Ïù¥Î¶ÑÏù¥ ÏóÜÏúºÎ©¥ ÏÉùÏÑ± (spaceLuckÏùÄ Î¶¨ÏÖãÌïòÏßÄ ÏïäÏùå)
    if (!GameState.creatureName) {
        GameState.creatureName = generateCreatureName();
        // spaceLuckÏù¥ ÏóÜÏùÑ ÎïåÎßå Ï¥àÍ∏∞Ìôî
        if (GameState.spaceLuck === undefined || GameState.spaceLuck === null) {
            GameState.spaceLuck = 0;
        }
        GameState.spaceRank = GameState.spaceRank || 1;
        GameState.save();
    }
    
    const intro = [
        { icon: 'üåü', title: 'ÏßÑÌôîÏùò ÎÅù, ÏÉàÎ°úÏö¥ ÏãúÏûë', text: 'ÎãπÏã†ÏùÄ Îã®ÏÑ∏Ìè¨ÏóêÏÑú ÏãúÏûëÌï¥\nÎ¨∏Î™ÖÏùÑ Ïù¥Î£®Í≥† Í∏∞Í≥ÑÏôÄ ÏúµÌï©ÌñàÏäµÎãàÎã§.' },
        { icon: env?.icon || 'üåç', title: `${envName}ÏùÑ ÎÑòÏñ¥ÏÑú`, text: `Ïù¥Ï†ú ÎãπÏã†Ïùò Î¨¥ÎåÄÎäî\n${envName}ÏùÑ ÎÑòÏñ¥ÏÑ≠ÎãàÎã§.` },
        { icon: 'üöÄ', title: 'Ïö∞Ï£ºÏÑºÌÑ∞ ÎèÑÏ∞©', text: 'Í¥ëÌôúÌïú Ïö∞Ï£ºÍ∞Ä ÎãπÏã†ÏùÑ Í∏∞Îã§Î¶ΩÎãàÎã§.\nÌïòÏßÄÎßå... ÏïÑÎ¨¥Í≤ÉÎèÑ ÏóÜÏù¥ ÏãúÏûëÌï¥Ïïº Ìï©ÎãàÎã§.' },
        { icon: 'üßπ', title: 'ÌóàÎìúÎ†õÏùºÎ∂ÄÌÑ∞', text: 'Ïö∞Ï£ºÏÑ†ÎèÑ ÏóÜÍ≥†, ÎèàÎèÑ ÏóÜÏäµÎãàÎã§.\nÏ≤≠ÏÜåÎ∂ÄÌÑ∞ ÏãúÏûëÌï¥ Ïö∞Ï£ºÏùò ÏßÄÎ∞∞ÏûêÍ∞Ä ÎêòÏÑ∏Ïöî!' }
    ];
    
    let idx = 0;
    
    function renderSlide() {
        const slide = intro[idx];
        const isLast = idx === intro.length - 1;
        
        app.innerHTML = `
            <div class="page-center">
                <div class="page-content" style="max-width: 380px;">
                    <div style="font-size: 4rem; margin-bottom: 20px; filter: drop-shadow(0 0 20px rgba(255,255,255,0.3));">${slide.icon}</div>
                    <h2 class="page-title" style="font-size: 1.4rem; margin-bottom: 12px;">${slide.title}</h2>
                    <p class="page-text" style="white-space: pre-line; line-height: 1.6; color: #aaa;">${slide.text}</p>
                    <div id="creature-intro" style="width: 100px; height: 100px; margin: 20px auto; background: rgba(0,0,0,0.4); border-radius: 12px;"></div>
                    <div class="progress-dots" style="margin: 20px 0;">
                        ${intro.map((_, i) => `<div class="dot ${i < idx ? 'done' : ''} ${i === idx ? 'active' : ''}"></div>`).join('')}
                    </div>
                    <button class="btn btn-primary btn-block" id="btn-next">${isLast ? 'üöÄ Ïö∞Ï£ºÏÑºÌÑ∞ ÏûÖÏû•' : 'Îã§Ïùå ‚Üí'}</button>
                </div>
            </div>
        `;
        
        setTimeout(() => {
            if (GameState.creature) renderCreatureCanvasLevel('creature-intro', GameState.creature, 5);
        }, 100);
        
        document.getElementById('btn-next').onclick = () => {
            if (isLast) {
                showSpaceLobby();
            } else {
                idx++;
                renderSlide();
            }
        };
    }
    
    renderSlide();
}

// Ïö∞Ï£ºÏÑºÌÑ∞ Î°úÎπÑ (Î©îÏù∏ ÌôîÎ©¥)
function showSpaceLobby() {
    initPixi(0x0a0a1a);
    
    const env = getEnvById(GameState.envId);
    const luck = GameState.spaceLuck || 0;
    const currentRank = getCurrentRank(luck);
    const nextRank = getNextRank(luck);
    const creatureName = GameState.creatureName || generateCreatureName();
    
    // Í≤åÏãúÌåê Í≥µÍ≥† ÎÇ¥Ïö©
    const bulletinPosts = [
        { type: 'Í∏¥Í∏â', icon: 'üö®', title: 'Ï≤≠ÏÜåÎ∂Ä Í∏¥Í∏â Î™®Ïßë', desc: '3Ï∏µ Í∞ùÏã§ Ï≤≠ÏÜå Ïù∏Ïõê ÌïÑÏöî', reward: '15 LUCK' },
        { type: 'ÏùºÎ∞ò', icon: 'üì¶', title: 'ÌôîÎ¨º Ï†ÅÏû¨ Îã¥ÎãπÏûê Î™®Ïßë', desc: 'Î≥¥Í∏âÌíà Ï†ïÎ¶¨ ÏûëÏóÖ', reward: '20 LUCK' },
        { type: 'Ïã†Í∑ú', icon: 'üîå', title: 'Î∞∞ÏÑ† Ï†ïÎπÑ Î≥¥Ï°∞', desc: 'Lv.3 Ïù¥ÏÉÅÎßå ÏßÄÏõê Í∞ÄÎä•', reward: '25 LUCK' },
        { type: 'Í≥µÏßÄ', icon: 'üì¢', title: 'Ïù¥Î≤à Ï£º Ïö∞Ïàò Í∑ºÎ¨¥Ïûê Î∞úÌëú', desc: 'Ïó¥Ïã¨Ìûà ÏùºÌïú ÎãπÏã†ÏóêÍ≤å Î≥¥ÎÑàÏä§!', reward: '' }
    ];
    
    app.innerHTML = `
        <div style="width: 100%; height: 100%; background: linear-gradient(180deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a2a 100%); overflow-y: auto; padding-bottom: 100px;">
            <!-- ÏÉÅÎã® Ìó§Îçî -->
            <div style="background: linear-gradient(180deg, rgba(20,20,50,0.95), rgba(10,10,30,0.9)); padding: 15px; padding-top: calc(15px + var(--safe-top)); border-bottom: 1px solid rgba(100,150,255,0.2);">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="font-size: 1.3rem; font-weight: 900; color: #fff;">üöÄ Ïö∞Ï£ºÏÑºÌÑ∞</div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <div id="luck-container" style="background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.4); border-radius: 20px; padding: 6px 12px; font-size: 0.8rem; display: flex; align-items: center; height: 36px; cursor: pointer;">
                            üí∞ <span id="luck-display">${luck.toLocaleString()}</span> LUCK
                        </div>
                        <button class="hud-btn" id="btn-home-space" style="width: 36px; height: 36px; font-size: 1rem; display: flex; align-items: center; justify-content: center;">üè†</button>
                    </div>
                </div>
            </div>
            
            <!-- LUCK Ï°∞Ï†à ÌåùÏóÖ -->
            <div id="luck-popup" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 1000; display: none; align-items: center; justify-content: center;">
                <div style="background: linear-gradient(135deg, #1a1a3a, #0a0a2a); border-radius: 16px; padding: 20px; max-width: 300px; width: 90%; border: 1px solid rgba(255,215,0,0.3);">
                    <div style="text-align: center; margin-bottom: 15px;">
                        <div style="font-size: 1.2rem; color: #ffd700; font-weight: bold;">üí∞ LUCK Ï°∞Ï†à</div>
                        <div style="font-size: 0.75rem; color: #888; margin-top: 5px;">‚ö†Ô∏è ÎîîÎ≤ÑÍ∑∏Ïö©</div>
                    </div>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <input type="number" id="luck-input" value="${luck}" style="flex: 1; padding: 10px; border-radius: 8px; border: 1px solid rgba(255,215,0,0.3); background: rgba(0,0,0,0.3); color: #fff; font-size: 1rem; text-align: center;">
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 15px;">
                        <button class="luck-btn" data-add="100" style="padding: 8px; border-radius: 8px; border: 1px solid rgba(100,255,100,0.3); background: rgba(100,255,100,0.2); color: #44ff88; font-size: 0.8rem;">+100</button>
                        <button class="luck-btn" data-add="500" style="padding: 8px; border-radius: 8px; border: 1px solid rgba(100,255,100,0.3); background: rgba(100,255,100,0.2); color: #44ff88; font-size: 0.8rem;">+500</button>
                        <button class="luck-btn" data-add="1000" style="padding: 8px; border-radius: 8px; border: 1px solid rgba(100,255,100,0.3); background: rgba(100,255,100,0.2); color: #44ff88; font-size: 0.8rem;">+1000</button>
                        <button class="luck-btn" data-add="-100" style="padding: 8px; border-radius: 8px; border: 1px solid rgba(255,100,100,0.3); background: rgba(255,100,100,0.2); color: #ff6b6b; font-size: 0.8rem;">-100</button>
                        <button class="luck-btn" data-add="-500" style="padding: 8px; border-radius: 8px; border: 1px solid rgba(255,100,100,0.3); background: rgba(255,100,100,0.2); color: #ff6b6b; font-size: 0.8rem;">-500</button>
                        <button class="luck-btn" data-add="10000" style="padding: 8px; border-radius: 8px; border: 1px solid rgba(255,215,0,0.3); background: rgba(255,215,0,0.2); color: #ffd700; font-size: 0.8rem;">+10K</button>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button id="btn-luck-apply" style="flex: 1; padding: 12px; border-radius: 8px; border: none; background: linear-gradient(135deg, #44aa44, #228822); color: #fff; font-weight: bold;">Ï†ÅÏö©</button>
                        <button id="btn-luck-close" style="flex: 1; padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.1); color: #fff;">Îã´Í∏∞</button>
                    </div>
                </div>
            </div>
            
            <div style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                <!-- ÎÇ¥ Ï†ïÎ≥¥ Ïπ¥Îìú -->
                <div style="background: linear-gradient(135deg, rgba(30,30,60,0.9), rgba(20,20,40,0.9)); border-radius: 16px; padding: 15px; border: 1px solid rgba(100,150,255,0.2); box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                    <div style="display: flex; gap: 15px; align-items: center;">
                        <div id="my-creature" style="width: 80px; height: 80px; background: rgba(0,0,0,0.4); border-radius: 12px; border: 2px solid rgba(100,150,255,0.3);"></div>
                        <div style="flex: 1;">
                            <div style="font-size: 1.1rem; font-weight: 700; color: #fff; margin-bottom: 4px;">${creatureName}</div>
                            <div style="font-size: 0.85rem; color: #aaa; margin-bottom: 8px;">${currentRank.name}</div>
                            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                <div style="background: rgba(0,0,0,0.3); border-radius: 8px; padding: 4px 8px; font-size: 0.7rem;">
                                    ${env?.icon || 'üåä'} ${env?.name || 'Ìï¥Ïñë'} Ï∂úÏã†
                                </div>
                                <div style="background: rgba(0,0,0,0.3); border-radius: 8px; padding: 4px 8px; font-size: 0.7rem;">
                                    üß¨ ÏßÑÌôî ÏôÑÎ£å
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- ÌòÑÏû¨ Î™©Ìëú -->
                <div style="background: linear-gradient(135deg, rgba(50,30,80,0.8), rgba(30,20,50,0.8)); border-radius: 12px; padding: 12px 15px; border: 1px solid rgba(150,100,255,0.3);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <div style="font-size: 0.75rem; color: #c77dff;">üéØ ÌòÑÏû¨ Î™©Ìëú</div>
                        <button id="btn-all-goals" style="background: rgba(150,100,255,0.3); border: 1px solid rgba(150,100,255,0.5); border-radius: 12px; padding: 3px 10px; font-size: 0.65rem; color: #c77dff; cursor: pointer;">Ï†ÑÏ≤¥ Î™©Ìëú üìã</button>
                    </div>
                    ${nextRank ? `
                        <div style="font-size: 0.95rem; font-weight: 600; color: #fff; margin-bottom: 8px;">${nextRank.name} ÏäπÍ∏â</div>
                        <div style="background: rgba(0,0,0,0.3); border-radius: 6px; height: 8px; overflow: hidden;">
                            <div style="width: ${Math.min(100, (luck / nextRank.luckRequired) * 100)}%; height: 100%; background: linear-gradient(90deg, #9d4edd, #c77dff);"></div>
                        </div>
                        <div style="font-size: 0.7rem; color: #888; margin-top: 4px;">${luck.toLocaleString()} / ${nextRank.luckRequired.toLocaleString()} LUCK</div>
                    ` : `
                        <div style="font-size: 0.95rem; font-weight: 600; color: #ffd700;">üëë ÏµúÍ≥† Í≥ÑÍ∏â Îã¨ÏÑ±!</div>
                    `}
                </div>
                
                <!-- Ï†ÑÏ≤¥ Î™©Ìëú ÌåùÏóÖ -->
                <div id="goals-popup" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 1000; overflow-y: auto; padding: 20px; padding-top: calc(20px + var(--safe-top));">
                    <div style="max-width: 400px; margin: 0 auto;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h2 style="color: #fff; font-size: 1.3rem; margin: 0;">üìã Ï†ÑÏ≤¥ Î™©Ìëú</h2>
                            <button id="btn-close-goals" style="background: rgba(255,255,255,0.1); border: none; border-radius: 50%; width: 36px; height: 36px; color: #fff; font-size: 1.2rem; cursor: pointer;">‚úï</button>
                        </div>
                        
                        <!-- Í≥ÑÍ∏â ÏäπÍ∏â Î™©Ìëú -->
                        <div style="background: linear-gradient(135deg, rgba(50,30,80,0.9), rgba(30,20,50,0.9)); border-radius: 12px; padding: 15px; margin-bottom: 15px; border: 1px solid rgba(150,100,255,0.3);">
                            <div style="font-size: 0.85rem; color: #c77dff; margin-bottom: 12px; font-weight: 600;">üèÜ Í≥ÑÍ∏â ÏäπÍ∏â</div>
                            ${SPACE_RANKS.map((rank, idx) => {
                                const isAchieved = luck >= rank.luckRequired;
                                const isCurrent = currentRank.level === rank.level;
                                return `
                                    <div style="display: flex; align-items: center; gap: 10px; padding: 8px; margin-bottom: 6px; background: ${isCurrent ? 'rgba(150,100,255,0.2)' : 'rgba(0,0,0,0.2)'}; border-radius: 8px; ${isCurrent ? 'border: 1px solid rgba(150,100,255,0.5);' : ''}">
                                        <div style="font-size: 1.2rem;">${isAchieved ? '‚úÖ' : isCurrent ? 'üîÑ' : '‚¨ú'}</div>
                                        <div style="flex: 1;">
                                            <div style="font-size: 0.85rem; color: ${isAchieved ? '#44ff88' : '#fff'}; font-weight: ${isCurrent ? '700' : '400'};">${rank.name}</div>
                                            <div style="font-size: 0.7rem; color: #888;">${rank.luckRequired.toLocaleString()} LUCK ÌïÑÏöî</div>
                                        </div>
                                        ${isCurrent ? '<div style="font-size: 0.65rem; color: #c77dff; background: rgba(150,100,255,0.3); padding: 2px 8px; border-radius: 10px;">ÌòÑÏû¨</div>' : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        
                        <!-- ÏóÖÏ†Å Î™©Ìëú -->
                        <div style="background: linear-gradient(135deg, rgba(80,60,20,0.9), rgba(50,40,10,0.9)); border-radius: 12px; padding: 15px; margin-bottom: 15px; border: 1px solid rgba(255,200,100,0.3);">
                            <div style="font-size: 0.85rem; color: #ffd700; margin-bottom: 12px; font-weight: 600;">‚≠ê ÏóÖÏ†Å (Ï§ÄÎπÑ Ï§ë)</div>
                            <div style="color: #888; font-size: 0.8rem; text-align: center; padding: 20px;">
                                üöß ÏóÖÏ†Å ÏãúÏä§ÌÖú Ï§ÄÎπÑ Ï§ë...<br>
                                <span style="font-size: 0.7rem;">Í≥ß Îã§ÏñëÌïú ÎèÑÏ†Ñ Í≥ºÏ†úÍ∞Ä Ï∂îÍ∞ÄÎê©ÎãàÎã§!</span>
                            </div>
                        </div>
                        
                        <!-- ÏµúÏ¢Ö Î™©Ìëú -->
                        <div style="background: linear-gradient(135deg, rgba(20,50,80,0.9), rgba(10,30,50,0.9)); border-radius: 12px; padding: 15px; border: 1px solid rgba(100,200,255,0.3);">
                            <div style="font-size: 0.85rem; color: #4fc3f7; margin-bottom: 12px; font-weight: 600;">üöÄ ÏµúÏ¢Ö Î™©Ìëú</div>
                            <div style="text-align: center; padding: 15px;">
                                <div style="font-size: 2rem; margin-bottom: 10px;">üåå</div>
                                <div style="color: #fff; font-size: 1rem; font-weight: 600;">Ïö∞Ï£ºÏùò ÏßÄÎ∞∞Ïûê</div>
                                <div style="color: #888; font-size: 0.75rem; margin-top: 5px;">Î™®Îì† Í≥ÑÍ∏âÏùÑ Îã¨ÏÑ±ÌïòÍ≥†<br>ÏùÄÌïòÍ≥ÑÎ•º Ï†ïÎ≥µÌïòÏÑ∏Ïöî!</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Í≤åÏãúÌåê -->
                <div style="background: linear-gradient(135deg, rgba(20,40,60,0.9), rgba(10,20,30,0.9)); border-radius: 16px; border: 1px solid rgba(100,200,255,0.2); overflow: hidden;">
                    <div style="background: rgba(0,50,100,0.4); padding: 10px 15px; border-bottom: 1px solid rgba(100,200,255,0.2);">
                        <div style="font-size: 0.9rem; font-weight: 700; color: #4fc3f7;">üìã Íµ¨Ïù∏ Í≤åÏãúÌåê</div>
                    </div>
                    <div style="padding: 10px;">
                        ${bulletinPosts.map(post => `
                            <div style="display: flex; align-items: center; gap: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px; margin-bottom: 8px; ${post.type === 'Í∏¥Í∏â' ? 'border-left: 3px solid #ff6b6b;' : post.type === 'Ïã†Í∑ú' ? 'border-left: 3px solid #4fc3f7;' : ''}">
                                <div style="font-size: 1.5rem;">${post.icon}</div>
                                <div style="flex: 1;">
                                    <div style="font-size: 0.85rem; font-weight: 600; color: #fff;">${post.title}</div>
                                    <div style="font-size: 0.7rem; color: #888;">${post.desc}</div>
                                </div>
                                ${post.reward ? `<div style="font-size: 0.75rem; color: #ffd700; font-weight: 600;">${post.reward}</div>` : ''}
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <!-- ÎØ∏ÎãàÍ≤åÏûÑ Î≤ÑÌäºÎì§ -->
                <div style="font-size: 0.85rem; color: #888; margin-top: 5px;">üíº ÌóàÎìúÎ†õÏùº ÏÑ†ÌÉù</div>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                    <button class="space-job-btn" id="btn-cleaning" style="background: linear-gradient(135deg, #2d5a3d, #1a3d2a); border: 1px solid rgba(100,200,100,0.3);">
                        <div style="font-size: 2rem; margin-bottom: 5px;">üßπ</div>
                        <div style="font-size: 0.8rem; font-weight: 600;">Ï≤≠ÏÜå</div>
                        <div style="font-size: 0.65rem; color: #aaa;">30~50 LUCK</div>
                    </button>
                    <button class="space-job-btn ${currentRank.level >= 2 ? '' : 'locked'}" id="btn-cargo" style="background: linear-gradient(135deg, #5a4a2d, #3d3a1a); border: 1px solid rgba(200,180,100,0.3); ${currentRank.level < 2 ? 'opacity: 0.5;' : ''}">
                        <div style="font-size: 2rem; margin-bottom: 5px;">${currentRank.level >= 2 ? 'üì¶' : 'üîí'}</div>
                        <div style="font-size: 0.8rem; font-weight: 600;">ÌôîÎ¨º</div>
                        <div style="font-size: 0.65rem; color: #aaa;">${currentRank.level >= 2 ? '50~100 LUCK' : 'Lv.2 ÌïÑÏöî'}</div>
                    </button>
                    <button class="space-job-btn ${currentRank.level >= 3 ? '' : 'locked'}" id="btn-wiring" style="background: linear-gradient(135deg, #2d3d5a, #1a2a3d); border: 1px solid rgba(100,150,200,0.3); ${currentRank.level < 3 ? 'opacity: 0.5;' : ''}">
                        <div style="font-size: 2rem; margin-bottom: 5px;">${currentRank.level >= 3 ? 'üîå' : 'üîí'}</div>
                        <div style="font-size: 0.8rem; font-weight: 600;">Î∞∞ÏÑ†</div>
                        <div style="font-size: 0.65rem; color: #aaa;">${currentRank.level >= 3 ? '150~300 LUCK' : 'Lv.3 ÌïÑÏöî'}</div>
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // ÌÅ¨Î¶¨Ï≤ò Î†åÎçîÎßÅ
    setTimeout(() => {
        if (GameState.creature) renderCreatureCanvasLevel('my-creature', GameState.creature, 5);
    }, 100);
    
    // Ïù¥Î≤§Ìä∏ Ïó∞Í≤∞
    document.getElementById('btn-home-space').onclick = () => showTitle();
    document.getElementById('btn-cleaning').onclick = () => showJobDice('cleaning');
    document.getElementById('btn-cargo').onclick = () => {
        if (currentRank.level >= 2) {
            showJobDice('cargo');
        } else {
            alert('Lv.2 ÏàòÏäµ Ï†ïÎπÑÍ≥µ Ïù¥ÏÉÅÎßå ÏßÄÏõê Í∞ÄÎä•Ìï©ÎãàÎã§!');
        }
    };
    document.getElementById('btn-wiring').onclick = () => {
        if (currentRank.level >= 3) {
            showJobDice('wiring');
        } else {
            alert('Lv.3 ÏùºÎ∞ò Ï†ïÎπÑÍ≥µ Ïù¥ÏÉÅÎßå ÏßÄÏõê Í∞ÄÎä•Ìï©ÎãàÎã§!');
        }
    };
    
    // Ï†ÑÏ≤¥ Î™©Ìëú ÌåùÏóÖ
    document.getElementById('btn-all-goals').onclick = () => {
        document.getElementById('goals-popup').style.display = 'block';
    };
    document.getElementById('btn-close-goals').onclick = () => {
        document.getElementById('goals-popup').style.display = 'none';
    };
    document.getElementById('goals-popup').onclick = (e) => {
        if (e.target.id === 'goals-popup') {
            document.getElementById('goals-popup').style.display = 'none';
        }
    };
    
    // LUCK Ï°∞Ï†à ÌåùÏóÖ
    document.getElementById('luck-container').onclick = () => {
        document.getElementById('luck-popup').style.display = 'flex';
        document.getElementById('luck-input').value = GameState.spaceLuck;
    };
    document.getElementById('btn-luck-close').onclick = () => {
        document.getElementById('luck-popup').style.display = 'none';
    };
    document.getElementById('btn-luck-apply').onclick = () => {
        const newLuck = parseInt(document.getElementById('luck-input').value) || 0;
        GameState.spaceLuck = Math.max(0, newLuck);
        GameState.save();
        document.getElementById('luck-popup').style.display = 'none';
        showSpaceLobby(); // ÏÉàÎ°úÍ≥†Ïπ®
    };
    document.querySelectorAll('.luck-btn').forEach(btn => {
        btn.onclick = () => {
            const add = parseInt(btn.dataset.add);
            const input = document.getElementById('luck-input');
            input.value = Math.max(0, parseInt(input.value) + add);
        };
    });
    document.getElementById('luck-popup').onclick = (e) => {
        if (e.target.id === 'luck-popup') {
            document.getElementById('luck-popup').style.display = 'none';
        }
    };
}

// ÎØ∏ÎãàÍ≤åÏûÑ ÏãúÏûë Ï†Ñ Ï£ºÏÇ¨ÏúÑ
function showJobDice(jobType) {
    const jobNames = {
        cleaning: { name: 'üßπ Ï≤≠ÏÜå', desc: '1Ï∏µ~30Ï∏µ Ï≤≠ÏÜå ÏôÑÎ£åÌïòÍ∏∞' },
        cargo: { name: 'üì¶ ÌôîÎ¨º Ï†ÅÏû¨', desc: 'ÌôîÎ¨º 100Í∞úÎ•º Î™©Ìëú Ïπ∏Ïóê ÎçòÏßÄÍ∏∞' },
        wiring: { name: 'üîå Î∞∞ÏÑ† Ï†ïÎ¶¨', desc: '10Î†àÎ≤® ÌÅ¥Î¶¨Ïñ¥ÌïòÍ∏∞' }
    };
    const job = jobNames[jobType];
    
    app.innerHTML = `
        <div class="page-center" style="background: linear-gradient(180deg, #0a0a1a, #1a1a3a);">
            <div class="page-content" style="max-width: 350px;">
                <div style="font-size: 0.9rem; color: #888; margin-bottom: 10px;">ÌóàÎìúÎ†õÏùº ÏãúÏûë</div>
                <h2 class="page-title" style="font-size: 1.5rem; margin-bottom: 8px;">${job.name}</h2>
                <p style="font-size: 0.85rem; color: #aaa; margin-bottom: 20px;">${job.desc}</p>
                
                <div style="background: rgba(0,0,0,0.3); border-radius: 16px; padding: 20px; margin-bottom: 20px;">
                    <div style="font-size: 0.8rem; color: #ffd700; margin-bottom: 10px;">üé≤ ÌñâÏö¥Ïùò Ï£ºÏÇ¨ÏúÑ!</div>
                    <div class="dice-box" id="dice-box" style="font-size: 3rem; margin: 15px auto;">üé≤</div>
                    <div id="dice-result" style="min-height: 40px; font-size: 0.9rem; color: #aaa;"></div>
                </div>
                
                <button class="btn btn-primary btn-block" id="btn-roll-dice">üé≤ Ï£ºÏÇ¨ÏúÑ Íµ¥Î¶¨Í∏∞</button>
                <button class="btn btn-block" id="btn-back" style="margin-top: 10px; background: rgba(255,255,255,0.1);">‚Üê ÎèåÏïÑÍ∞ÄÍ∏∞</button>
            </div>
        </div>
    `;
    
    let diceResult = null;
    
    document.getElementById('btn-roll-dice').onclick = () => {
        const btn = document.getElementById('btn-roll-dice');
        const diceBox = document.getElementById('dice-box');
        const resultEl = document.getElementById('dice-result');
        
        if (diceResult !== null) {
            // Ïù¥ÎØ∏ Íµ¥Î†∏ÏúºÎ©¥ Í≤åÏûÑ ÏãúÏûë
            startMiniGame(jobType, diceResult);
            return;
        }
        
        btn.disabled = true;
        diceBox.classList.add('rolling');
        SFX.play('dice');
        
        let count = 0;
        const anim = setInterval(() => {
            diceBox.textContent = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'][Math.floor(Math.random() * 6)];
            count++;
        }, 50);
        
        setTimeout(() => {
            clearInterval(anim);
            diceBox.classList.remove('rolling');
            
            const roll = Math.floor(Math.random() * 6) + 1;
            diceBox.textContent = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'][roll - 1];
            diceResult = roll;
            
            const effects = {
                1: { text: 'üò∞ ÏãúÍ∞Ñ -1Î∂Ñ', color: '#ff6b6b' },
                2: { text: 'üòê Ìö®Í≥º ÏóÜÏùå', color: '#888' },
                3: { text: 'üôÇ ÏãúÍ∞Ñ +30Ï¥à', color: '#4fc3f7' },
                4: { text: 'üòä ÏãúÍ∞Ñ +1Î∂Ñ', color: '#44ff88' },
                5: { text: 'üòÑ Î≥¥ÏÉÅ √ó1.5', color: '#ffd700' },
                6: { text: 'üéâ Î≥¥ÏÉÅ √ó2!', color: '#ff6b6b' }
            };
            
            const effect = effects[roll];
            resultEl.innerHTML = `<span style="color: ${effect.color}; font-weight: 600;">${effect.text}</span>`;
            
            btn.disabled = false;
            btn.textContent = '‚ñ∂Ô∏è Í≤åÏûÑ ÏãúÏûë';
            btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
        }, 1000);
    };
    
    document.getElementById('btn-back').onclick = () => showSpaceLobby();
}

// ÎØ∏ÎãàÍ≤åÏûÑ ÏãúÏûë
function startMiniGame(jobType, diceRoll) {
    // Ï£ºÏÇ¨ÏúÑ Ìö®Í≥º Í≥ÑÏÇ∞
    let timeBonus = 0;
    let rewardMultiplier = 1;
    
    switch(diceRoll) {
        case 1: timeBonus = -60; break;
        case 3: timeBonus = 30; break;
        case 4: timeBonus = 60; break;
        case 5: rewardMultiplier = 1.5; break;
        case 6: rewardMultiplier = 2; break;
    }
    
    // ÎØ∏ÎãàÍ≤åÏûÑ Ï¢ÖÎ•òÏóê Îî∞Îùº Î∂ÑÍ∏∞
    if (jobType === 'cleaning') {
        startCleaningGame(timeBonus, rewardMultiplier);
    } else if (jobType === 'cargo') {
        startCargoGame(timeBonus, rewardMultiplier);
    } else if (jobType === 'wiring') {
        startWiringGame(timeBonus, rewardMultiplier);
    }
}

// ========================================
// ÎØ∏ÎãàÍ≤åÏûÑ 1: Ï≤≠ÏÜå (PixiJS Í∏∞Î∞ò)
// ========================================
let cleaningState = null;
let cleaningApp = null;

// ÏÉâÏÉÅ ÌåîÎ†àÌä∏
const CL_COLORS = {
    wallDark: 0x1a1a2e, wallMid: 0x2d2d44, wallLight: 0x4a4a6a,
    floorDark: 0x252538, floorMid: 0x353548, floorLight: 0x454560,
    lightOn: 0x00ffff, lightGlow: 0x66ffff,
    trashBag: 0x3d5c3d, trashBagDark: 0x2a3d2a,
    can: 0xc0c0c0, canDark: 0x808080,
    poop: 0x8B4513, poopDark: 0x5D3A1A,
    bacteria: 0x00ff00, bacteriaDark: 0x00aa00,
    fastBacteria: 0xff00ff,
    boxMain: 0x8B7355, boxDark: 0x5D4E3A, boxLight: 0xA08060,
    broomHandle: 0x8B4513, broomHead: 0xDEB887, broomBristles: 0xC4A060
};

// Ï≤≠ÏÜå ÎåÄÏÇ¨ Î≥ÄÏàòÎì§
const TRASH_NAMES = ['Ïì∞Î†àÍ∏∞', 'Ìú¥ÏßÄ', 'Ï∫î', 'Îò•', 'Ïò§Î¨º', 'Î®ºÏßÄ', 'ÏÑ∏Í∑†', 'Í≥∞Ìå°Ïù¥'];
const ACTIONS = ['ÏπòÏõåÏïºÍ≤†Îã§', 'Ïã´Ïñ¥!', 'Ïôú ÏûàÏñ¥?', 'Ïñ¥ÎîîÏÑú ÎÇ¨ÏßÄ?', 'ÎòêÏïº?', 'Í∑∏Îßå!'];
const FEELINGS = ['ÎçîÎüΩÎã§', 'ÌûòÎì§Îã§', 'ÏßÄÏπúÎã§', 'ÌîºÍ≥§Ìï¥', 'Í∑ÄÏ∞ÆÏïÑ', 'Ï°∏Î†§'];
const EXCLAMATIONS = ['ÏúΩ!', 'ÏóêÏûá!', 'Ìïò...', 'Ìù†...', 'Ïñ¥?', 'Î≠êÏïº!', 'Ìóâ!'];

// Ï≤≠ÏÜå Ï§ë ÎßêÌíçÏÑ† ÎåÄÏÇ¨Îì§ (Î≥ÄÏàò ÌôúÏö©)
const CLEANING_QUOTES = {
    start: [
        "Îòê Ï≤≠ÏÜåÏïº...", "Ïò§ÎäòÎèÑ ÌûòÎÇ¥Ïûê!", "Íπ®ÎÅóÌïòÍ≤å ÎßåÎì§Ïñ¥ÏïºÏßÄ",
        "ÎàÑÍ∞Ä Ïù¥Î†áÍ≤å Ïñ¥ÏßàÎ†ÄÏñ¥?", "Ï≤≠ÏÜåÎäî Î™ÖÏÉÅÏù¥Ïïº...", "ÎπóÏûêÎ£® Ï§ÄÎπÑ ÏôÑÎ£å!"
    ],
    collect: [
        () => `${EXCLAMATIONS[Math.floor(Math.random()*EXCLAMATIONS.length)]} ${TRASH_NAMES[Math.floor(Math.random()*TRASH_NAMES.length)]}!`,
        () => `${TRASH_NAMES[Math.floor(Math.random()*TRASH_NAMES.length)]} ${ACTIONS[Math.floor(Math.random()*ACTIONS.length)]}`,
        () => `Ïù¥ ${TRASH_NAMES[Math.floor(Math.random()*TRASH_NAMES.length)]} ÎàÑÍ∞Ä Î≤ÑÎ†∏Ïñ¥?`,
        () => `${TRASH_NAMES[Math.floor(Math.random()*TRASH_NAMES.length)]}... ${FEELINGS[Math.floor(Math.random()*FEELINGS.length)]}`,
        "ÌïòÎÇò ÏπòÏõ†Îã§!", "ÍπîÎÅî~", "Î∂ÑÎ¶¨ÏàòÍ±∞ Ìï¥ÏïºÌïòÎÇò?", "Ï†êÏ†ê Íπ®ÎÅóÌï¥ÏßÄÎÑ§"
    ],
    combo: [
        "Ïó∞ÏÜçÏù¥Îã§!", "Ïò§ ÏûòÎêòÎÑ§!", "ÏÜêÏù¥ Îπ®ÎùºÏ°åÏñ¥!", "ÏΩ§Î≥¥!",
        "ÎÇ¥Í∞Ä Ï≤≠ÏÜåÏùò Ïã†?", "Î©àÏ∂ú Ïàò ÏóÜÏñ¥!", "Îã¨Ïù∏Ïùò Í≤ΩÏßÄ...",
        () => `${Math.floor(Math.random()*5)+3}Ïó∞ÏÜç! ÎåÄÎ∞ï!`
    ],
    bacteria: [
        () => `${EXCLAMATIONS[Math.floor(Math.random()*EXCLAMATIONS.length)]} ÏÑ∏Í∑†Ïù¥Îã§!`,
        "ÏõÄÏßÅÏù¥Îäî Í≤å ÏûàÏñ¥!!", "Ï†ÄÍ±¥ Î≠êÏïº?!", "Ïû°ÏïÑÏïº Ìï¥!",
        "Îπ®Î¶¨Îπ®Î¶¨!", "ÎèÑÎßùÍ∞ÄÏßÄ Îßà!", "ÏßïÍ∑∏Îü¨Ïõå!"
    ],
    floorClear: [
        "Ìïú Ï∏µ ÎÅù!", "Îã§Ïùå Ï∏µÏúºÎ°ú!", "Ï†êÏ†ê ÎçîÎü¨ÏõåÏßÄÍ≤†ÏßÄ...",
        "ÏïÑÏßÅ Í∞à Í∏∏Ïù¥ Î©ÄÏñ¥", "Ìú¥~ Ïû†Íπê Ïâ¨Ïûê", "Í±∞Ïùò Îã§ ÏôîÏñ¥!",
        () => `${Math.floor(Math.random()*3)+1}Ï∏µ ÎÇ®ÏïòÎã§!`
    ],
    tired: [
        () => `${FEELINGS[Math.floor(Math.random()*FEELINGS.length)]}...`,
        "Ïñ∏Ï†ú ÎÅùÎÇò?", "ÌóàÎ¶¨ ÏïÑÌåå...", "Îã§Î¶¨Í∞Ä...",
        "Ï≤≠ÏÜå Î°úÎ¥áÏù¥ÎÇò ÏÇ¨ÏïºÌïòÎÇò", "ÏõîÍ∏â Ïò¨Î†§Ï§ò...", "Ïâ¨Í≥† Ïã∂Îã§..."
    ]
};

// NPC ÏßÅÏõê ÎåÄÏÇ¨ (Î≥ÄÏàò ÌôúÏö©)
const NPC_TRASH_WORDS = ['Ïì∞Î†àÍ∏∞', 'Ìú¥ÏßÄ', 'Ï∫î', 'ÏÑ∏Í∑†', 'Î®ºÏßÄ', 'Ïò§Î¨º'];
const NPC_PLACES = ['Ïó¨Í∏∞', 'Ï†ÄÍ∏∞', 'Î≥µÎèÑ', '3Ï∏µ', 'ÌôîÏû•Ïã§', 'Ï∞ΩÍ≥†'];
const NPC_WARNINGS = ['Ï°∞Ïã¨Ìï¥', 'ÎπÑÏºú', 'ÏßÄÎÇòÍ∞àÍ≤å', 'Ïû†ÍπêÎßå', 'Í∏âÌï¥'];
const NPC_COMPLAINTS = ['Î∞îÎπ† Ï£ΩÍ≤†Ïñ¥', 'Ïò§Îäò ÏïºÍ∑ºÏù¥Ïïº', 'Ï†êÏã¨ÎèÑ Î™ª Î®πÏóàÏñ¥', 'Ïª§Ìîº ÎßàÏãúÍ≥† Ïã∂Îã§'];

const NPC_QUOTES = [
    () => `${NPC_PLACES[Math.floor(Math.random()*NPC_PLACES.length)]}Ïóê ${NPC_TRASH_WORDS[Math.floor(Math.random()*NPC_TRASH_WORDS.length)]} Ï¢Ä ÏπòÏõåÏ§ò!`,
    () => `${NPC_WARNINGS[Math.floor(Math.random()*NPC_WARNINGS.length)]}! ÏßÄÎÇòÍ∞ÑÎã§!`,
    () => `${NPC_COMPLAINTS[Math.floor(Math.random()*NPC_COMPLAINTS.length)]}...`,
    () => `${NPC_TRASH_WORDS[Math.floor(Math.random()*NPC_TRASH_WORDS.length)]} Ï†ÄÎ¶¨ ÏπòÏõå!`,
    "Í∏∏ ÎßâÏßÄ Îßà!", "Î≠ò Î¥ê?", "ÏùºÌïòÎäî Ï§ëÏù¥Ïïº!", "Ï≤≠ÏÜåÎ∂ÄÎãò ÌôîÏù¥ÌåÖ!",
    "ÏïÑ ÍπúÏßùÏù¥Ïïº!", "Ïñ¥Îîî Í∞Ä?", "Ïó¥Ïã¨Ìûà ÌïòÎÑ§~", "ÏàòÍ≥†Ìï¥Ïöî!",
    () => `${NPC_PLACES[Math.floor(Math.random()*NPC_PLACES.length)]}ÎèÑ Ï≤≠ÏÜåÌï¥Ïïº Ìï¥!`,
    "Î∞∞Í≥†Ìåå...", "Ìá¥Í∑ºÌïòÍ≥† Ïã∂Îã§", "Ïò§Îäò Î™á Ï∏µÍπåÏßÄÏïº?"
];

function getRandomQuote(category) {
    const quotes = CLEANING_QUOTES[category];
    const selected = quotes[Math.floor(Math.random() * quotes.length)];
    return typeof selected === 'function' ? selected() : selected;
}

function getRandomNPCQuote() {
    const selected = NPC_QUOTES[Math.floor(Math.random() * NPC_QUOTES.length)];
    return typeof selected === 'function' ? selected() : selected;
}

function startCleaningGame(timeBonus, rewardMultiplier) {
    const baseTime = 150; // 2Î∂Ñ 30Ï¥àÎ°ú Ï¶ùÍ∞Ä
    const maxTime = baseTime + timeBonus;
    
    // Í≤åÏûÑ ÏòÅÏó≠ ÌÅ¨Í∏∞ - Îçî ÌÅ¨Í≤å
    const maxW = Math.min(window.innerWidth - 10, 450);
    const maxH = Math.min(window.innerHeight - 180, 500);
    const gameW = maxW;
    const gameH = maxH;
    
    cleaningState = {
        floor: 1,
        maxFloor: 10,
        score: 0,
        time: maxTime,
        rewardMultiplier: rewardMultiplier,
        player: { x: gameW / 2, y: gameH / 2 },
        trash: [],
        walls: [],
        npcs: [],
        combo: 0,
        gameOver: false,
        paused: false,
        frozen: false,  // NPCÏôÄ Ï∂©Îèå Ïãú Ïù¥Îèô Î∂àÍ∞Ä
        frozenTimer: 0,
        gameW: gameW,
        gameH: gameH,
        keys: { up: false, down: false, left: false, right: false },
        joyPos: { x: 0, y: 0 },
        speechBubble: null,
        speechTimer: 0,
        lastQuoteTime: 0,
        npcContainer: null
    };
    
    renderCleaningUI();
    initCleaningPixi();
}

function renderCleaningUI() {
    const s = cleaningState;
    
    app.innerHTML = `
        <div style="width: 100%; height: 100%; background: #0a0a1a; display: flex; flex-direction: column; align-items: center;">
            <!-- HUD -->
            <div style="width: 100%; max-width: 420px; padding: 10px 15px; padding-top: calc(10px + var(--safe-top)); background: linear-gradient(180deg, rgba(0,0,0,0.9), rgba(0,0,0,0.5)); display: flex; justify-content: space-between; align-items: center; z-index: 100;">
                <div style="display: flex; gap: 12px; align-items: center; font-size: 0.85rem;">
                    <div>üè¢ Ï∏µ <span id="cl-floor">${s.floor}</span>/${s.maxFloor}</div>
                    <div>üóëÔ∏è Ïì∞Î†àÍ∏∞ <span id="cl-trash">0</span></div>
                </div>
                <div style="display: flex; gap: 12px; align-items: center; font-size: 0.85rem;">
                    <div id="cl-combo-wrap" style="color: #fff;">üî• ÏΩ§Î≥¥ <span id="cl-combo">0</span></div>
                    <div>‚è±Ô∏è <span id="cl-time">${Math.floor(s.time / 60)}:${(s.time % 60).toString().padStart(2, '0')}</span></div>
                    <div style="color: #44ff88;">‚≠ê <span id="cl-score">0</span>Ï†ê</div>
                </div>
            </div>
            
            <!-- Í≤åÏûÑ Ï∫îÎ≤ÑÏä§ -->
            <div id="cleaning-canvas-wrap" style="flex: 1; display: flex; align-items: center; justify-content: center; position: relative;">
            </div>
            
            <!-- ÌïòÎã® Ïª®Ìä∏Î°§ -->
            <div style="width: 100%; padding: 15px; padding-bottom: calc(15px + var(--safe-bottom)); background: rgba(0,0,0,0.5); display: flex; justify-content: space-between; align-items: center;">
                <div class="joystick" id="cl-joystick" style="position: relative; width: 100px; height: 100px;">
                    <div class="joy-base"></div>
                    <div class="joy-knob" id="cl-joy-knob"></div>
                </div>
                <div style="text-align: center; color: #666; font-size: 0.7rem;">
                    PC: WASD / Î∞©Ìñ•ÌÇ§
                </div>
                <button id="btn-quit-cleaning" style="background: rgba(255,0,0,0.3); border: 1px solid rgba(255,0,0,0.5); border-radius: 8px; padding: 10px 15px; color: #fff; font-size: 0.8rem;">‚úï Ìè¨Í∏∞</button>
            </div>
            
            <!-- Ï∏µ Ï†ÑÌôò Ïò§Î≤ÑÎ†àÏù¥ -->
            <div id="cl-floor-overlay" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 200;">
                <div style="font-size: 3rem; margin-bottom: 10px;">üè¢</div>
                <div id="cl-floor-text" style="font-size: 1.5rem; color: #4fc3f7; margin-bottom: 5px;">2Ï∏µÏúºÎ°ú Ïù¥Îèô</div>
                <div id="cl-floor-desc" style="font-size: 0.85rem; color: #888;">ÎÇúÏù¥ÎèÑ Ï¶ùÍ∞Ä!</div>
            </div>
        </div>
    `;
    
    setupCleaningControls();
}

function initCleaningPixi() {
    const s = cleaningState;
    const wrap = document.getElementById('cleaning-canvas-wrap');
    
    cleaningApp = new PIXI.Application({
        width: s.gameW,
        height: s.gameH,
        backgroundColor: CL_COLORS.wallDark,
        resolution: window.devicePixelRatio || 1,
        autoDensity: true
    });
    
    wrap.appendChild(cleaningApp.view);
    cleaningApp.view.style.borderRadius = '8px';
    cleaningApp.view.style.border = '2px solid #333';
    
    // Ïª®ÌÖåÏù¥ÎÑàÎì§
    s.bgContainer = new PIXI.Container();
    s.wallContainer = new PIXI.Container();
    s.trashContainer = new PIXI.Container();
    s.npcContainer = new PIXI.Container();
    s.playerContainer = new PIXI.Container();
    s.particleContainer = new PIXI.Container();
    
    cleaningApp.stage.addChild(s.bgContainer);
    cleaningApp.stage.addChild(s.wallContainer);
    cleaningApp.stage.addChild(s.trashContainer);
    cleaningApp.stage.addChild(s.npcContainer);
    cleaningApp.stage.addChild(s.playerContainer);
    cleaningApp.stage.addChild(s.particleContainer);
    
    // Î∞∞Í≤Ω Í∑∏Î¶¨Í∏∞
    drawCleaningBackground();
    
    // Ï≤´ Ï∏µ ÏÉùÏÑ±
    generateFloor(s.floor);
    
    // ÌîåÎ†àÏù¥Ïñ¥ ÏÉùÏÑ±
    createCleaningPlayer();
    
    // Í≤åÏûÑ Î£®ÌîÑ
    cleaningApp.ticker.add(cleaningGameLoop);
    
    // ÌÉÄÏù¥Î®∏
    s.timerInterval = setInterval(() => {
        if (s.paused || s.gameOver) return;
        s.time--;
        updateCleaningHUD();
        if (s.time <= 0) endCleaningGame(false);
    }, 1000);
}

function drawCleaningBackground() {
    const s = cleaningState;
    const g = new PIXI.Graphics();
    
    // Î∞îÎã• ÌÉÄÏùº
    const tileSize = 20;
    for (let x = 0; x < s.gameW; x += tileSize) {
        for (let y = 0; y < s.gameH; y += tileSize) {
            const isEven = ((x + y) / tileSize) % 2 === 0;
            g.beginFill(isEven ? CL_COLORS.floorMid : CL_COLORS.floorDark);
            g.drawRect(x, y, tileSize, tileSize);
            g.endFill();
        }
    }
    
    // Ï≤úÏû• Ï°∞Î™Ö Ìö®Í≥º
    for (let i = 0; i < 4; i++) {
        g.beginFill(CL_COLORS.lightGlow, 0.08);
        g.drawEllipse(50 + i * 100, 30, 40, 25);
        g.endFill();
    }
    
    s.bgContainer.addChild(g);
}

// ÎØ∏Î°úÌòï Ï∏µ ÎûúÎç§ ÏÉùÏÑ± - Îçî Î≥µÏû°Ìïú Ìå®ÌÑ¥
function generateFloor(floorNum) {
    const s = cleaningState;
    
    // Í∏∞Ï°¥ Ïò§Î∏åÏ†ùÌä∏ Ï†úÍ±∞
    s.wallContainer.removeChildren();
    s.trashContainer.removeChildren();
    s.walls = [];
    s.trash = [];
    
    const g = new PIXI.Graphics();
    
    // Ïô∏Î≤Ω
    const wallThick = 12;
    const margin = 8;
    
    // ÏÉÅÎã® Î≤Ω
    drawWall(g, margin, margin, s.gameW - margin * 2, wallThick);
    s.walls.push({ x: margin, y: margin, w: s.gameW - margin * 2, h: wallThick });
    
    // ÌïòÎã® Î≤Ω
    drawWall(g, margin, s.gameH - margin - wallThick, s.gameW - margin * 2, wallThick);
    s.walls.push({ x: margin, y: s.gameH - margin - wallThick, w: s.gameW - margin * 2, h: wallThick });
    
    // Ï¢åÏ∏° Î≤Ω
    drawWall(g, margin, margin, wallThick, s.gameH - margin * 2);
    s.walls.push({ x: margin, y: margin, w: wallThick, h: s.gameH - margin * 2 });
    
    // Ïö∞Ï∏° Î≤Ω
    drawWall(g, s.gameW - margin - wallThick, margin, wallThick, s.gameH - margin * 2);
    s.walls.push({ x: s.gameW - margin - wallThick, y: margin, w: wallThick, h: s.gameH - margin * 2 });
    
    const playArea = {
        x: margin + wallThick + 10,
        y: margin + wallThick + 10,
        w: s.gameW - (margin + wallThick + 10) * 2,
        h: s.gameH - (margin + wallThick + 10) * 2
    };
    
    const px = s.gameW / 2, py = s.gameH / 2;
    const safeZone = 40; // ÌîåÎ†àÏù¥Ïñ¥ Ï£ºÎ≥Ä ÏïàÏ†Ñ ÏòÅÏó≠
    const minGap = 35; // ÏµúÏÜå ÌÜµÍ≥º Í∞ÑÍ≤©
    
    // Î≤Ω Í∞úÏàò (Ï∏µÏù¥ Ïò¨ÎùºÍ∞àÏàòÎ°ù Ï¶ùÍ∞Ä, ÏµúÎåÄ Ï†úÌïú)
    const maxWalls = Math.min(4 + floorNum, 12);
    
    // Î≤Ω ÏÉùÏÑ± ÏãúÎèÑ (Í≤ÄÏ¶ù Ìè¨Ìï®)
    let wallsCreated = 0;
    let attempts = 0;
    const maxAttempts = maxWalls * 5;
    
    while (wallsCreated < maxWalls && attempts < maxAttempts) {
        attempts++;
        
        // ÎûúÎç§ Î≤Ω ÏÉùÏÑ±
        const isH = Math.random() > 0.5;
        let wx, wy, ww, wh;
        
        if (isH) {
            // ÏàòÌèâ Î≤Ω - Î∞òÎìúÏãú ÏñëÏ™ΩÏóê ÌÜµÎ°ú ÎÇ®ÍπÄ
            ww = 30 + Math.random() * Math.min(60, playArea.w * 0.4);
            wh = 10;
            wx = playArea.x + minGap + Math.random() * (playArea.w - ww - minGap * 2);
            wy = playArea.y + minGap + Math.random() * (playArea.h - wh - minGap * 2);
        } else {
            // ÏàòÏßÅ Î≤Ω - Î∞òÎìúÏãú ÏúÑÏïÑÎûòÏóê ÌÜµÎ°ú ÎÇ®ÍπÄ
            ww = 10;
            wh = 30 + Math.random() * Math.min(60, playArea.h * 0.4);
            wx = playArea.x + minGap + Math.random() * (playArea.w - ww - minGap * 2);
            wy = playArea.y + minGap + Math.random() * (playArea.h - wh - minGap * 2);
        }
        
        // ÌîåÎ†àÏù¥Ïñ¥ ÏãúÏûë ÏúÑÏπò Ï≤¥ÌÅ¨
        if (Math.abs(wx + ww/2 - px) < safeZone && Math.abs(wy + wh/2 - py) < safeZone) {
            continue;
        }
        
        // Îã§Î•∏ Î≤ΩÍ≥º ÎÑàÎ¨¥ Í∞ÄÍπùÏßÄ ÏïäÏùÄÏßÄ Ï≤¥ÌÅ¨ (ÌÜµÎ°ú ÌôïÎ≥¥)
        let tooClose = false;
        for (const existingWall of s.walls.slice(4)) { // Ïô∏Î≤Ω Ï†úÏô∏
            // Í∞ôÏùÄ Î∞©Ìñ• Î≤ΩÎÅºÎ¶¨Îäî Í∞ÑÍ≤© Ï≤¥ÌÅ¨
            const existingIsH = existingWall.w > existingWall.h;
            
            if (isH === existingIsH) {
                // Í∞ôÏùÄ Î∞©Ìñ•Ïù¥Î©¥ ÌèâÌñâ Í∞ÑÍ≤© Ï≤¥ÌÅ¨
                if (isH) {
                    // ÏàòÌèâ Î≤ΩÎÅºÎ¶¨
                    if (Math.abs(wy - existingWall.y) < minGap &&
                        wx < existingWall.x + existingWall.w + minGap &&
                        wx + ww > existingWall.x - minGap) {
                        tooClose = true;
                        break;
                    }
                } else {
                    // ÏàòÏßÅ Î≤ΩÎÅºÎ¶¨
                    if (Math.abs(wx - existingWall.x) < minGap &&
                        wy < existingWall.y + existingWall.h + minGap &&
                        wy + wh > existingWall.y - minGap) {
                        tooClose = true;
                        break;
                    }
                }
            } else {
                // Îã§Î•∏ Î∞©Ìñ•Ïù¥Î©¥ ÍµêÏ∞® ÏßÄÏ†ê Í∑ºÏ≤ò Ï≤¥ÌÅ¨
                const intersection = !(wx + ww < existingWall.x - 5 ||
                                       wx > existingWall.x + existingWall.w + 5 ||
                                       wy + wh < existingWall.y - 5 ||
                                       wy > existingWall.y + existingWall.h + 5);
                if (intersection) {
                    // ÍµêÏ∞®ÌïòÎ©¥ LÏûêÎÇò TÏûê ÌòïÌÉúÍ∞Ä ÎêòÏñ¥ ÎßâÌûê Ïàò ÏûàÏùå
                    // ÌÜµÎ°úÍ∞Ä ÌôïÎ≥¥ÎêòÎäîÏßÄ Ï∂îÍ∞Ä Í≤ÄÏ¶ù
                    const gapLeft = wx - playArea.x;
                    const gapRight = playArea.x + playArea.w - (wx + ww);
                    const gapTop = wy - playArea.y;
                    const gapBottom = playArea.y + playArea.h - (wy + wh);
                    
                    if (Math.min(gapLeft, gapRight) < minGap && Math.min(gapTop, gapBottom) < minGap) {
                        tooClose = true;
                        break;
                    }
                }
            }
        }
        
        if (tooClose) continue;
        
        // Î≤Ω Ï∂îÍ∞Ä
        drawWall(g, wx, wy, ww, wh);
        s.walls.push({ x: wx, y: wy, w: ww, h: wh });
        wallsCreated++;
    }
    
    s.wallContainer.addChild(g);
    
    // Ïì∞Î†àÍ∏∞ ÏÉùÏÑ± (ÎÇúÏù¥ÎèÑ ÏÉÅÌñ•)
    const trashCount = 5 + Math.floor(floorNum * 1.2);
    const bacteriaCount = floorNum >= 2 ? Math.floor(floorNum / 2) : 0;
    const fastBacteriaCount = floorNum >= 5 ? Math.floor((floorNum - 3) / 2) : 0;
    const bacteriaSpeed = 0.4 + floorNum * 0.12;
    
    for (let i = 0; i < trashCount; i++) {
        let type;
        if (i < fastBacteriaCount) {
            type = { name: 'fastBacteria', points: 30, speed: bacteriaSpeed * 2 };
        } else if (i < fastBacteriaCount + 2 && floorNum >= 3) {
            type = { name: 'bacteria', points: 20, speed: bacteriaSpeed };
        } else {
            const types = [
                { name: 'bag', points: 10, speed: 0 },
                { name: 'can', points: 5, speed: 0 },
                { name: 'poop', points: 15, speed: 0 }
            ];
            type = types[Math.floor(Math.random() * types.length)];
        }
        
        // Î≤ΩÍ≥º Í≤πÏπòÏßÄ ÏïäÎäî ÏúÑÏπò Ï∞æÍ∏∞
        let tx, ty, valid = false, attempts = 0;
        while (!valid && attempts < 50) {
            tx = playArea.x + Math.random() * playArea.w;
            ty = playArea.y + Math.random() * playArea.h;
            valid = !isInWallCL(tx, ty, 25);
            attempts++;
        }
        
        if (valid) {
            const trash = createTrashSprite(type, tx, ty);
            s.trash.push(trash);
            s.trashContainer.addChild(trash);
        }
    }
    
    // NPC ÏÉùÏÑ± (Ï∏µÎ≥Ñ 1~3Î™Ö)
    s.npcContainer.removeChildren();
    s.npcs = [];
    const npcCount = Math.min(1 + Math.floor(floorNum / 4), 3);
    
    for (let i = 0; i < npcCount; i++) {
        let nx, ny, valid = false, attempts = 0;
        while (!valid && attempts < 50) {
            nx = playArea.x + 30 + Math.random() * (playArea.w - 60);
            ny = playArea.y + 30 + Math.random() * (playArea.h - 60);
            // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Í±∞Î¶¨ Ï≤¥ÌÅ¨, Î≤Ω Ï≤¥ÌÅ¨
            const distToPlayer = Math.sqrt((nx - px) * (nx - px) + (ny - py) * (ny - py));
            valid = !isInWallCL(nx, ny, 25) && distToPlayer > 80;
            attempts++;
        }
        
        if (valid) {
            const npc = createNPCSprite(nx, ny, i);
            s.npcs.push(npc);
            s.npcContainer.addChild(npc);
        }
    }
    
    // ÌîåÎ†àÏù¥Ïñ¥ ÏãúÏûë ÏúÑÏπò Í≤ÄÏ¶ù - Î≤ΩÏóê ÎÅºÏóàÏúºÎ©¥ Ïù¥Îèô
    if (isInWallCL(s.player.x, s.player.y, 15)) {
        // ÏïàÏ†ÑÌïú ÏúÑÏπò Ï∞æÍ∏∞
        let found = false;
        for (let r = 30; r < 150 && !found; r += 20) {
            for (let a = 0; a < Math.PI * 2; a += Math.PI / 4) {
                const testX = px + Math.cos(a) * r;
                const testY = py + Math.sin(a) * r;
                if (!isInWallCL(testX, testY, 15) && 
                    testX > playArea.x && testX < playArea.x + playArea.w &&
                    testY > playArea.y && testY < playArea.y + playArea.h) {
                    s.player.x = testX;
                    s.player.y = testY;
                    found = true;
                    break;
                }
            }
        }
    }
    
    updateCleaningHUD();
    
    // ÏãúÏûë ÎßêÌíçÏÑ† (Í∞ïÏ†ú ÌëúÏãú)
    showSpeechBubble(getRandomQuote('start'), true);
}

// NPC Ïä§ÌîÑÎùºÏù¥Ìä∏ ÏÉùÏÑ±
function createNPCSprite(x, y, index) {
    const container = new PIXI.Container();
    container.x = x;
    container.y = y;
    container.npcBubble = null;
    
    const g = new PIXI.Graphics();
    
    // Ïö∞Ï£ºÎ≥µ ÏÉâÏÉÅ (Ïù∏Îç±Ïä§Î≥ÑÎ°ú Îã§Î•¥Í≤å)
    const suitColors = [0x4169E1, 0xFF6347, 0x32CD32]; // ÌååÎûë, Îπ®Í∞ï, Ï¥àÎ°ù
    const suitColor = suitColors[index % suitColors.length];
    
    // Ïö∞Ï£º Î∂ÄÏ∏†
    g.beginFill(0x555555);
    g.drawRoundedRect(-10, 18, 8, 10, 2);
    g.drawRoundedRect(2, 18, 8, 10, 2);
    g.endFill();
    
    // Î∂ÄÏ∏† Î∞úÎ™© ÎßÅ
    g.beginFill(0x888888);
    g.drawRect(-10, 16, 8, 3);
    g.drawRect(2, 16, 8, 3);
    g.endFill();
    
    // Ïö∞Ï£ºÎ≥µ Îã§Î¶¨
    g.beginFill(0xEEEEEE);
    g.drawRect(-9, 8, 7, 10);
    g.drawRect(2, 8, 7, 10);
    g.endFill();
    
    // Ïö∞Ï£ºÎ≥µ Î™∏ÌÜµ
    g.beginFill(0xEEEEEE);
    g.drawRoundedRect(-14, -12, 28, 24, 6);
    g.endFill();
    
    // Ïö∞Ï£ºÎ≥µ ÏÉâÏÉÅ Ìå®ÎÑê
    g.beginFill(suitColor);
    g.drawRoundedRect(-12, -10, 24, 10, 3);
    g.endFill();
    
    // ÏÉùÎ™ÖÏú†ÏßÄÏû•Ïπò (Îì±Ïóê)
    g.beginFill(0x666666);
    g.drawRoundedRect(-8, -8, 16, 12, 3);
    g.endFill();
    g.beginFill(0x44FF44, 0.8);
    g.drawCircle(-3, -2, 3);
    g.endFill();
    g.beginFill(0xFF4444, 0.8);
    g.drawCircle(3, -2, 3);
    g.endFill();
    
    // Ìó¨Î©ß (Íµ¨Ìòï)
    g.beginFill(0xFFFFFF);
    g.drawCircle(0, -22, 14);
    g.endFill();
    
    // Ìó¨Î©ß Î∞îÏù¥Ï†Ä (Ïú†Î¶¨)
    g.beginFill(0x88CCFF, 0.7);
    g.drawEllipse(0, -20, 10, 8);
    g.endFill();
    
    // Î∞îÏù¥Ï†Ä Î∞òÏÇ¨Í¥ë
    g.beginFill(0xFFFFFF, 0.4);
    g.drawEllipse(-4, -23, 3, 2);
    g.endFill();
    
    // Ìó¨Î©ß ÌÖåÎëêÎ¶¨
    g.lineStyle(2, suitColor);
    g.drawCircle(0, -22, 14);
    g.lineStyle(0);
    
    // Ìó¨Î©ß Ïïà ÏñºÍµ¥ (ÏÇ¥Ïßù Î≥¥Ïù¥Í≤å)
    g.beginFill(0xFFDBB4, 0.6);
    g.drawCircle(0, -20, 6);
    g.endFill();
    
    // Îàà
    g.beginFill(0x000000);
    g.drawCircle(-2, -21, 1.5);
    g.drawCircle(2, -21, 1.5);
    g.endFill();
    
    // Ìåî
    g.beginFill(0xEEEEEE);
    g.drawRoundedRect(-18, -8, 6, 14, 3);
    g.drawRoundedRect(12, -8, 6, 14, 3);
    g.endFill();
    
    // Ïû•Í∞ë
    g.beginFill(suitColor);
    g.drawCircle(-15, 8, 5);
    g.drawCircle(15, 8, 5);
    g.endFill();
    
    container.addChild(g);
    return container;
}

// ÎûúÎç§ Î≤Ω ÏÉùÏÑ± Ìó¨Ìçº
function createRandomWall(g, s, playArea, px, py, safeZone) {
    const isH = Math.random() > 0.5;
    let wx, wy, ww, wh;
    
    if (isH) {
        ww = 35 + Math.random() * 70;
        wh = 10;
        wx = playArea.x + Math.random() * (playArea.w - ww);
        wy = playArea.y + Math.random() * (playArea.h - wh);
    } else {
        ww = 10;
        wh = 35 + Math.random() * 70;
        wx = playArea.x + Math.random() * (playArea.w - ww);
        wy = playArea.y + Math.random() * (playArea.h - wh);
    }
    
    if (Math.abs(wx + ww/2 - px) > safeZone || Math.abs(wy + wh/2 - py) > safeZone) {
        drawWall(g, wx, wy, ww, wh);
        s.walls.push({ x: wx, y: wy, w: ww, h: wh });
    }
}

// ÎßêÌíçÏÑ† ÌëúÏãú - Í∏∞Ï°¥ ÎßêÌíçÏÑ†Ïù¥ ÏûàÏúºÎ©¥ ÏÉàÎ°ú ÏÉùÏÑ±ÌïòÏßÄ ÏïäÏùå
function showSpeechBubble(text, force = false) {
    const s = cleaningState;
    if (!s || !s.particleContainer) return;
    
    // Í∏∞Ï°¥ ÎßêÌíçÏÑ†Ïù¥ ÏûàÏúºÎ©¥ ÏÉàÎ°ú ÏÉùÏÑ±ÌïòÏßÄ ÏïäÏùå (forceÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞)
    if (s.speechBubble && !force) {
        return;
    }
    
    // Í∏∞Ï°¥ ÎßêÌíçÏÑ† Ï†úÍ±∞ (forceÏù∏ Í≤ΩÏö∞)
    if (s.speechBubble && force) {
        s.particleContainer.removeChild(s.speechBubble);
        s.speechBubble = null;
    }
    
    const bubble = new PIXI.Container();
    
    // ÎßêÌíçÏÑ† Î∞∞Í≤Ω
    const bg = new PIXI.Graphics();
    const padding = 8;
    const textObj = new PIXI.Text(text, {
        fontFamily: 'Arial', fontSize: 11, fill: 0x333333, fontWeight: 'bold'
    });
    const bw = textObj.width + padding * 2;
    const bh = textObj.height + padding * 2;
    
    bg.beginFill(0xffffff, 0.95);
    bg.lineStyle(2, 0x333333);
    bg.drawRoundedRect(0, 0, bw, bh, 8);
    bg.endFill();
    
    // ÎßêÌíçÏÑ† Íº¨Î¶¨
    bg.beginFill(0xffffff, 0.95);
    bg.lineStyle(2, 0x333333);
    bg.moveTo(bw / 2 - 5, bh);
    bg.lineTo(bw / 2, bh + 8);
    bg.lineTo(bw / 2 + 5, bh);
    bg.endFill();
    
    textObj.x = padding;
    textObj.y = padding;
    
    bubble.addChild(bg);
    bubble.addChild(textObj);
    bubble.alpha = 1;
    
    s.speechBubble = bubble;
    s.speechTimer = 180; // 3Ï¥à
    s.particleContainer.addChild(bubble);
}

function drawWall(g, x, y, w, h) {
    // Î≤Ω Î≥∏Ï≤¥
    g.beginFill(CL_COLORS.wallMid);
    g.drawRect(x, y, w, h);
    g.endFill();
    
    // Î≤Ω ÌïòÏù¥ÎùºÏù¥Ìä∏
    g.beginFill(CL_COLORS.wallLight, 0.5);
    g.drawRect(x, y, w, 3);
    g.drawRect(x, y, 3, h);
    g.endFill();
    
    // Î≤Ω Í∑∏Î¶ºÏûê
    g.beginFill(CL_COLORS.wallDark, 0.5);
    g.drawRect(x, y + h - 3, w, 3);
    g.drawRect(x + w - 3, y, 3, h);
    g.endFill();
}

function isInWallCL(x, y, margin = 15) {
    for (const w of cleaningState.walls) {
        if (x > w.x - margin && x < w.x + w.w + margin &&
            y > w.y - margin && y < w.y + w.h + margin) {
            return true;
        }
    }
    return false;
}

function createTrashSprite(type, x, y) {
    const container = new PIXI.Container();
    container.x = x;
    container.y = y;
    container.trashType = type;
    container.angle = Math.random() * Math.PI * 2;
    
    const g = new PIXI.Graphics();
    
    if (type.name === 'bag') {
        g.beginFill(CL_COLORS.trashBagDark);
        g.moveTo(-10, -8); g.lineTo(-8, 10); g.lineTo(8, 10); g.lineTo(10, -8);
        g.closePath(); g.endFill();
        g.beginFill(CL_COLORS.trashBag);
        g.moveTo(-8, -10); g.lineTo(-6, 8); g.lineTo(6, 8); g.lineTo(8, -10);
        g.closePath(); g.endFill();
        g.beginFill(CL_COLORS.trashBagDark);
        g.drawEllipse(0, -11, 5, 3); g.endFill();
    } else if (type.name === 'can') {
        g.beginFill(CL_COLORS.canDark);
        g.drawRect(-6, -9, 12, 18); g.endFill();
        g.beginFill(CL_COLORS.can);
        g.drawRect(-5, -8, 10, 16); g.endFill();
        g.beginFill(0xff6b6b);
        g.drawRect(-4, -3, 8, 6); g.endFill();
        g.beginFill(0xffffff, 0.3);
        g.drawRect(-4, -7, 2, 12); g.endFill();
    } else if (type.name === 'poop') {
        g.beginFill(CL_COLORS.poopDark);
        g.drawEllipse(0, 6, 9, 4); g.endFill();
        g.beginFill(CL_COLORS.poop);
        g.drawEllipse(0, 4, 8, 3);
        g.drawEllipse(0, 0, 6, 3);
        g.drawEllipse(0, -4, 4, 2); g.endFill();
    } else if (type.name === 'bacteria') {
        g.beginFill(CL_COLORS.bacteriaDark);
        g.drawCircle(0, 0, 11); g.endFill();
        g.beginFill(CL_COLORS.bacteria);
        g.drawCircle(0, 0, 9); g.endFill();
        g.beginFill(0x008800);
        g.drawCircle(0, 0, 3); g.endFill();
        g.lineStyle(2, CL_COLORS.bacteria);
        for (let i = 0; i < 6; i++) {
            const a = (i / 6) * Math.PI * 2;
            g.moveTo(Math.cos(a) * 9, Math.sin(a) * 9);
            g.lineTo(Math.cos(a) * 15, Math.sin(a) * 15);
        }
        g.lineStyle(0);
        g.beginFill(0xffffff);
        g.drawCircle(-3, -2, 2); g.drawCircle(3, -2, 2); g.endFill();
        g.beginFill(0x000000);
        g.drawCircle(-3, -2, 1); g.drawCircle(3, -2, 1); g.endFill();
    } else if (type.name === 'fastBacteria') {
        g.beginFill(0x880088);
        g.drawCircle(0, 0, 11); g.endFill();
        g.beginFill(CL_COLORS.fastBacteria);
        g.drawCircle(0, 0, 9); g.endFill();
        g.beginFill(0xaa00aa);
        g.drawCircle(0, 0, 3); g.endFill();
        g.lineStyle(2, CL_COLORS.fastBacteria);
        for (let i = 0; i < 8; i++) {
            const a = (i / 8) * Math.PI * 2;
            g.moveTo(Math.cos(a) * 9, Math.sin(a) * 9);
            g.lineTo(Math.cos(a) * 16, Math.sin(a) * 16);
        }
        g.lineStyle(0);
        g.beginFill(0xffffff);
        g.drawCircle(-3, -2, 2); g.drawCircle(3, -2, 2); g.endFill();
        g.beginFill(0xff0000);
        g.drawCircle(-3, -2, 1); g.drawCircle(3, -2, 1); g.endFill();
    }
    
    container.addChild(g);
    return container;
}

function createCleaningPlayer() {
    const s = cleaningState;
    const player = new PIXI.Container();
    player.x = s.player.x;
    player.y = s.player.y;
    
    const g = new PIXI.Graphics();
    
    // Ïã§Ï†ú ÌÅ¨Î¶¨Ï≤ò Í∑∏Î¶¨Í∏∞ (Î†àÎ≤® 5Î°ú ÏßÑÌôîÎêú ÏÉÅÌÉú)
    if (GameState.creature) {
        const evolved = evolveCreatureByLevel(GameState.creature, 5);
        drawCreature(g, evolved, 0, 0, 25, Date.now() * 0.001);
    } else {
        // Í∏∞Î≥∏ ÌÅ¨Î¶¨Ï≤ò
        g.beginFill(0x4fc3f7);
        g.drawEllipse(0, 0, 14, 11);
        g.endFill();
        g.beginFill(0xffffff);
        g.drawCircle(-5, -4, 4);
        g.drawCircle(5, -4, 4);
        g.endFill();
        g.beginFill(0x000000);
        g.drawCircle(-5, -4, 2);
        g.drawCircle(5, -4, 2);
        g.endFill();
    }
    
    // ÎπóÏûêÎ£® ÏÜêÏû°Ïù¥
    g.beginFill(CL_COLORS.broomHandle);
    g.drawRect(20, -15, 3, 35);
    g.endFill();
    
    // ÎπóÏûêÎ£® Î®∏Î¶¨
    g.beginFill(CL_COLORS.broomHead);
    g.drawRect(14, 18, 14, 5);
    g.endFill();
    
    // ÎπóÏÇ¥
    g.beginFill(CL_COLORS.broomBristles);
    for (let i = 0; i < 5; i++) {
        g.drawRect(15 + i * 2.5, 23, 2, 8);
    }
    g.endFill();
    
    player.addChild(g);
    s.playerSprite = player;
    s.playerContainer.addChild(player);
}

function setupCleaningControls() {
    const s = cleaningState;
    
    // ÌÇ§Î≥¥Îìú
    const keyHandler = (e, pressed) => {
        switch(e.key.toLowerCase()) {
            case 'w': case 'arrowup': s.keys.up = pressed; break;
            case 's': case 'arrowdown': s.keys.down = pressed; break;
            case 'a': case 'arrowleft': s.keys.left = pressed; break;
            case 'd': case 'arrowright': s.keys.right = pressed; break;
        }
    };
    s.keydownHandler = (e) => keyHandler(e, true);
    s.keyupHandler = (e) => keyHandler(e, false);
    window.addEventListener('keydown', s.keydownHandler);
    window.addEventListener('keyup', s.keyupHandler);
    
    // Ï°∞Ïù¥Ïä§Ìã±
    const joystick = document.getElementById('cl-joystick');
    const knob = document.getElementById('cl-joy-knob');
    
    if (!joystick || !knob) return;
    
    let joyActive = false;
    let joyCenterX = 0, joyCenterY = 0;
    
    const handleStart = (e) => {
        e.preventDefault();
        e.stopPropagation();
        joyActive = true;
        const rect = joystick.getBoundingClientRect();
        joyCenterX = rect.left + rect.width / 2;
        joyCenterY = rect.top + rect.height / 2;
        handleMove(e);
    };
    
    const handleMove = (e) => {
        if (!joyActive) return;
        e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        let dx = touch.clientX - joyCenterX;
        let dy = touch.clientY - joyCenterY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const max = 35;
        if (dist > max) { dx = (dx / dist) * max; dy = (dy / dist) * max; }
        s.joyPos.x = dx / max;
        s.joyPos.y = dy / max;
        knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    };
    
    const handleEnd = (e) => {
        joyActive = false;
        s.joyPos.x = 0;
        s.joyPos.y = 0;
        knob.style.transform = 'translate(-50%, -50%)';
    };
    
    // Ï°∞Ïù¥Ïä§Ìã± Ïù¥Î≤§Ìä∏
    joystick.addEventListener('mousedown', handleStart);
    joystick.addEventListener('touchstart', handleStart, { passive: false });
    joystick.addEventListener('mousemove', handleMove);
    joystick.addEventListener('touchmove', handleMove, { passive: false });
    joystick.addEventListener('mouseup', handleEnd);
    joystick.addEventListener('touchend', handleEnd);
    joystick.addEventListener('mouseleave', handleEnd);
    joystick.addEventListener('touchcancel', handleEnd);
    
    // Ï†ÑÏó≠ ÎßàÏö∞Ïä§ÏóÖÎèÑ Ï≤òÎ¶¨
    s.globalMouseUp = handleEnd;
    document.addEventListener('mouseup', s.globalMouseUp);
    document.addEventListener('touchend', s.globalMouseUp);
    
    // ÎÇòÍ∞ÄÍ∏∞ Î≤ÑÌäº (Î∂ÄÎ∂Ñ Î≥¥ÏÉÅ)
    const quitBtn = document.getElementById('btn-quit-cleaning');
    if (quitBtn) {
        quitBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (confirm('Ìè¨Í∏∞ÌïòÏãúÍ≤†ÏäµÎãàÍπå?\nÌòÑÏû¨ÍπåÏßÄ Î≤à Ï†êÏàòÏùò 50%Î•º Î∞õÏäµÎãàÎã§.')) {
                endCleaningGame(false, true);
            }
        };
    }
}

function cleaningGameLoop(delta) {
    const s = cleaningState;
    if (s.paused || s.gameOver) return;
    
    // frozen ÌÉÄÏù¥Î®∏ Í∞êÏÜå
    if (s.frozenTimer > 0) {
        s.frozenTimer--;
        if (s.frozenTimer <= 0) {
            s.frozen = false;
        }
    }
    
    // frozen ÏÉÅÌÉúÎ©¥ Ïù¥Îèô Î∂àÍ∞Ä (NPC ÎßêÌíçÏÑ† ÏóÖÎç∞Ïù¥Ìä∏Îßå)
    if (s.frozen) {
        // NPC ÎßêÌíçÏÑ† ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
        s.npcs.forEach(npc => {
            if (npc.npcBubble) {
                npc.npcBubble.x = npc.x - npc.npcBubble.width / 2;
                npc.npcBubble.y = npc.y - 55;
            }
        });
        
        // ÎßêÌíçÏÑ† ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
        if (s.speechBubble) {
            s.speechBubble.x = s.player.x - s.speechBubble.width / 2;
            s.speechBubble.y = s.player.y - 55;
            s.speechTimer--;
            if (s.speechTimer <= 20) s.speechBubble.alpha = s.speechTimer / 20;
            if (s.speechTimer <= 0) {
                s.particleContainer.removeChild(s.speechBubble);
                s.speechBubble = null;
            }
        }
        return;
    }
    
    // ÏûÖÎ†• Ï≤òÎ¶¨
    let kx = 0, ky = 0;
    if (s.keys.left) kx = -1;
    if (s.keys.right) kx = 1;
    if (s.keys.up) ky = -1;
    if (s.keys.down) ky = 1;
    
    const inputX = Math.abs(s.joyPos.x) > Math.abs(kx) ? s.joyPos.x : kx;
    const inputY = Math.abs(s.joyPos.y) > Math.abs(ky) ? s.joyPos.y : ky;
    
    // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô
    const speed = 3.5;
    let newX = s.player.x + inputX * speed;
    let newY = s.player.y + inputY * speed;
    
    // Î≤Ω Ï∂©Îèå
    if (!isInWallCL(newX, s.player.y, 12)) s.player.x = newX;
    if (!isInWallCL(s.player.x, newY, 12)) s.player.y = newY;
    
    // Í≤ΩÍ≥Ñ
    s.player.x = Math.max(35, Math.min(s.gameW - 35, s.player.x));
    s.player.y = Math.max(35, Math.min(s.gameH - 35, s.player.y));
    
    s.playerSprite.x = s.player.x;
    s.playerSprite.y = s.player.y;
    
    // ÎßêÌíçÏÑ† ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
    if (s.speechBubble) {
        s.speechBubble.x = s.player.x - s.speechBubble.width / 2;
        s.speechBubble.y = s.player.y - 55;
        
        s.speechTimer--;
        if (s.speechTimer <= 20) {
            s.speechBubble.alpha = s.speechTimer / 20;
        }
        if (s.speechTimer <= 0) {
            s.particleContainer.removeChild(s.speechBubble);
            s.speechBubble = null;
        }
    }
    
    // Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú ÌîºÎ°ú ÎåÄÏÇ¨ (30Ï¥àÎßàÎã§)
    const now = Date.now();
    if (now - s.lastQuoteTime > 25000 && !s.speechBubble && s.time < s.time * 0.7) {
        s.lastQuoteTime = now;
        if (Math.random() < 0.3) {
            showSpeechBubble(getRandomQuote('tired'));
        }
    }
    
    // Ïì∞Î†àÍ∏∞ Ïù¥Îèô (ÏÑ∏Í∑†)
    s.trash.forEach(t => {
        if (t.trashType.speed > 0) {
            if (Math.random() < 0.03) t.angle += (Math.random() - 0.5) * 1.5;
            
            let nx = t.x + Math.cos(t.angle) * t.trashType.speed;
            let ny = t.y + Math.sin(t.angle) * t.trashType.speed;
            
            if (isInWallCL(nx, ny, 12)) {
                t.angle += Math.PI * 0.5 + Math.random() * Math.PI;
            } else {
                t.x = nx;
                t.y = ny;
            }
            
            t.rotation += 0.02;
        }
    });
    
    // Ïì∞Î†àÍ∏∞ ÏàòÏßë
    const px = s.player.x + 10; // ÎπóÏûêÎ£® ÏúÑÏπò Î≥¥Ï†ï
    const py = s.player.y + 15;
    
    for (let i = s.trash.length - 1; i >= 0; i--) {
        const t = s.trash[i];
        const dx = px - t.x;
        const dy = py - t.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 28) {
            s.combo++;
            const mult = s.combo >= 5 ? 2 : s.combo >= 3 ? 1.5 : 1;
            s.score += Math.floor(t.trashType.points * mult);
            
            // ÌååÌã∞ÌÅ¥
            createCleaningParticle(t.x, t.y, t.trashType.points);
            
            // ÏàòÏßë Ïãú ÎßêÌíçÏÑ† (ÎûúÎç§ ÌôïÎ•†)
            if (Math.random() < 0.25 && !s.speechBubble) {
                const isBacteria = t.trashType.name.includes('acteria');
                if (isBacteria) {
                    showSpeechBubble(getRandomQuote('bacteria'));
                } else if (s.combo >= 3) {
                    showSpeechBubble(getRandomQuote('combo'));
                } else {
                    showSpeechBubble(getRandomQuote('collect'));
                }
            }
            
            s.trashContainer.removeChild(t);
            s.trash.splice(i, 1);
            
            SFX.play('eat');
            updateCleaningHUD();
            
            // Ï∏µ ÌÅ¥Î¶¨Ïñ¥
            if (s.trash.length === 0) {
                nextCleaningFloor();
            }
        }
    }
    
    // NPC Ï∂©Îèå Ï≤¥ÌÅ¨
    for (const npc of s.npcs) {
        const dx = s.player.x - npc.x;
        const dy = s.player.y - npc.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 35 && !s.frozen && !npc.npcBubble) {
            // NPCÏôÄ Ï∂©Îèå! frozen ÏÉÅÌÉúÎ°ú
            s.frozen = true;
            s.frozenTimer = 120; // 2Ï¥àÍ∞Ñ Î©àÏ∂§
            
            // NPC ÎßêÌíçÏÑ† ÏÉùÏÑ±
            const npcText = getRandomNPCQuote();
            npc.npcBubble = createNPCBubble(npcText);
            npc.npcBubble.x = npc.x - npc.npcBubble.width / 2;
            npc.npcBubble.y = npc.y - 55;
            s.particleContainer.addChild(npc.npcBubble);
            
            // 2Ï¥à ÌõÑ NPC ÎßêÌíçÏÑ† Ï†úÍ±∞
            setTimeout(() => {
                if (npc.npcBubble && s.particleContainer) {
                    s.particleContainer.removeChild(npc.npcBubble);
                    npc.npcBubble = null;
                }
            }, 2000);
            
            // ÌîåÎ†àÏù¥Ïñ¥ ÏïàÏ†ÑÌïòÍ≤å Î∞ÄÏñ¥ÎÇ¥Í∏∞ (Î≤Ω Ï≤¥ÌÅ¨)
            if (dist > 0) {
                const pushDist = 20;
                const pushX = (dx / dist) * pushDist;
                const pushY = (dy / dist) * pushDist;
                
                // Ïó¨Îü¨ Î∞©Ìñ• ÏãúÎèÑÌï¥ÏÑú ÏïàÏ†ÑÌïú Í≥≥ÏúºÎ°ú Î∞ÄÏñ¥ÎÇ¥Í∏∞
                const directions = [
                    { x: pushX, y: pushY },           // ÏõêÎûò Î∞©Ìñ•
                    { x: pushX, y: 0 },               // XÎßå
                    { x: 0, y: pushY },               // YÎßå
                    { x: -pushX, y: pushY },          // Î∞òÎåÄ X
                    { x: pushX, y: -pushY },          // Î∞òÎåÄ Y
                    { x: -pushX, y: 0 },              // Î∞òÎåÄ XÎßå
                    { x: 0, y: -pushY },              // Î∞òÎåÄ YÎßå
                    { x: -pushX, y: -pushY }          // ÏôÑÏ†Ñ Î∞òÎåÄ
                ];
                
                for (const dir of directions) {
                    const newX = s.player.x + dir.x;
                    const newY = s.player.y + dir.y;
                    if (!isInWallCL(newX, newY, 15) && 
                        newX > 40 && newX < s.gameW - 40 &&
                        newY > 40 && newY < s.gameH - 40) {
                        s.player.x = newX;
                        s.player.y = newY;
                        break;
                    }
                }
            }
            
            // ÌîåÎ†àÏù¥Ïñ¥ Ïä§ÌîÑÎùºÏù¥Ìä∏ ÏúÑÏπò Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏
            s.playerSprite.x = s.player.x;
            s.playerSprite.y = s.player.y;
            
            break;
        }
    }
    
    // ÌååÌã∞ÌÅ¥ ÏóÖÎç∞Ïù¥Ìä∏ (ÎßêÌíçÏÑ† Ï†úÏô∏)
    for (let i = s.particleContainer.children.length - 1; i >= 0; i--) {
        const p = s.particleContainer.children[i];
        if (p === s.speechBubble) continue;
        
        // NPC ÎßêÌíçÏÑ†ÎèÑ Ïä§ÌÇµ
        if (s.npcs.some(npc => npc.npcBubble === p)) continue;
        
        if (p.isText) {
            // Ï†êÏàò ÌÖçÏä§Ìä∏ - ÌåùÏóÖ Ìö®Í≥º
            p.y += p.vy || -2.5;
            p.x += p.vx || 0;
            if (p.scale.x < p.targetScale) {
                p.scale.x += 0.1;
                p.scale.y += 0.1;
            } else {
                p.alpha -= 0.025;
            }
            if (p.alpha <= 0) s.particleContainer.removeChild(p);
        } else if (p.isSpark) {
            // Î∞òÏßùÏù¥ ÌååÌã∞ÌÅ¥
            p.x += p.vx || 0;
            p.y += p.vy || 0;
            p.vy += 0.15; // Ï§ëÎ†•
            p.rotation += p.rotSpeed || 0;
            p.alpha -= 0.035;
            p.scale.x *= 0.97;
            p.scale.y *= 0.97;
            if (p.alpha <= 0) s.particleContainer.removeChild(p);
        } else if (p.isShockwave) {
            // Ï∂©Í≤©Ìåå
            p.scale.x += p.expandSpeed * 0.08;
            p.scale.y += p.expandSpeed * 0.08;
            p.alpha -= 0.06;
            if (p.alpha <= 0) s.particleContainer.removeChild(p);
        } else if (p.isFlash) {
            // ÌôîÎ©¥ ÌîåÎûòÏãú
            p.alpha -= 0.1;
            if (p.alpha <= 0) s.particleContainer.removeChild(p);
        } else if (p.isClearText) {
            // CLEAR ÌÖçÏä§Ìä∏
            p.life--;
            p.scale.x = 1 + Math.sin(p.life * 0.2) * 0.1;
            p.scale.y = p.scale.x;
            if (p.life <= 20) p.alpha -= 0.05;
            if (p.alpha <= 0 || p.life <= 0) s.particleContainer.removeChild(p);
        } else {
            // Í∏∞Î≥∏ ÌååÌã∞ÌÅ¥
            p.y += p.vy || -1.5;
            p.alpha -= 0.03;
            if (p.alpha <= 0) s.particleContainer.removeChild(p);
        }
    }
}

function createCleaningParticle(x, y, points) {
    const s = cleaningState;
    
    // Ï†êÏàò ÌÖçÏä§Ìä∏ ÌååÌã∞ÌÅ¥
    const text = new PIXI.Text(`+${points}`, {
        fontFamily: 'Arial', fontSize: points >= 20 ? 18 : 14, 
        fill: points >= 20 ? 0xffff00 : 0x44ff88,
        fontWeight: 'bold', stroke: 0x000000, strokeThickness: 3
    });
    text.x = x; text.y = y;
    text.anchor.set(0.5);
    text.vy = -2.5;
    text.vx = (Math.random() - 0.5) * 2;
    text.isText = true;
    text.scale.set(0.5);
    text.targetScale = 1.2;
    s.particleContainer.addChild(text);
    
    // Î∞òÏßùÏù¥ ÌååÌã∞ÌÅ¥Îì§ (ÏΩ§Î≥¥Ïóê Îî∞Îùº Í∞úÏàò Ï¶ùÍ∞Ä)
    const sparkCount = Math.min(3 + s.combo, 10);
    const colors = [0x44ff88, 0xffff00, 0xff88ff, 0x88ffff, 0xffffff];
    
    for (let i = 0; i < sparkCount; i++) {
        const spark = new PIXI.Graphics();
        const color = colors[Math.floor(Math.random() * colors.length)];
        const size = 2 + Math.random() * 4;
        
        spark.beginFill(color);
        if (Math.random() > 0.5) {
            // Î≥Ñ Î™®Ïñë
            drawStar(spark, 0, 0, 5, size, size / 2);
        } else {
            // ÏõêÌòï
            spark.drawCircle(0, 0, size);
        }
        spark.endFill();
        
        spark.x = x + (Math.random() - 0.5) * 30;
        spark.y = y + (Math.random() - 0.5) * 30;
        spark.vx = (Math.random() - 0.5) * 6;
        spark.vy = -2 - Math.random() * 4;
        spark.rotation = Math.random() * Math.PI * 2;
        spark.rotSpeed = (Math.random() - 0.5) * 0.3;
        spark.isSpark = true;
        s.particleContainer.addChild(spark);
    }
    
    // ÏΩ§Î≥¥ 3 Ïù¥ÏÉÅÏù¥Î©¥ ÏõêÌòï Ï∂©Í≤©Ìåå
    if (s.combo >= 3) {
        const shockwave = new PIXI.Graphics();
        shockwave.lineStyle(3, s.combo >= 5 ? 0xffd700 : 0x44ff88, 0.8);
        shockwave.drawCircle(0, 0, 10);
        shockwave.x = x;
        shockwave.y = y;
        shockwave.isShockwave = true;
        shockwave.expandSpeed = s.combo >= 5 ? 4 : 3;
        s.particleContainer.addChild(shockwave);
    }
    
    // ÏΩ§Î≥¥ 5 Ïù¥ÏÉÅÏù¥Î©¥ ÌôîÎ©¥ ÌîåÎûòÏãú
    if (s.combo >= 5 && cleaningApp) {
        const flash = new PIXI.Graphics();
        flash.beginFill(0xffffff, 0.3);
        flash.drawRect(0, 0, s.gameW, s.gameH);
        flash.endFill();
        flash.isFlash = true;
        s.particleContainer.addChild(flash);
    }
}

// Î≥Ñ Î™®Ïñë Í∑∏Î¶¨Í∏∞ Ìó¨Ìçº
function drawStar(g, cx, cy, spikes, outerR, innerR) {
    let rot = Math.PI / 2 * 3;
    const step = Math.PI / spikes;
    g.moveTo(cx, cy - outerR);
    for (let i = 0; i < spikes; i++) {
        g.lineTo(cx + Math.cos(rot) * outerR, cy + Math.sin(rot) * outerR);
        rot += step;
        g.lineTo(cx + Math.cos(rot) * innerR, cy + Math.sin(rot) * innerR);
        rot += step;
    }
    g.lineTo(cx, cy - outerR);
}

// Ï∏µ ÌÅ¥Î¶¨Ïñ¥ Ïù¥ÌéôÌä∏
function createFloorClearEffect() {
    const s = cleaningState;
    if (!s || !s.particleContainer) return;
    
    // ÎåÄÎüâÏùò ÌååÌã∞ÌÅ¥ Ìè≠Î∞ú
    for (let i = 0; i < 30; i++) {
        const spark = new PIXI.Graphics();
        const colors = [0x44ff88, 0xffff00, 0xff88ff, 0x88ffff, 0xffd700];
        spark.beginFill(colors[Math.floor(Math.random() * colors.length)]);
        drawStar(spark, 0, 0, 5, 4 + Math.random() * 4, 2);
        spark.endFill();
        
        spark.x = s.gameW / 2;
        spark.y = s.gameH / 2;
        const angle = (i / 30) * Math.PI * 2;
        const speed = 3 + Math.random() * 5;
        spark.vx = Math.cos(angle) * speed;
        spark.vy = Math.sin(angle) * speed;
        spark.rotSpeed = (Math.random() - 0.5) * 0.5;
        spark.isSpark = true;
        s.particleContainer.addChild(spark);
    }
    
    // "CLEAR!" ÌÖçÏä§Ìä∏
    const clearText = new PIXI.Text('CLEAR!', {
        fontFamily: 'Arial', fontSize: 32, fill: 0xffd700,
        fontWeight: 'bold', stroke: 0x000000, strokeThickness: 4
    });
    clearText.anchor.set(0.5);
    clearText.x = s.gameW / 2;
    clearText.y = s.gameH / 2;
    clearText.isClearText = true;
    clearText.life = 60;
    s.particleContainer.addChild(clearText);
}

// NPC ÎßêÌíçÏÑ† ÏÉùÏÑ±
function createNPCBubble(text) {
    const bubble = new PIXI.Container();
    
    const bg = new PIXI.Graphics();
    const padding = 6;
    const textObj = new PIXI.Text(text, {
        fontFamily: 'Arial', fontSize: 10, fill: 0x333333, fontWeight: 'bold'
    });
    const bw = textObj.width + padding * 2;
    const bh = textObj.height + padding * 2;
    
    // ÎßêÌíçÏÑ† Î∞∞Í≤Ω (Ïó∞Ìïú ÎÖ∏ÎûÄÏÉâ)
    bg.beginFill(0xFFF8DC, 0.95);
    bg.lineStyle(2, 0x666666);
    bg.drawRoundedRect(0, 0, bw, bh, 6);
    bg.endFill();
    
    // ÎßêÌíçÏÑ† Íº¨Î¶¨
    bg.beginFill(0xFFF8DC, 0.95);
    bg.lineStyle(2, 0x666666);
    bg.moveTo(bw / 2 - 4, bh);
    bg.lineTo(bw / 2, bh + 6);
    bg.lineTo(bw / 2 + 4, bh);
    bg.endFill();
    
    textObj.x = padding;
    textObj.y = padding;
    
    bubble.addChild(bg);
    bubble.addChild(textObj);
    
    return bubble;
}

function nextCleaningFloor() {
    const s = cleaningState;
    s.floor++;
    s.combo = 0;
    
    // Ï∏µ ÌÅ¥Î¶¨Ïñ¥ Ïù¥ÌéôÌä∏!
    createFloorClearEffect();
    
    // Ï∏µ ÌÅ¥Î¶¨Ïñ¥ ÎßêÌíçÏÑ†
    showSpeechBubble(getRandomQuote('floorClear'));
    
    if (s.floor > s.maxFloor) {
        endCleaningGame(true);
        return;
    }
    
    // Ïò§Î≤ÑÎ†àÏù¥ ÌëúÏãú
    const overlay = document.getElementById('cl-floor-overlay');
    document.getElementById('cl-floor-text').textContent = `${s.floor}Ï∏µÏúºÎ°ú Ïù¥Îèô`;
    const trashNum = 5 + Math.floor(s.floor * 1.2);
    document.getElementById('cl-floor-desc').textContent = `Ïì∞Î†àÍ∏∞ ${trashNum}Í∞ú | ÎÇúÏù¥ÎèÑ ${s.floor <= 3 ? 'Ïâ¨ÏõÄ' : s.floor <= 6 ? 'Î≥¥ÌÜµ' : s.floor <= 8 ? 'Ïñ¥Î†§ÏõÄ' : 'Í∑πÌïú'}`;
    overlay.style.display = 'flex';
    
    setTimeout(() => {
        overlay.style.display = 'none';
        s.player.x = s.gameW / 2;
        s.player.y = s.gameH / 2;
        s.playerSprite.x = s.player.x;
        s.playerSprite.y = s.player.y;
        generateFloor(s.floor);
    }, 1200);
}

function updateCleaningHUD() {
    const s = cleaningState;
    const floorEl = document.getElementById('cl-floor');
    const trashEl = document.getElementById('cl-trash');
    const comboEl = document.getElementById('cl-combo');
    const comboWrap = document.getElementById('cl-combo-wrap');
    const timeEl = document.getElementById('cl-time');
    const scoreEl = document.getElementById('cl-score');
    
    if (floorEl) floorEl.textContent = s.floor;
    if (trashEl) trashEl.textContent = s.trash.length;
    if (comboEl) comboEl.textContent = s.combo;
    if (comboWrap) comboWrap.style.color = s.combo >= 3 ? '#ffd700' : '#fff';
    if (scoreEl) scoreEl.textContent = s.score;
    
    if (timeEl) {
        const min = Math.floor(s.time / 60);
        const sec = s.time % 60;
        timeEl.textContent = `${min}:${sec.toString().padStart(2, '0')}`;
        timeEl.style.color = s.time < 30 ? '#ff6b6b' : '#fff';
    }
}

function endCleaningGame(success, partialReward = false) {
    const s = cleaningState;
    s.gameOver = true;
    
    clearInterval(s.timerInterval);
    window.removeEventListener('keydown', s.keydownHandler);
    window.removeEventListener('keyup', s.keyupHandler);
    
    // Ï†ÑÏó≠ ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏ Ï†ïÎ¶¨
    if (s.globalMouseUp) {
        document.removeEventListener('mouseup', s.globalMouseUp);
        document.removeEventListener('touchend', s.globalMouseUp);
    }
    
    if (cleaningApp) {
        cleaningApp.destroy(true, { children: true });
        cleaningApp = null;
    }
    
    if (success) {
        const timeLeft = s.time;
        let baseReward = 30;
        let timeRating = '';
        
        if (timeLeft >= 80) { baseReward = 50; timeRating = '‚≠ê‚≠ê‚≠ê'; }
        else if (timeLeft >= 50) { baseReward = 40; timeRating = '‚≠ê‚≠ê'; }
        else if (timeLeft >= 20) { baseReward = 35; timeRating = '‚≠ê'; }
        else { baseReward = 30; timeRating = '-'; }
        
        const envBonus = getEnvBonus('cleaning');
        const partsBonus = getPartsBonus('cleaning');
        const totalReward = Math.floor((baseReward + envBonus + partsBonus) * s.rewardMultiplier);
        
        GameState.spaceLuck = (GameState.spaceLuck || 0) + totalReward;
        GameState.save();
        
        showMiniGameResult(true, {
            baseReward, envBonus, partsBonus,
            rewardMultiplier: s.rewardMultiplier,
            totalReward, timeRating,
            floor: s.floor,
            score: s.score
        });
    } else if (partialReward && s.score > 0) {
        // Ìè¨Í∏∞ Ïãú Î∂ÄÎ∂Ñ Î≥¥ÏÉÅ (Ï†êÏàòÏùò 50%Î•º LUCKÏúºÎ°ú)
        const partialLuck = Math.floor(s.score * 0.5 * 0.1); // Ï†êÏàò * 50% * 0.1
        if (partialLuck > 0) {
            GameState.spaceLuck = (GameState.spaceLuck || 0) + partialLuck;
            GameState.save();
        }
        showMiniGameResult(false, { 
            floor: s.floor, 
            score: s.score, 
            partialReward: partialLuck 
        });
    } else {
        showMiniGameResult(false, { floor: s.floor, score: s.score });
    }
}


// ========================================

// ========================================
// ÎØ∏ÎãàÍ≤åÏûÑ 2: ÌôîÎ¨º ÎçòÏßÄÍ∏∞ (ÌÉÄÏù¥Î∞ç Í≤åÏûÑ)
// ========================================
let cargoState = null;
let cargoApp = null;

// ÌôîÎ¨º Í≤åÏûÑ ÎåÄÏÇ¨
const CARGO_QUOTES = {
    success: [
        "Ï¢ãÏïòÏñ¥!",
        "ÎÇòÏù¥Ïä§~!",
        "Ïù¥ Ï†ïÎèÑÎäî ÍªåÏù¥ÏßÄ!",
        "ÏôÑÎ≤ΩÌï¥!",
        "Í∞ê Ïû°ÏïòÎã§!",
        "Ïó≠Ïãú ÎÇòÏïº!",
        "Ïèô Îì§Ïñ¥Í∞îÎÑ§!",
        "Ï†ïÌôïÌï¥!",
        "Ïù¥Í≤å Ïã§Î†•Ïù¥Ïïº!",
        "Í∞ÄÏ¶àÏïÑ!"
    ],
    perfect: [
        "ÌçºÌéôÌä∏!!!",
        "ÏôÄ ÎåÄÎ∞ï!",
        "Ï≤úÏû¨Ïù∏Í∞Ä?!",
        "Ïù¥Í≤å Í∞ÄÎä•ÌïòÎã§Í≥†?!",
        "ÎØ∏Ï≥§Îã§!!",
        "Î†àÏ†ÑÎìú Í∞ÅÎèÑ!",
        "ÌîÑÎ°úÏù∏Í∞ÄÏöî?",
        "ÏÜêÎßõ Ï¢ãÎã§!"
    ],
    miss: [
        "ÏïÑ ÏïÑÍπùÎã§...",
        "Îã§ÏùåÏóî ÎßûÏ∂òÎã§!",
        "ÏÜêÏù¥ ÎØ∏ÎÅÑÎü¨Ï°åÏñ¥",
        "ÏúºÏïÖ!",
        "Ïù¥Îü∞...",
        "ÏßëÏ§ë ÏßëÏ§ë!",
        "Ïã§ÏàòÏïº Ïã§Ïàò"
    ],
    wrongTarget: [
        "Ïñ¥? Í±∞Í∏∞ ÏïÑÎãåÎç∞...",
        "ÏûòÎ™ª Îì§Ïñ¥Í∞îÎã§!",
        "ÏïÑ Ìó∑Í∞àÎ†§!",
        "ÏÉâÍπî Ï¢Ä Î≥¥Ïûê...",
        "Ïã§ÏàòÌñàÎÑ§..."
    ],
    combo: [
        "${combo}ÏΩ§Î≥¥Îã§!",
        "Ïó∞ÏÜç ${combo}Í∞ú!",
        "Î©àÏ∂ú Ïàò ÏóÜÏñ¥!",
        "${combo}Ïó∞ÏÜç ÏÑ±Í≥µ!",
        "ÏΩ§Î≥¥Í∞Ä ÌÑ∞ÏßÑÎã§!"
    ]
};

function getCargoQuote(type) {
    const quotes = CARGO_QUOTES[type];
    return quotes[Math.floor(Math.random() * quotes.length)];
}

function startCargoGame(timeBonus, rewardMultiplier) {
    cargoState = {
        count: 0,
        maxCount: 10,  // 10Í∞úÎ°ú Î≥ÄÍ≤Ω
        score: 0,
        time: 90 + timeBonus,  // ÏãúÍ∞ÑÎèÑ Ï§ÑÏûÑ
        rewardMultiplier: rewardMultiplier,
        currentCargo: null,
        nextCargo: null,
        gameOver: false,
        gameW: 0,
        gameH: 0,
        // Í≤åÏù¥ÏßÄ ÏÉÅÌÉú
        phase: 'angle',
        angleValue: 0,
        angleDir: 1,
        angleSpeed: 2.2,
        angleLocked: false,
        powerValue: 0,
        powerDir: 1,
        powerSpeed: 3,
        powerLocked: false,
        // Ï†ïÎãµ Íµ¨Í∞Ñ (ÌôîÎ¨ºÎ≥ÑÎ°ú Îã§Î¶Ñ)
        anglePerfectMin: 40,
        anglePerfectMax: 60,
        powerPerfectMin: 60,
        powerPerfectMax: 80,
        // ÎçòÏßÄÍ∏∞
        throwing: false,
        cargoSprite: null,
        throwVx: 0,
        throwVy: 0,
        throwTime: 0,
        // ÌÉÄÍ≤ü
        targets: [],
        // ÌååÌã∞ÌÅ¥
        particles: [],
        // ÏΩ§Î≥¥ & ÌçºÌéôÌä∏
        combo: 0,
        perfectCount: 0,
        // ÎßêÌíçÏÑ†
        speechBubble: null,
        // Î≥Ñ Î∞òÏßùÏûÑ
        stars: [],
        // Ïª®ÌÖåÏù¥ÎÑà
        particleContainer: null,
        trajectoryGraphics: null,
        playerContainer: null,
        targetContainer: null,
        bgContainer: null,
        gaugeContainer: null
    };
    
    spawnCargoCG();
    spawnNextCargoCG();
    renderCargoUI();
    initCargoPixi();
}

// ÌôîÎ¨º ÌÉÄÏûÖÎ≥Ñ Ï†ïÎãµ Íµ¨Í∞Ñ ÏÑ§Ï†ï
function getCargoZones(cargo) {
    // Í∞Å ÌÉÄÍ≤ü ÏúÑÏπòÏóê ÎßûÎäî Í∞ÅÎèÑ/ÌååÏõå ÏÑ§Ï†ï
    // ÏôºÏ™Ω(blue): ÎÇÆÏùÄ Í∞ÅÎèÑ, Ï§ëÍ∞Ñ ÌååÏõå
    // Ï§ëÏïô(yellow): Ï§ëÍ∞Ñ Í∞ÅÎèÑ, ÎÜíÏùÄ ÌååÏõå  
    // Ïò§Î•∏Ï™Ω(red): ÎÜíÏùÄ Í∞ÅÎèÑ, ÎÜíÏùÄ ÌååÏõå
    // any: Ï§ëÍ∞Ñ Í∞ÅÎèÑ, Ï§ëÍ∞Ñ ÌååÏõå
    
    switch(cargo.target) {
        case 'blue':   // ÏôºÏ™Ω ÌÉÄÍ≤ü
            return { angleMin: 20, angleMax: 35, powerMin: 50, powerMax: 65 };
        case 'yellow': // Ï§ëÏïô ÌÉÄÍ≤ü
            return { angleMin: 45, angleMax: 60, powerMin: 65, powerMax: 80 };
        case 'red':    // Ïò§Î•∏Ï™Ω ÌÉÄÍ≤ü
            return { angleMin: 65, angleMax: 80, powerMin: 70, powerMax: 85 };
        case 'any':    // ÏïÑÎ¨¥Îç∞ÎÇò
            return { angleMin: 40, angleMax: 65, powerMin: 55, powerMax: 75 };
        default:
            return { angleMin: 40, angleMax: 60, powerMin: 60, powerMax: 80 };
    }
}

function spawnCargoCG() {
    const s = cargoState;
    const types = [
        { emoji: 'üîß', name: 'Î∂ÄÌíà', target: 'blue', color: 0x3b82f6, points: 50 },
        { emoji: 'üçé', name: 'ÏãùÎüâ', target: 'yellow', color: 0xeab308, points: 50 },
        { emoji: '‚ò¢Ô∏è', name: 'ÏúÑÌóòÎ¨º', target: 'red', color: 0xef4444, points: 50 }
    ];
    
    // ÌäπÏàò ÌôîÎ¨º (5Í∞ú Ïù¥ÌõÑ Îì±Ïû• ÌôïÎ•†)
    if (s.count >= 5 && Math.random() < 0.25) {
        const specials = [
            { emoji: '‚≠ê', name: 'Í≥®Îìú', target: 'any', points: 150, color: 0xffd700 },
            { emoji: 'üéÅ', name: 'Î≥¥ÎÑàÏä§', target: 'any', points: 100, color: 0xff88ff }
        ];
        s.currentCargo = specials[Math.floor(Math.random() * specials.length)];
    } else {
        s.currentCargo = { ...types[Math.floor(Math.random() * types.length)] };
    }
    
    // Ï†ïÎãµ Íµ¨Í∞Ñ ÏÑ§Ï†ï
    const zones = getCargoZones(s.currentCargo);
    s.anglePerfectMin = zones.angleMin;
    s.anglePerfectMax = zones.angleMax;
    s.powerPerfectMin = zones.powerMin;
    s.powerPerfectMax = zones.powerMax;
}

function spawnNextCargoCG() {
    const types = [
        { emoji: 'üîß', name: 'Î∂ÄÌíà', target: 'blue', color: 0x3b82f6, points: 50 },
        { emoji: 'üçé', name: 'ÏãùÎüâ', target: 'yellow', color: 0xeab308, points: 50 },
        { emoji: '‚ò¢Ô∏è', name: 'ÏúÑÌóòÎ¨º', target: 'red', color: 0xef4444, points: 50 }
    ];
    cargoState.nextCargo = { ...types[Math.floor(Math.random() * types.length)] };
}

function renderCargoUI() {
    const s = cargoState;
    
    app.innerHTML = `
        <div style="width: 100%; height: 100%; background: #0a0a1a; display: flex; flex-direction: column; align-items: center;">
            <!-- HUD -->
            <div style="width: 100%; max-width: 420px; padding: 10px 15px; padding-top: calc(10px + var(--safe-top)); background: linear-gradient(180deg, rgba(0,0,0,0.9), rgba(0,0,0,0.5)); display: flex; justify-content: space-between; align-items: center; z-index: 100;">
                <div style="display: flex; gap: 12px; align-items: center; font-size: 0.85rem;">
                    <div>üì¶ Ï†ÅÏû¨ <span id="cg-count">${s.count}</span>/${s.maxCount}</div>
                    <div id="cg-combo-wrap" style="color: #fff;">üî• ÏΩ§Î≥¥ <span id="cg-combo">0</span></div>
                </div>
                <div style="display: flex; gap: 12px; align-items: center; font-size: 0.85rem;">
                    <div>‚è±Ô∏è <span id="cg-time">${Math.floor(s.time / 60)}:${(s.time % 60).toString().padStart(2, '0')}</span></div>
                    <div style="color: #44ff88;">‚≠ê <span id="cg-score">0</span>Ï†ê</div>
                </div>
            </div>
            
            <!-- Í≤åÏûÑ Ï∫îÎ≤ÑÏä§ -->
            <div id="cargo-canvas-wrap" style="flex: 1; width: 100%; max-width: 420px; position: relative;"></div>
            
            <!-- ÌïòÎã® Ïª®Ìä∏Î°§ -->
            <div style="width: 100%; max-width: 420px; padding: 15px; padding-bottom: calc(15px + var(--safe-bottom)); background: rgba(0,0,0,0.9);">
                <!-- ÌòÑÏû¨/Îã§Ïùå ÌôîÎ¨º -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="font-size: 2.5rem;" id="cg-current-emoji">${s.currentCargo?.emoji || 'üì¶'}</div>
                        <div>
                            <div style="font-size: 0.9rem; color: #fff; font-weight: bold;" id="cg-target-hint">‚Üí üü¶ Î∂ÄÌíàÌï®</div>
                            <div style="font-size: 0.7rem; color: #888;">Îã§Ïùå: <span id="cg-next-emoji">${s.nextCargo?.emoji || 'üîß'}</span></div>
                        </div>
                    </div>
                    <button id="btn-quit-cargo" style="background: rgba(255,100,100,0.3); border: 1px solid rgba(255,100,100,0.5); border-radius: 8px; padding: 6px 12px; color: #fff; font-size: 0.75rem;">‚úï Ìè¨Í∏∞</button>
                </div>
                
                <!-- ÏïàÎÇ¥ ÌÖçÏä§Ìä∏ -->
                <div id="cg-instruction" style="text-align: center; font-size: 1rem; color: #ffd700; margin-bottom: 12px; font-weight: bold;">
                    üéØ Ï¥àÎ°ù Íµ¨Í∞ÑÏóê ÎßûÏ∂∞ ÌÑ∞Ïπò!
                </div>
                
                <!-- Î∞úÏÇ¨ Î≤ÑÌäº -->
                <button id="btn-cargo-action" style="width: 100%; padding: 18px; font-size: 1.3rem; font-weight: bold; background: linear-gradient(135deg, #4488ff, #2266dd); border: none; border-radius: 16px; color: #fff; cursor: pointer; box-shadow: 0 4px 20px rgba(68,136,255,0.5); transition: transform 0.1s;">
                    üéØ Í∞ÅÎèÑ Í≥†Ï†ï!
                </button>
            </div>
        </div>
    `;
    
    setupCargoControlsCG();
}

function initCargoPixi() {
    const s = cargoState;
    const wrap = document.getElementById('cargo-canvas-wrap');
    s.gameW = wrap.clientWidth;
    s.gameH = wrap.clientHeight;
    
    cargoApp = new PIXI.Application({
        width: s.gameW,
        height: s.gameH,
        backgroundColor: 0x05051a,
        antialias: true
    });
    wrap.appendChild(cargoApp.view);
    
    // Î∞∞Í≤Ω Ïª®ÌÖåÏù¥ÎÑà
    s.bgContainer = new PIXI.Container();
    cargoApp.stage.addChild(s.bgContainer);
    createCargoBgCG();
    
    // ÌÉÄÍ≤ü Ïª®ÌÖåÏù¥ÎÑà
    s.targetContainer = new PIXI.Container();
    cargoApp.stage.addChild(s.targetContainer);
    createCargoTargetsCG();
    
    // Í∂§Ï†Å
    s.trajectoryGraphics = new PIXI.Graphics();
    cargoApp.stage.addChild(s.trajectoryGraphics);
    
    // ÌååÌã∞ÌÅ¥
    s.particleContainer = new PIXI.Container();
    cargoApp.stage.addChild(s.particleContainer);
    
    // ÌîåÎ†àÏù¥Ïñ¥
    s.playerContainer = new PIXI.Container();
    cargoApp.stage.addChild(s.playerContainer);
    createCargoPlayerCG();
    
    // Í≤åÏù¥ÏßÄ UI
    s.gaugeContainer = new PIXI.Container();
    cargoApp.stage.addChild(s.gaugeContainer);
    createGaugesCG();
    
    // ÌÉÄÏù¥Î®∏
    s.timerInterval = setInterval(() => {
        if (s.gameOver) return;
        s.time--;
        updateCargoHUDCG();
        if (s.time <= 0) endCargoGame(false);
    }, 1000);
    
    // Í≤åÏûÑ Î£®ÌîÑ
    cargoApp.ticker.add(cargoGameLoopCG);
}

function createCargoBgCG() {
    const s = cargoState;
    const bg = s.bgContainer;
    
    // Ïö∞Ï£º Î∞∞Í≤Ω Í∑∏ÎùºÎç∞Ïù¥ÏÖò (Ïó¨Îü¨ Î†àÏù¥Ïñ¥)
    const spaceBg = new PIXI.Graphics();
    
    // ÍπäÏùÄ Ïö∞Ï£º Î∞∞Í≤Ω
    spaceBg.beginFill(0x05051a);
    spaceBg.drawRect(0, 0, s.gameW, s.gameH);
    spaceBg.endFill();
    
    // ÏùÄÌïòÏàò Ìö®Í≥º (Ïó¨Îü¨ Í∞ú)
    spaceBg.beginFill(0x1a1a5a, 0.25);
    spaceBg.drawEllipse(s.gameW * 0.6, s.gameH * 0.25, s.gameW * 0.6, 70);
    spaceBg.endFill();
    
    spaceBg.beginFill(0x2a1a4a, 0.2);
    spaceBg.drawEllipse(s.gameW * 0.3, s.gameH * 0.4, s.gameW * 0.4, 40);
    spaceBg.endFill();
    
    // ÏÑ±Ïö¥ Ìö®Í≥º (Îã§ÏñëÌïú ÏÉâÏÉÅ)
    spaceBg.beginFill(0x4a1a6a, 0.12);
    spaceBg.drawEllipse(s.gameW * 0.15, s.gameH * 0.15, 90, 60);
    spaceBg.endFill();
    
    spaceBg.beginFill(0x1a4a6a, 0.1);
    spaceBg.drawEllipse(s.gameW * 0.8, s.gameH * 0.35, 70, 45);
    spaceBg.endFill();
    
    spaceBg.beginFill(0x6a3a4a, 0.08);
    spaceBg.drawEllipse(s.gameW * 0.5, s.gameH * 0.5, 100, 50);
    spaceBg.endFill();
    
    bg.addChild(spaceBg);
    
    // Î∞òÏßùÏù¥Îäî Î≥ÑÎì§ (Îã§ÏñëÌïú ÌÅ¨Í∏∞ÏôÄ ÏÉâÏÉÅ)
    for (let i = 0; i < 120; i++) {
        const star = new PIXI.Graphics();
        const size = 0.5 + Math.random() * 2.5;
        const brightness = 0.4 + Math.random() * 0.6;
        
        // Î≥Ñ ÏÉâÏÉÅ Îã§ÏñëÌôî
        const colors = [0xffffff, 0xffffee, 0xeeeeff, 0xffeedd, 0xddeeff, 0xffddff];
        const color = colors[Math.floor(Math.random() * colors.length)];
        
        star.beginFill(color, brightness);
        star.drawCircle(0, 0, size);
        star.endFill();
        
        // ÌÅ∞ Î≥ÑÏùÄ Í∏ÄÎ°úÏö∞ Ìö®Í≥º
        if (size > 1.8) {
            star.beginFill(color, 0.2);
            star.drawCircle(0, 0, size * 2);
            star.endFill();
        }
        
        star.x = Math.random() * s.gameW;
        star.y = Math.random() * (s.gameH * 0.58);
        star.baseAlpha = brightness;
        star.twinkleSpeed = 0.03 + Math.random() * 0.06;
        star.twinkleOffset = Math.random() * Math.PI * 2;
        
        bg.addChild(star);
        s.stars.push(star);
    }
    
    // ÌÅ∞ ÎπõÎÇòÎäî Î≥Ñ (Ïã≠ÏûêÌòï + Í∏ÄÎ°úÏö∞)
    for (let i = 0; i < 8; i++) {
        const bigStar = new PIXI.Graphics();
        const x = 25 + Math.random() * (s.gameW - 50);
        const y = 25 + Math.random() * (s.gameH * 0.45);
        const len = 8 + Math.random() * 12;
        
        // Í∏ÄÎ°úÏö∞ Ìö®Í≥º
        bigStar.beginFill(0xffffff, 0.15);
        bigStar.drawCircle(x, y, len * 1.5);
        bigStar.endFill();
        
        // Í¥ëÏÑ† Ìö®Í≥º
        bigStar.lineStyle(2, 0xffffff, 0.8);
        bigStar.moveTo(x - len, y); bigStar.lineTo(x + len, y);
        bigStar.moveTo(x, y - len); bigStar.lineTo(x, y + len);
        
        // ÎåÄÍ∞ÅÏÑ†
        bigStar.lineStyle(1.5, 0xffffff, 0.5);
        const diagLen = len * 0.6;
        bigStar.moveTo(x - diagLen, y - diagLen); bigStar.lineTo(x + diagLen, y + diagLen);
        bigStar.moveTo(x + diagLen, y - diagLen); bigStar.lineTo(x - diagLen, y + diagLen);
        
        // Ï§ëÏã¨
        bigStar.beginFill(0xffffff, 1);
        bigStar.drawCircle(x, y, 3);
        bigStar.endFill();
        
        bg.addChild(bigStar);
    }
    
    // ÌñâÏÑ± (Îçî ÎîîÌÖåÏùºÌïòÍ≤å)
    const planet = new PIXI.Graphics();
    const px = s.gameW * 0.88, py = s.gameH * 0.13;
    
    // ÌñâÏÑ± Í∑∏Î¶ºÏûê
    planet.beginFill(0x331144, 0.5);
    planet.drawCircle(px + 3, py + 3, 24);
    planet.endFill();
    
    // ÌñâÏÑ± Î≥∏Ï≤¥
    planet.beginFill(0x6644aa);
    planet.drawCircle(px, py, 24);
    planet.endFill();
    
    // ÌñâÏÑ± Î¨¥Îä¨
    planet.beginFill(0x5533aa, 0.6);
    planet.drawEllipse(px - 5, py + 5, 15, 8);
    planet.endFill();
    
    // ÌïòÏù¥ÎùºÏù¥Ìä∏
    planet.beginFill(0xaa88dd, 0.6);
    planet.drawCircle(px - 8, py - 8, 10);
    planet.endFill();
    planet.beginFill(0xffffff, 0.3);
    planet.drawCircle(px - 10, py - 10, 5);
    planet.endFill();
    
    // Í≥†Î¶¨ (Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ìö®Í≥º)
    planet.lineStyle(4, 0x9988cc, 0.4);
    planet.drawEllipse(px, py, 42, 10);
    planet.lineStyle(2, 0xbbaadd, 0.6);
    planet.drawEllipse(px, py, 38, 8);
    
    bg.addChild(planet);
    
    // ÏûëÏùÄ ÌñâÏÑ±/Îã¨
    const moon = new PIXI.Graphics();
    moon.beginFill(0x888899, 0.7);
    moon.drawCircle(s.gameW * 0.12, s.gameH * 0.25, 12);
    moon.endFill();
    moon.beginFill(0xaaaaaa, 0.4);
    moon.drawCircle(s.gameW * 0.12 - 3, s.gameH * 0.25 - 3, 6);
    moon.endFill();
    // ÌÅ¨Î†àÏù¥ÌÑ∞
    moon.beginFill(0x666677, 0.5);
    moon.drawCircle(s.gameW * 0.12 + 3, s.gameH * 0.25 + 2, 3);
    moon.drawCircle(s.gameW * 0.12 - 2, s.gameH * 0.25 + 4, 2);
    moon.endFill();
    bg.addChild(moon);
    
    // Ïö∞Ï£ºÏÑ† Î∞îÎã• (ÌôîÎ¨ºÏ∞Ω) - Îçî ÎîîÌÖåÏùºÌïòÍ≤å
    const floor = new PIXI.Graphics();
    
    // Î©îÏù∏ Î∞îÎã• (Í∑∏ÎùºÎç∞Ïù¥ÏÖò ÎäêÎÇå)
    floor.beginFill(0x1a1a3a);
    floor.drawRect(0, s.gameH - 100, s.gameW, 100);
    floor.endFill();
    
    floor.beginFill(0x252545);
    floor.drawRect(0, s.gameH - 100, s.gameW, 50);
    floor.endFill();
    
    // ÏÉÅÎã® ÌïòÏù¥ÎùºÏù¥Ìä∏ (Î©îÌÉàÎ¶≠)
    floor.beginFill(0x4a4a7a);
    floor.drawRect(0, s.gameH - 100, s.gameW, 6);
    floor.endFill();
    floor.beginFill(0x6a6a9a);
    floor.drawRect(0, s.gameH - 100, s.gameW, 2);
    floor.endFill();
    
    // Í≤©Ïûê Ìå®ÌÑ¥ (Îçî ÏÑ¨ÏÑ∏ÌïòÍ≤å)
    floor.lineStyle(1, 0x3a3a6a, 0.4);
    for (let i = 0; i < s.gameW; i += 20) {
        floor.moveTo(i, s.gameH - 94);
        floor.lineTo(i, s.gameH);
    }
    for (let j = s.gameH - 80; j < s.gameH; j += 15) {
        floor.moveTo(0, j);
        floor.lineTo(s.gameW, j);
    }
    
    // Î∞îÎã• Ïû•Ïãù Ìå®ÎÑêÎì§
    floor.beginFill(0x3a3a6a);
    floor.drawRoundedRect(10, s.gameH - 92, 60, 12, 4);
    floor.drawRoundedRect(s.gameW - 70, s.gameH - 92, 60, 12, 4);
    floor.endFill();
    
    // ÌôòÍ∏∞Íµ¨/Ïû•Ïãù
    floor.beginFill(0x2a2a5a);
    floor.drawRoundedRect(s.gameW/2 - 40, s.gameH - 90, 80, 8, 3);
    floor.endFill();
    floor.lineStyle(1, 0x4a4a7a);
    for (let i = 0; i < 7; i++) {
        floor.moveTo(s.gameW/2 - 35 + i * 11, s.gameH - 88);
        floor.lineTo(s.gameW/2 - 35 + i * 11, s.gameH - 84);
    }
    
    // ÏΩîÎÑà Ï°∞Î™Ö
    floor.beginFill(0x88ff88, 0.3);
    floor.drawCircle(15, s.gameH - 85, 4);
    floor.drawCircle(s.gameW - 15, s.gameH - 85, 4);
    floor.endFill();
    
    bg.addChild(floor);
}

function createCargoTargetsCG() {
    const s = cargoState;
    const targetY = 80;
    const targetW = 75;
    const targetH = 60;
    const gap = (s.gameW - targetW * 3) / 4;
    
    s.targets = [
        { id: 'blue', x: gap + targetW/2, y: targetY, w: targetW, h: targetH, 
          color: 0x3b82f6, darkColor: 0x1e40af, lightColor: 0x60a5fa, label: 'üîß', name: 'Î∂ÄÌíàÌï®' },
        { id: 'yellow', x: gap * 2 + targetW * 1.5, y: targetY, w: targetW, h: targetH, 
          color: 0xeab308, darkColor: 0xa16207, lightColor: 0xfacc15, label: 'üçé', name: 'ÏãùÎüâÌï®' },
        { id: 'red', x: gap * 3 + targetW * 2.5, y: targetY, w: targetW, h: targetH, 
          color: 0xef4444, darkColor: 0xb91c1c, lightColor: 0xf87171, label: '‚ò¢Ô∏è', name: 'ÏúÑÌóòÌï®' }
    ];
    
    s.targets.forEach(t => {
        const container = new PIXI.Container();
        container.x = t.x;
        container.y = t.y;
        
        // Í∏ÄÎ°úÏö∞ Ìö®Í≥º
        const glow = new PIXI.Graphics();
        glow.beginFill(t.color, 0.15);
        glow.drawRoundedRect(-t.w/2 - 8, -t.h/2 - 8, t.w + 16, t.h + 16, 18);
        glow.endFill();
        container.addChild(glow);
        
        // Í∑∏Î¶ºÏûê
        const shadow = new PIXI.Graphics();
        shadow.beginFill(0x000000, 0.4);
        shadow.drawRoundedRect(-t.w/2 + 6, -t.h/2 + 8, t.w, t.h, 14);
        shadow.endFill();
        container.addChild(shadow);
        
        // Î∞ïÏä§ Îí∑Î©¥ (3D ÍπäÏù¥Í∞ê)
        const boxBack = new PIXI.Graphics();
        boxBack.beginFill(t.darkColor);
        boxBack.drawRoundedRect(-t.w/2 + 4, -t.h/2 + 4, t.w, t.h, 14);
        boxBack.endFill();
        container.addChild(boxBack);
        
        // Î∞ïÏä§ Î≥∏Ï≤¥
        const box = new PIXI.Graphics();
        
        // Î©îÏù∏ Î∞ïÏä§
        box.beginFill(t.color);
        box.drawRoundedRect(-t.w/2, -t.h/2, t.w, t.h, 14);
        box.endFill();
        
        // ÏÉÅÎã® Î∞ùÏùÄ Î∂ÄÎ∂Ñ
        box.beginFill(t.lightColor, 0.4);
        box.drawRoundedRect(-t.w/2 + 4, -t.h/2 + 4, t.w - 8, t.h/3, 8);
        box.endFill();
        
        // ÏµúÏÉÅÎã® ÌïòÏù¥ÎùºÏù¥Ìä∏
        box.beginFill(0xffffff, 0.35);
        box.drawRoundedRect(-t.w/2 + 6, -t.h/2 + 6, t.w - 12, 12, 6);
        box.endFill();
        
        // ÌÖåÎëêÎ¶¨ (Î©îÌÉàÎ¶≠)
        box.lineStyle(3, 0xffffff, 0.4);
        box.drawRoundedRect(-t.w/2, -t.h/2, t.w, t.h, 14);
        box.lineStyle(2, t.lightColor, 0.6);
        box.drawRoundedRect(-t.w/2 + 2, -t.h/2 + 2, t.w - 4, t.h - 4, 12);
        
        // Í∏àÏÜç Î≥ºÌä∏
        const boltPositions = [
            [-t.w/2 + 10, -t.h/2 + 10],
            [t.w/2 - 10, -t.h/2 + 10],
            [-t.w/2 + 10, t.h/2 - 10],
            [t.w/2 - 10, t.h/2 - 10]
        ];
        boltPositions.forEach(([bx, by]) => {
            box.beginFill(0xcccccc, 0.9);
            box.drawCircle(bx, by, 5);
            box.endFill();
            box.beginFill(0x666666, 0.8);
            box.drawCircle(bx, by, 2.5);
            box.endFill();
            box.lineStyle(1.5, 0x444444, 0.8);
            box.moveTo(bx - 2, by); box.lineTo(bx + 2, by);
            box.moveTo(bx, by - 2); box.lineTo(bx, by + 2);
        });
        
        // Ï§ëÏïô Ïû•Ïãù ÎùºÏù∏
        box.lineStyle(2, t.darkColor, 0.4);
        box.moveTo(-t.w/2 + 15, 0);
        box.lineTo(t.w/2 - 15, 0);
        
        container.addChild(box);
        
        // ÎùºÎ≤® (Ïù¥Î™®ÏßÄ)
        const label = new PIXI.Text(t.label, { fontSize: 28 });
        label.anchor.set(0.5);
        label.y = -2;
        container.addChild(label);
        
        // Ïù¥Î¶Ñ ÎùºÎ≤® Î∞∞Í≤Ω
        const nameBg = new PIXI.Graphics();
        nameBg.beginFill(0x000000, 0.5);
        nameBg.drawRoundedRect(-25, t.h/2 + 6, 50, 16, 6);
        nameBg.endFill();
        container.addChild(nameBg);
        
        const nameLabel = new PIXI.Text(t.name, {
            fontSize: 10,
            fill: 0xffffff,
            fontWeight: 'bold'
        });
        nameLabel.anchor.set(0.5);
        nameLabel.y = t.h/2 + 14;
        container.addChild(nameLabel);
        
        t.sprite = container;
        s.targetContainer.addChild(container);
    });
}

function createCargoPlayerCG() {
    const s = cargoState;
    const container = s.playerContainer;
    container.x = s.gameW / 2;  // Í∞ÄÏö¥Îç∞ Î∞∞Ïπò
    container.y = s.gameH - 125;
    
    // ÌÅ¨Î¶¨Ï≤ò Í∑∏ÎûòÌîΩ
    const creatureG = new PIXI.Graphics();
    
    if (GameState.creature) {
        // Ïã§Ï†ú ÌÅ¨Î¶¨Ï≤òÎ•º Ï†ïÌôïÌûà Í∑∏Î¶¨Í∏∞
        const evolved = evolveCreatureByLevel(GameState.creature, 5);
        drawCreature(creatureG, evolved, 0, 0, 28, Date.now() * 0.001);
    } else {
        // Í∏∞Î≥∏ ÌÅ¨Î¶¨Ï≤ò
        creatureG.beginFill(0x4fc3f7);
        creatureG.drawEllipse(0, 0, 20, 26);
        creatureG.endFill();
        
        // ÌïòÏù¥ÎùºÏù¥Ìä∏
        creatureG.beginFill(0xffffff, 0.2);
        creatureG.drawEllipse(-5, -5, 8, 12);
        creatureG.endFill();
        
        // Îàà
        creatureG.beginFill(0xffffff);
        creatureG.drawEllipse(-6, -8, 7, 8);
        creatureG.drawEllipse(6, -8, 7, 8);
        creatureG.endFill();
        creatureG.beginFill(0x000000);
        creatureG.drawCircle(-4, -8, 4);
        creatureG.drawCircle(8, -8, 4);
        creatureG.endFill();
        creatureG.beginFill(0xffffff);
        creatureG.drawCircle(-6, -10, 2);
        creatureG.drawCircle(6, -10, 2);
        creatureG.endFill();
    }
    
    container.addChild(creatureG);
    s.creatureGraphic = creatureG;
    
    // ÏÜêÏóê Îì§Í≥† ÏûàÎäî ÌôîÎ¨º
    s.holdingCargo = new PIXI.Container();
    s.holdingCargo.x = 38;
    s.holdingCargo.y = -8;
    updateHoldingCargoCG();
    container.addChild(s.holdingCargo);
    
    s.playerSprite = container;
}

function createGaugesCG() {
    const s = cargoState;
    const g = s.gaugeContainer;
    
    // === Í∞ÅÎèÑ Í≤åÏù¥ÏßÄ (Ìò∏ ÌòïÌÉú) - ÏôºÏ™ΩÏóê Î∞∞Ïπò ===
    const gaugeCenterX = 55;
    const gaugeCenterY = s.gameH - 125;
    s.gaugeCenterX = gaugeCenterX;
    s.gaugeCenterY = gaugeCenterY;
    
    // Î∞∞Í≤Ω Ìò∏
    s.angleGaugeBg = new PIXI.Graphics();
    s.angleGaugeBg.lineStyle(12, 0x222244, 0.8);
    s.angleGaugeBg.arc(gaugeCenterX, gaugeCenterY, 80, -Math.PI * 0.85, -Math.PI * 0.15, false);
    g.addChild(s.angleGaugeBg);
    
    // Í∞ÅÎèÑ Ï†ïÎãµ Íµ¨Í∞Ñ (Ï¥àÎ°ùÏÉâ) - ÎèôÏ†ÅÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏Îê®
    s.anglePerfectZone = new PIXI.Graphics();
    g.addChild(s.anglePerfectZone);
    
    // Í∞ÅÎèÑ Ïù∏ÎîîÏºÄÏù¥ÌÑ∞
    s.angleIndicator = new PIXI.Graphics();
    g.addChild(s.angleIndicator);
    
    // === ÌååÏõå Í≤åÏù¥ÏßÄ (ÏÑ∏Î°ú Î∞î) ===
    // Î∞∞Í≤Ω
    s.powerGaugeBg = new PIXI.Graphics();
    s.powerGaugeBg.beginFill(0x222244, 0.8);
    s.powerGaugeBg.drawRoundedRect(s.gameW - 45, 110, 30, 180, 10);
    s.powerGaugeBg.endFill();
    // ÌÖåÎëêÎ¶¨
    s.powerGaugeBg.lineStyle(2, 0x444466, 0.8);
    s.powerGaugeBg.drawRoundedRect(s.gameW - 45, 110, 30, 180, 10);
    g.addChild(s.powerGaugeBg);
    
    // ÌååÏõå Ï†ïÎãµ Íµ¨Í∞Ñ (Ï¥àÎ°ùÏÉâ) - ÎèôÏ†ÅÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏Îê®
    s.powerPerfectZone = new PIXI.Graphics();
    g.addChild(s.powerPerfectZone);
    
    // ÌååÏõå Î∞î (Ï±ÑÏõåÏßÄÎäî Î∂ÄÎ∂Ñ)
    s.powerBar = new PIXI.Graphics();
    g.addChild(s.powerBar);
    
    // ÌååÏõå Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ (ÌôîÏÇ¥Ìëú)
    s.powerIndicator = new PIXI.Graphics();
    g.addChild(s.powerIndicator);
    
    // ÎùºÎ≤®
    const angleLabel = new PIXI.Text('Í∞ÅÎèÑ', { fontSize: 12, fill: 0x88aaff, fontWeight: 'bold' });
    angleLabel.x = 28; angleLabel.y = s.gameH - 45;
    g.addChild(angleLabel);
    
    const powerLabel = new PIXI.Text('ÌååÏõå', { fontSize: 12, fill: 0xffaa88, fontWeight: 'bold' });
    powerLabel.x = s.gameW - 50; powerLabel.y = 295;
    g.addChild(powerLabel);
    
    // Ï†ïÎãµ Íµ¨Í∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
    updatePerfectZones();
    updateGaugesCG();
}

function updatePerfectZones() {
    const s = cargoState;
    const cx = s.gaugeCenterX || 55;
    const cy = s.gaugeCenterY || (s.gameH - 125);
    
    // Í∞ÅÎèÑ Ï†ïÎãµ Íµ¨Í∞Ñ
    if (s.anglePerfectZone) {
        s.anglePerfectZone.clear();
        s.anglePerfectZone.lineStyle(12, 0x44ff88, 0.7);
        const startAngle = -Math.PI * 0.85 + (s.anglePerfectMin / 100) * Math.PI * 0.7;
        const endAngle = -Math.PI * 0.85 + (s.anglePerfectMax / 100) * Math.PI * 0.7;
        s.anglePerfectZone.arc(cx, cy, 80, startAngle, endAngle, false);
    }
    
    // ÌååÏõå Ï†ïÎãµ Íµ¨Í∞Ñ
    if (s.powerPerfectZone) {
        s.powerPerfectZone.clear();
        s.powerPerfectZone.beginFill(0x44ff88, 0.6);
        const barHeight = 170;
        const topY = 285 - (s.powerPerfectMax / 100) * barHeight;
        const height = ((s.powerPerfectMax - s.powerPerfectMin) / 100) * barHeight;
        s.powerPerfectZone.drawRoundedRect(s.gameW - 43, topY, 26, height, 5);
        s.powerPerfectZone.endFill();
    }
}

function updateGaugesCG() {
    const s = cargoState;
    const cx = s.gaugeCenterX || 55;
    const cy = s.gaugeCenterY || (s.gameH - 125);
    
    // Í∞ÅÎèÑ Ïù∏ÎîîÏºÄÏù¥ÌÑ∞
    if (s.angleIndicator) {
        s.angleIndicator.clear();
        const angleRad = -Math.PI * 0.85 + (s.angleValue / 100) * Math.PI * 0.7;
        const r = 80;
        
        // ÌòÑÏû¨ Í∞ÅÎèÑ ÏÑ†
        const color = s.angleLocked ? 0x44ff88 : 0xffff00;
        s.angleIndicator.lineStyle(5, color, 1);
        s.angleIndicator.moveTo(cx, cy);
        s.angleIndicator.lineTo(cx + Math.cos(angleRad) * r, cy + Math.sin(angleRad) * r);
        
        // ÎÅù Ïõê
        s.angleIndicator.beginFill(color);
        s.angleIndicator.drawCircle(cx + Math.cos(angleRad) * r, cy + Math.sin(angleRad) * r, 12);
        s.angleIndicator.endFill();
        
        // ÎÅù Ïõê ÌÖåÎëêÎ¶¨
        s.angleIndicator.lineStyle(2, 0xffffff, 0.8);
        s.angleIndicator.drawCircle(cx + Math.cos(angleRad) * r, cy + Math.sin(angleRad) * r, 12);
        
        // Ï§ëÏã¨ Ïõê
        s.angleIndicator.beginFill(0x333355);
        s.angleIndicator.lineStyle(2, 0x555577);
        s.angleIndicator.drawCircle(cx, cy, 10);
        s.angleIndicator.endFill();
    }
    
    // ÌååÏõå Î∞î (power ÌéòÏù¥Ï¶àÏóêÏÑúÎßå)
    if (s.powerBar && (s.phase === 'power' || s.phase === 'throwing')) {
        s.powerBar.clear();
        const barH = (s.powerValue / 100) * 170;
        const color = s.powerLocked ? 0x44ff88 : 0xff8844;
        s.powerBar.beginFill(color, 0.9);
        s.powerBar.drawRoundedRect(s.gameW - 43, 285 - barH, 26, barH, 5);
        s.powerBar.endFill();
    }
    
    // ÌååÏõå Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ ÌôîÏÇ¥Ìëú
    if (s.powerIndicator && (s.phase === 'power' || s.phase === 'throwing')) {
        s.powerIndicator.clear();
        const indY = 285 - (s.powerValue / 100) * 170;
        s.powerIndicator.beginFill(0xffffff);
        s.powerIndicator.moveTo(s.gameW - 50, indY);
        s.powerIndicator.lineTo(s.gameW - 62, indY - 10);
        s.powerIndicator.lineTo(s.gameW - 62, indY + 10);
        s.powerIndicator.endFill();
    }
}

function setupCargoControlsCG() {
    const s = cargoState;
    
    const actionBtn = document.getElementById('btn-cargo-action');
    actionBtn.onclick = () => {
        if (s.gameOver || s.throwing) return;
        
        if (s.phase === 'angle') {
            s.angleLocked = true;
            s.phase = 'power';
            
            // ÌçºÌéôÌä∏ Ï≤¥ÌÅ¨
            const isPerfect = s.angleValue >= s.anglePerfectMin && s.angleValue <= s.anglePerfectMax;
            if (isPerfect) {
                createPerfectEffectCG(55, s.gameH - 125);
                s.perfectCount++;
            }
            
            actionBtn.textContent = 'üí™ ÌååÏõå Í≥†Ï†ï!';
            actionBtn.style.background = 'linear-gradient(135deg, #ff8844, #dd6622)';
            document.getElementById('cg-instruction').textContent = 'üí™ Ï¥àÎ°ù Íµ¨Í∞ÑÏóê ÎßûÏ∂∞ ÌÑ∞Ïπò!';
            
        } else if (s.phase === 'power') {
            s.powerLocked = true;
            
            // ÌçºÌéôÌä∏ Ï≤¥ÌÅ¨
            const isPerfect = s.powerValue >= s.powerPerfectMin && s.powerValue <= s.powerPerfectMax;
            if (isPerfect) {
                createPerfectEffectCG(s.gameW - 30, 200);
                s.perfectCount++;
            }
            
            s.phase = 'throwing';
            throwCargoCG();
            
            actionBtn.disabled = true;
            actionBtn.style.opacity = '0.5';
            document.getElementById('cg-instruction').textContent = 'üöÄ Î∞úÏÇ¨!';
        }
    };
    
    document.getElementById('btn-quit-cargo').onclick = () => {
        if (confirm('Ìè¨Í∏∞ÌïòÏãúÍ≤†ÏäµÎãàÍπå?\nÌòÑÏû¨ÍπåÏßÄ Î≤à Ï†êÏàòÏùò 50%Î•º Î∞õÏäµÎãàÎã§.')) {
            endCargoGame(false, true);
        }
    };
    
    updateCargoHintCG();
}

function throwCargoCG() {
    const s = cargoState;
    s.throwing = true;
    
    // ÌîåÎ†àÏù¥Ïñ¥ Ïï†ÎãàÎ©îÏù¥ÏÖò
    if (s.playerSprite) {
        s.playerSprite.rotation = -0.3;
    }
    
    // ÌôîÎ¨º Ïä§ÌîÑÎùºÏù¥Ìä∏ ÏÉùÏÑ±
    const cargo = new PIXI.Container();
    
    // Î∞ïÏä§ Í∑∏Î¶ºÏûê
    const boxShadow = new PIXI.Graphics();
    boxShadow.beginFill(0x000000, 0.3);
    boxShadow.drawRoundedRect(-13, -13, 30, 30, 5);
    boxShadow.endFill();
    cargo.addChild(boxShadow);
    
    // Î∞ïÏä§ Î≥∏Ï≤¥
    const box = new PIXI.Graphics();
    box.beginFill(s.currentCargo?.color || 0x888888);
    box.lineStyle(2, 0xffffff, 0.6);
    box.drawRoundedRect(-15, -15, 30, 30, 6);
    box.endFill();
    // ÌïòÏù¥ÎùºÏù¥Ìä∏
    box.beginFill(0xffffff, 0.25);
    box.drawRoundedRect(-12, -12, 24, 10, 3);
    box.endFill();
    cargo.addChild(box);
    
    const emoji = new PIXI.Text(s.currentCargo?.emoji || 'üì¶', { fontSize: 18 });
    emoji.anchor.set(0.5);
    cargo.addChild(emoji);
    
    // Í∞ÄÏö¥Îç∞ÏóêÏÑú ÏãúÏûë
    s.throwStartX = s.gameW / 2 + 30;
    s.throwStartY = s.gameH - 133;
    cargo.x = s.throwStartX;
    cargo.y = s.throwStartY;
    cargoApp.stage.addChild(cargo);
    s.cargoSprite = cargo;
    
    // ÏÜêÏóê Îì† ÌôîÎ¨º Ïà®Í∏∞Í∏∞
    if (s.holdingCargo) s.holdingCargo.visible = false;
    
    // ÏÜçÎèÑ Í≥ÑÏÇ∞
    const angleRad = -Math.PI * 0.85 + (s.angleValue / 100) * Math.PI * 0.7;
    const power = 280 + s.powerValue * 5;
    s.throwVx = Math.cos(angleRad) * power;
    s.throwVy = Math.sin(angleRad) * power;
    s.throwTime = 0;
    
    // Î∞úÏÇ¨ Ïù¥ÌéôÌä∏
    createThrowEffectCG(cargo.x, cargo.y);
}

function createThrowEffectCG(x, y) {
    const s = cargoState;
    for (let i = 0; i < 25; i++) {
        const p = new PIXI.Graphics();
        const colors = [0xffffff, 0xffff88, 0x88ffff, 0xff88ff, 0x88ff88];
        p.beginFill(colors[Math.floor(Math.random() * colors.length)]);
        
        if (Math.random() > 0.6) {
            drawStar(p, 0, 0, 5, 3 + Math.random() * 4, 1.5);
        } else {
            p.drawCircle(0, 0, 2 + Math.random() * 4);
        }
        p.endFill();
        p.x = x; p.y = y;
        p.vx = (Math.random() - 0.5) * 14;
        p.vy = (Math.random() - 0.5) * 14;
        p.life = 40;
        s.particleContainer.addChild(p);
        s.particles.push(p);
    }
}

function createPerfectEffectCG(x, y) {
    const s = cargoState;
    
    // PERFECT ÌÖçÏä§Ìä∏
    const text = new PIXI.Text('PERFECT!', {
        fontSize: 24,
        fill: 0xffd700,
        fontWeight: 'bold',
        stroke: 0x000000,
        strokeThickness: 4
    });
    text.anchor.set(0.5);
    text.x = x; text.y = y - 30;
    text.vy = -2; text.life = 55;
    text.isText = true; text.vx = 0;
    s.particleContainer.addChild(text);
    s.particles.push(text);
    
    // Î≥Ñ ÌååÌã∞ÌÅ¥
    for (let i = 0; i < 15; i++) {
        const p = new PIXI.Graphics();
        p.beginFill(0xffd700);
        drawStar(p, 0, 0, 5, 7, 3);
        p.endFill();
        p.x = x; p.y = y;
        const angle = (i / 15) * Math.PI * 2;
        p.vx = Math.cos(angle) * 6;
        p.vy = Math.sin(angle) * 6;
        p.life = 45;
        s.particleContainer.addChild(p);
        s.particles.push(p);
    }
    
    // Ï∂©Í≤©Ìåå
    const ring = new PIXI.Graphics();
    ring.lineStyle(4, 0xffd700, 0.9);
    ring.drawCircle(0, 0, 15);
    ring.x = x; ring.y = y;
    ring.life = 35; ring.isRing = true; ring.vx = 0; ring.vy = 0;
    s.particleContainer.addChild(ring);
    s.particles.push(ring);
}

function showCargoSpeechBubble(text) {
    const s = cargoState;
    if (s.speechBubble) {
        s.particleContainer.removeChild(s.speechBubble);
    }
    
    const bubble = new PIXI.Container();
    
    // ÎßêÌíçÏÑ† ÌÖçÏä§Ìä∏
    const textObj = new PIXI.Text(text, {
        fontSize: 16,
        fill: 0x333333,
        fontWeight: 'bold'
    });
    textObj.anchor.set(0.5);
    
    const padding = 16;
    const bgWidth = textObj.width + padding * 2;
    const bgHeight = textObj.height + padding * 2;
    
    // ÎßêÌíçÏÑ† Í∑∏Î¶ºÏûê
    const shadow = new PIXI.Graphics();
    shadow.beginFill(0x000000, 0.2);
    shadow.drawRoundedRect(-bgWidth/2 + 3, -bgHeight/2 + 3, bgWidth, bgHeight, 15);
    shadow.endFill();
    bubble.addChild(shadow);
    
    // ÎßêÌíçÏÑ† Î∞∞Í≤Ω (Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ìö®Í≥º)
    const bg = new PIXI.Graphics();
    bg.beginFill(0xffffff);
    bg.lineStyle(3, 0x88aaff, 0.6);
    bg.drawRoundedRect(-bgWidth/2, -bgHeight/2, bgWidth, bgHeight, 15);
    bg.endFill();
    
    // ÏÉÅÎã® ÌïòÏù¥ÎùºÏù¥Ìä∏
    bg.beginFill(0xeeffff, 0.5);
    bg.drawRoundedRect(-bgWidth/2 + 4, -bgHeight/2 + 4, bgWidth - 8, bgHeight/3, 10);
    bg.endFill();
    
    // Íº¨Î¶¨
    bg.beginFill(0xffffff);
    bg.lineStyle(3, 0x88aaff, 0.6);
    bg.moveTo(-10, bgHeight/2 - 3);
    bg.lineTo(10, bgHeight/2 - 3);
    bg.lineTo(0, bgHeight/2 + 15);
    bg.closePath();
    bg.endFill();
    
    bubble.addChild(bg);
    bubble.addChild(textObj);
    
    // Ï∫êÎ¶≠ÌÑ∞ ÏúÑÏóê ÌëúÏãú
    bubble.x = s.gameW / 2;
    bubble.y = s.gameH - 205;
    bubble.life = 180;  // 100 -> 180 (ÏïΩ 2Î∞∞)
    bubble.isText = true;
    bubble.isBubble = true;  // ÎßêÌíçÏÑ† Ï†ÑÏö© ÌîåÎûòÍ∑∏
    bubble.vy = 0;
    bubble.vx = 0;
    
    s.particleContainer.addChild(bubble);
    s.speechBubble = bubble;
    s.particles.push(bubble);
}

function cargoGameLoopCG(delta) {
    const s = cargoState;
    if (!s || s.gameOver) return;
    
    // Î≥Ñ Î∞òÏßùÏûÑ (Îçî Í∑πÏ†ÅÏúºÎ°ú)
    const time = Date.now() * 0.001;
    s.stars.forEach(star => {
        const twinkle = Math.sin(time * star.twinkleSpeed * 15 + star.twinkleOffset);
        // 0.1 ~ 1.0 Î≤îÏúÑÎ°ú Îçî Í∑πÏ†ÅÏù∏ Î∞òÏßùÏûÑ
        star.alpha = star.baseAlpha * (0.15 + 0.85 * Math.abs(twinkle));
        // ÌÅ¨Í∏∞ÎèÑ ÏÇ¥Ïßù Î≥ÄÌôî
        const scaleVar = 1 + 0.2 * Math.abs(twinkle);
        star.scale.set(scaleVar);
    });
    
    // Í≤åÏù¥ÏßÄ Ïï†ÎãàÎ©îÏù¥ÏÖò
    if (s.phase === 'angle' && !s.angleLocked) {
        s.angleValue += s.angleDir * s.angleSpeed * delta;
        if (s.angleValue >= 100) { s.angleValue = 100; s.angleDir = -1; }
        if (s.angleValue <= 0) { s.angleValue = 0; s.angleDir = 1; }
    }
    
    if (s.phase === 'power' && !s.powerLocked) {
        s.powerValue += s.powerDir * s.powerSpeed * delta;
        if (s.powerValue >= 100) { s.powerValue = 100; s.powerDir = -1; }
        if (s.powerValue <= 0) { s.powerValue = 0; s.powerDir = 1; }
    }
    
    updateGaugesCG();
    
    // ÎçòÏßÄÍ∏∞ Î¨ºÎ¶¨
    if (s.throwing && s.cargoSprite) {
        const gravity = 500;
        s.throwTime += delta / 60;
        
        const startX = s.throwStartX || (s.gameW / 2 + 30);
        const startY = s.throwStartY || (s.gameH - 133);
        const newX = startX + s.throwVx * s.throwTime;
        const newY = startY + s.throwVy * s.throwTime + 0.5 * gravity * s.throwTime * s.throwTime;
        
        s.cargoSprite.x = newX;
        s.cargoSprite.y = newY;
        s.cargoSprite.rotation += 0.15 * delta;
        
        // Ï∂©Îèå Ï≤¥ÌÅ¨
        for (const target of s.targets) {
            if (newX > target.x - target.w/2 - 10 && newX < target.x + target.w/2 + 10 &&
                newY > target.y - target.h/2 - 10 && newY < target.y + target.h/2 + 10) {
                cargoHitCG(target);
                return;
            }
        }
        
        // ÌôîÎ©¥ Î∞ñ
        if (newY > s.gameH || newX > s.gameW + 50 || newX < -50) {
            cargoMissCG();
        }
    }
    
    // ÌååÌã∞ÌÅ¥
    for (let i = s.particles.length - 1; i >= 0; i--) {
        const p = s.particles[i];
        p.x += p.vx || 0;
        p.y += p.vy || 0;
        if (!p.isText && !p.isRing) p.vy = (p.vy || 0) + 0.25;
        
        // ÎßêÌíçÏÑ†ÏùÄ Îçî Ï≤úÏ≤úÌûà ÏÇ¨ÎùºÏßê
        if (p.isBubble) {
            if (p.life < 30) p.alpha -= 0.03;  // ÎßàÏßÄÎßâ 30ÌîÑÎ†àÏûÑÏóêÏÑúÎßå ÌéòÏù¥ÎìúÏïÑÏõÉ
        } else {
            p.alpha -= 0.018;
        }
        
        p.life--;
        if (p.isRing) { p.scale.x += 0.14; p.scale.y += 0.14; }
        if (p.life <= 0 || p.alpha <= 0) {
            s.particleContainer.removeChild(p);
            s.particles.splice(i, 1);
            if (p === s.speechBubble) s.speechBubble = null;
        }
    }
}

function cargoHitCG(target) {
    const s = cargoState;
    const cargo = s.currentCargo;
    let points = 0;
    let success = false;
    let quoteType = 'miss';
    
    if (cargo.target === 'any') {
        points = cargo.points;
        success = true;
        quoteType = s.perfectCount >= 2 ? 'perfect' : 'success';
    } else if (cargo.target === target.id) {
        points = cargo.points;
        success = true;
        s.combo++;
        
        if (s.perfectCount >= 2) {
            quoteType = 'perfect';
            points = Math.floor(points * 1.5);
        } else if (s.combo >= 3) {
            quoteType = 'combo';
            points = Math.floor(points * 1.3);
        } else {
            quoteType = 'success';
        }
        
        if (s.combo >= 5) points = Math.floor(points * 1.2);
    } else {
        points = -20;
        s.combo = 0;
        quoteType = 'wrongTarget';
    }
    
    s.score += points;
    s.count++;
    
    createHitEffectCG(target.x, target.y, success, points);
    
    // ÎåÄÏÇ¨ ÌëúÏãú
    let quote = getCargoQuote(quoteType);
    if (quoteType === 'combo') {
        quote = quote.replace('${combo}', s.combo);
    }
    showCargoSpeechBubble(quote);
    
    // ÌÉÄÍ≤ü Î∞òÏùë
    if (target.sprite) {
        target.sprite.scale.set(1.25);
        setTimeout(() => { if (target.sprite) target.sprite.scale.set(1); }, 200);
    }
    
    finishThrowCG();
}

function cargoMissCG() {
    const s = cargoState;
    s.score -= 15;
    s.count++;
    s.combo = 0;
    
    if (s.cargoSprite) {
        createMissEffectCG(s.cargoSprite.x, Math.min(s.cargoSprite.y, s.gameH - 60));
    }
    
    // Ïã§Ìå® ÎåÄÏÇ¨
    showCargoSpeechBubble(getCargoQuote('miss'));
    
    finishThrowCG();
}

function createHitEffectCG(x, y, success, points) {
    const s = cargoState;
    const colors = success ? [0x44ff88, 0xffff00, 0x88ffff, 0xff88ff] : [0xff6666, 0xff8888];
    
    for (let i = 0; i < (success ? 30 : 12); i++) {
        const p = new PIXI.Graphics();
        p.beginFill(colors[Math.floor(Math.random() * colors.length)]);
        if (Math.random() > 0.5) drawStar(p, 0, 0, 5, 5 + Math.random() * 6, 2);
        else p.drawCircle(0, 0, 2 + Math.random() * 5);
        p.endFill();
        p.x = x; p.y = y;
        const angle = (i / (success ? 30 : 12)) * Math.PI * 2;
        const speed = 4 + Math.random() * 7;
        p.vx = Math.cos(angle) * speed;
        p.vy = Math.sin(angle) * speed;
        p.life = 50;
        s.particleContainer.addChild(p);
        s.particles.push(p);
    }
    
    // Ï∂©Í≤©Ìåå (ÏÑ±Í≥µ Ïãú)
    if (success) {
        const ring = new PIXI.Graphics();
        ring.lineStyle(5, s.combo >= 3 ? 0xffd700 : 0x44ff88, 0.9);
        ring.drawCircle(0, 0, 15);
        ring.x = x; ring.y = y;
        ring.life = 35; ring.isRing = true; ring.vx = 0; ring.vy = 0;
        s.particleContainer.addChild(ring);
        s.particles.push(ring);
    }
    
    // Ï†êÏàò ÌÖçÏä§Ìä∏
    const scoreText = new PIXI.Text((points >= 0 ? '+' : '') + points, {
        fontSize: points >= 70 ? 36 : 28,
        fill: success ? 0x44ff88 : 0xff6666,
        fontWeight: 'bold',
        stroke: 0x000000,
        strokeThickness: 5
    });
    scoreText.anchor.set(0.5);
    scoreText.x = x; scoreText.y = y - 35;
    scoreText.vy = -3; scoreText.life = 65; scoreText.isText = true; scoreText.vx = 0;
    s.particleContainer.addChild(scoreText);
    s.particles.push(scoreText);
}

function createMissEffectCG(x, y) {
    const s = cargoState;
    const miss = new PIXI.Text('MISS!', {
        fontSize: 30,
        fill: 0xff4444,
        fontWeight: 'bold',
        stroke: 0x000000,
        strokeThickness: 4
    });
    miss.anchor.set(0.5);
    miss.x = x; miss.y = y;
    miss.life = 50; miss.isText = true; miss.vy = -2; miss.vx = 0;
    s.particleContainer.addChild(miss);
    s.particles.push(miss);
}

function finishThrowCG() {
    const s = cargoState;
    
    if (s.cargoSprite) {
        cargoApp.stage.removeChild(s.cargoSprite);
        s.cargoSprite = null;
    }
    
    s.throwing = false;
    s.perfectCount = 0;
    
    if (s.playerSprite) s.playerSprite.rotation = 0;
    
    updateCargoHUDCG();
    
    if (s.count >= s.maxCount) {
        setTimeout(() => endCargoGame(true), 900);
    } else {
        setTimeout(() => resetForNextCG(), 700);
    }
}

function resetForNextCG() {
    const s = cargoState;
    
    s.currentCargo = s.nextCargo;
    spawnNextCargoCG();
    
    // Ï†ïÎãµ Íµ¨Í∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
    const zones = getCargoZones(s.currentCargo);
    s.anglePerfectMin = zones.angleMin;
    s.anglePerfectMax = zones.angleMax;
    s.powerPerfectMin = zones.powerMin;
    s.powerPerfectMax = zones.powerMax;
    updatePerfectZones();
    
    s.phase = 'angle';
    s.angleLocked = false;
    s.powerLocked = false;
    s.angleValue = 50;
    s.powerValue = 0;
    
    // ÌååÏõåÎ∞î Ï¥àÍ∏∞Ìôî
    if (s.powerBar) s.powerBar.clear();
    if (s.powerIndicator) s.powerIndicator.clear();
    
    updateCargoHintCG();
    updateHoldingCargoCG();
    
    const btn = document.getElementById('btn-cargo-action');
    if (btn) {
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.textContent = 'üéØ Í∞ÅÎèÑ Í≥†Ï†ï!';
        btn.style.background = 'linear-gradient(135deg, #4488ff, #2266dd)';
    }
    document.getElementById('cg-instruction').textContent = 'üéØ Ï¥àÎ°ù Íµ¨Í∞ÑÏóê ÎßûÏ∂∞ ÌÑ∞Ïπò!';
}

function updateHoldingCargoCG() {
    const s = cargoState;
    if (!s.holdingCargo || !s.currentCargo) return;
    
    s.holdingCargo.visible = true;
    s.holdingCargo.removeChildren();
    
    // Î∞ïÏä§ Í∑∏Î¶ºÏûê
    const shadow = new PIXI.Graphics();
    shadow.beginFill(0x000000, 0.3);
    shadow.drawRoundedRect(-10, -10, 24, 24, 4);
    shadow.endFill();
    s.holdingCargo.addChild(shadow);
    
    // Î∞ïÏä§
    const box = new PIXI.Graphics();
    box.beginFill(s.currentCargo.color || 0x888888);
    box.lineStyle(2, 0xffffff, 0.5);
    box.drawRoundedRect(-12, -12, 24, 24, 5);
    box.endFill();
    box.beginFill(0xffffff, 0.2);
    box.drawRoundedRect(-9, -9, 18, 8, 3);
    box.endFill();
    s.holdingCargo.addChild(box);
    
    const emoji = new PIXI.Text(s.currentCargo.emoji, { fontSize: 14 });
    emoji.anchor.set(0.5);
    s.holdingCargo.addChild(emoji);
}

function updateCargoHintCG() {
    const s = cargoState;
    const hintEl = document.getElementById('cg-target-hint');
    const currentEl = document.getElementById('cg-current-emoji');
    const nextEl = document.getElementById('cg-next-emoji');
    
    if (currentEl && s.currentCargo) currentEl.textContent = s.currentCargo.emoji;
    if (nextEl && s.nextCargo) nextEl.textContent = s.nextCargo.emoji;
    
    if (hintEl && s.currentCargo) {
        const map = {
            'blue': '‚Üí üü¶ Î∂ÄÌíàÌï® (ÏôºÏ™Ω)',
            'yellow': '‚Üí üü® ÏãùÎüâÌï® (Ï§ëÏïô)',
            'red': '‚Üí üü• ÏúÑÌóòÌï® (Ïò§Î•∏Ï™Ω)',
            'any': '‚Üí ‚≠ê ÏïÑÎ¨¥Îç∞ÎÇò!'
        };
        hintEl.textContent = map[s.currentCargo.target] || '';
        hintEl.style.color = s.currentCargo.target === 'any' ? '#ffd700' : '#fff';
    }
}

function updateCargoHUDCG() {
    const s = cargoState;
    const countEl = document.getElementById('cg-count');
    const scoreEl = document.getElementById('cg-score');
    const timeEl = document.getElementById('cg-time');
    const comboEl = document.getElementById('cg-combo');
    const comboWrap = document.getElementById('cg-combo-wrap');
    
    if (countEl) countEl.textContent = s.count;
    if (scoreEl) scoreEl.textContent = Math.max(0, s.score);
    if (comboEl) comboEl.textContent = s.combo;
    if (comboWrap) comboWrap.style.color = s.combo >= 3 ? '#ffd700' : '#fff';
    
    if (timeEl) {
        const min = Math.floor(s.time / 60);
        const sec = s.time % 60;
        timeEl.textContent = `${min}:${sec.toString().padStart(2, '0')}`;
        timeEl.style.color = s.time < 30 ? '#ff6b6b' : '#fff';
    }
}

function endCargoGame(success, partialReward = false) {
    const s = cargoState;
    s.gameOver = true;
    clearInterval(s.timerInterval);
    
    if (cargoApp) {
        cargoApp.destroy(true);
        cargoApp = null;
    }
    
    if (success) {
        // Ï†êÏàò Í∏∞Î∞ò Î≥¥ÏÉÅ Í≥ÑÏÇ∞
        const scoreReward = Math.floor(s.score * 0.3);  // Ï†êÏàòÏùò 30%
        const timeLeft = s.time;
        let timeBonus = 0, timeRating = '';
        
        if (timeLeft >= 60) { timeBonus = 30; timeRating = '‚≠ê‚≠ê‚≠ê'; }
        else if (timeLeft >= 30) { timeBonus = 20; timeRating = '‚≠ê‚≠ê'; }
        else if (timeLeft >= 10) { timeBonus = 10; timeRating = '‚≠ê'; }
        else { timeBonus = 0; timeRating = '-'; }
        
        const baseReward = Math.max(20, scoreReward + timeBonus);
        const envBonus = getEnvBonus('cargo');
        const partsBonus = getPartsBonus('cargo');
        const totalReward = Math.floor((baseReward + envBonus + partsBonus) * s.rewardMultiplier);
        
        GameState.spaceLuck = (GameState.spaceLuck || 0) + totalReward;
        GameState.save();
        
        showMiniGameResult(true, {
            baseReward, envBonus, partsBonus,
            rewardMultiplier: s.rewardMultiplier,
            totalReward, timeRating,
            count: s.count, score: s.score
        });
    } else if (partialReward && s.score > 0) {
        const partialLuck = Math.floor(s.score * 0.15);
        GameState.spaceLuck = (GameState.spaceLuck || 0) + partialLuck;
        GameState.save();
        showMiniGameResult(false, { count: s.count, score: s.score, partialReward: partialLuck });
    } else {
        showMiniGameResult(false, { count: s.count, score: s.score });
    }
}

// ÎØ∏ÎãàÍ≤åÏûÑ 3: Î∞∞ÏÑ† Ï†ïÎ¶¨
// ========================================
let wiringState = null;

function startWiringGame(timeBonus, rewardMultiplier) {
    const baseTime = 180;
    const maxTime = baseTime + timeBonus;
    
    wiringState = {
        level: 1,
        maxLevel: 10,
        time: maxTime,
        rewardMultiplier: rewardMultiplier,
        ports: [],
        connections: [],
        currentWire: null,
        gameOver: false
    };
    
    generateWiringLevel(wiringState.level);
    renderWiringGame();
    startWiringLoop();
}

function generateWiringLevel(level) {
    const colors = ['#ef4444', '#3b82f6', '#eab308', '#22c55e', '#a855f7', '#f97316'];
    let portCount = 3;
    let obstacleCount = 0;
    
    if (level >= 4) { portCount = 4; obstacleCount = 1; }
    if (level >= 7) { portCount = 5; obstacleCount = 2; }
    if (level >= 9) { portCount = 6; obstacleCount = 3; }
    
    const w = window.innerWidth;
    const h = window.innerHeight;
    const startY = 150;
    const endY = h - 200;
    const spacing = (endY - startY) / (portCount + 1);
    
    wiringState.ports = [];
    wiringState.connections = [];
    
    // ÏôºÏ™Ω Ìè¨Ìä∏
    const leftPorts = [];
    for (let i = 0; i < portCount; i++) {
        leftPorts.push({
            id: `L${i}`,
            x: 40,
            y: startY + spacing * (i + 1),
            color: colors[i],
            connected: false
        });
    }
    
    // Ïò§Î•∏Ï™Ω Ìè¨Ìä∏ (ÏÖîÌîå)
    const rightColors = [...colors.slice(0, portCount)].sort(() => Math.random() - 0.5);
    const rightPorts = [];
    for (let i = 0; i < portCount; i++) {
        rightPorts.push({
            id: `R${i}`,
            x: w - 40,
            y: startY + spacing * (i + 1),
            color: rightColors[i],
            connected: false
        });
    }
    
    wiringState.ports = [...leftPorts, ...rightPorts];
    
    // Ïû•Ïï†Î¨º ÏÉùÏÑ±
    wiringState.obstacles = [];
    for (let i = 0; i < obstacleCount; i++) {
        wiringState.obstacles.push({
            x: w * 0.3 + Math.random() * (w * 0.4),
            y: startY + Math.random() * (endY - startY),
            w: 60, h: 60
        });
    }
}

function renderWiringGame() {
    const s = wiringState;
    const w = window.innerWidth;
    const h = window.innerHeight;
    
    app.innerHTML = `
        <div style="width: 100%; height: 100%; background: linear-gradient(180deg, #1a2a1a, #0f1a0f); position: relative; overflow: hidden; touch-action: none;">
            <!-- HUD -->
            <div style="position: absolute; top: 0; left: 0; right: 0; padding: 10px; padding-top: calc(10px + var(--safe-top)); background: rgba(0,0,0,0.5); display: flex; justify-content: space-between; align-items: center; z-index: 100;">
                <div style="font-size: 1rem;">üì∂ Lv.<span id="wr-level">${s.level}</span>/${s.maxLevel}</div>
                <div style="font-size: 1rem;">‚úÖ <span id="wr-connected">${s.connections.length}</span>/${s.ports.length / 2}</div>
                <div style="font-size: 1rem;">‚è±Ô∏è <span id="wr-time">${Math.floor(s.time / 60)}:${(s.time % 60).toString().padStart(2, '0')}</span></div>
            </div>
            
            <!-- Ï∫îÎ≤ÑÏä§ (Î∞∞ÏÑ† Í∑∏Î¶¨Í∏∞) -->
            <canvas id="wiring-canvas" width="${w}" height="${h}" style="position: absolute; top: 0; left: 0;"></canvas>
            
            <!-- Ìè¨Ìä∏Îì§ -->
            ${s.ports.map(p => `
                <div class="wiring-port" data-id="${p.id}" style="position: absolute; left: ${p.x}px; top: ${p.y}px; width: 30px; height: 30px; background: ${p.color}; border-radius: 50%; transform: translate(-50%, -50%); border: 3px solid #fff; cursor: pointer; z-index: 50;"></div>
            `).join('')}
            
            <!-- Ïû•Ïï†Î¨º -->
            ${(s.obstacles || []).map(o => `
                <div style="position: absolute; left: ${o.x}px; top: ${o.y}px; width: ${o.w}px; height: ${o.h}px; background: rgba(100,100,100,0.8); border-radius: 8px; transform: translate(-50%, -50%); display: flex; align-items: center; justify-content: center; font-size: 1.5rem;">üì¶</div>
            `).join('')}
            
            <!-- ÎÇòÍ∞ÄÍ∏∞ Î≤ÑÌäº -->
            <button id="btn-quit-wiring" style="position: fixed; top: calc(60px + var(--safe-top)); right: 10px; background: rgba(255,0,0,0.3); border: 1px solid rgba(255,0,0,0.5); border-radius: 8px; padding: 8px 12px; color: #fff; font-size: 0.8rem; z-index: 100;">‚úï Ìè¨Í∏∞</button>
        </div>
    `;
    
    drawConnections();
    setupWiringControls();
}

function setupWiringControls() {
    const canvas = document.getElementById('wiring-canvas');
    const ctx = canvas.getContext('2d');
    const ports = document.querySelectorAll('.wiring-port');
    
    let startPort = null;
    let currentPos = null;
    
    ports.forEach(port => {
        port.addEventListener('mousedown', startWire);
        port.addEventListener('touchstart', startWire, { passive: false });
    });
    
    function startWire(e) {
        e.preventDefault();
        const portId = e.target.dataset.id;
        const port = wiringState.ports.find(p => p.id === portId);
        
        if (port && !port.connected) {
            startPort = port;
            
            document.addEventListener('mousemove', drawWire);
            document.addEventListener('touchmove', drawWire, { passive: false });
            document.addEventListener('mouseup', endWire);
            document.addEventListener('touchend', endWire);
        }
    }
    
    function drawWire(e) {
        if (!startPort) return;
        e.preventDefault();
        
        const touch = e.touches ? e.touches[0] : e;
        currentPos = { x: touch.clientX, y: touch.clientY };
        
        drawConnections();
        
        // ÌòÑÏû¨ ÎìúÎûòÍ∑∏ Ï§ëÏù∏ ÏÑ†
        ctx.strokeStyle = startPort.color;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(startPort.x, startPort.y);
        ctx.lineTo(currentPos.x, currentPos.y);
        ctx.stroke();
    }
    
    function endWire(e) {
        document.removeEventListener('mousemove', drawWire);
        document.removeEventListener('touchmove', drawWire);
        document.removeEventListener('mouseup', endWire);
        document.removeEventListener('touchend', endWire);
        
        if (!startPort || !currentPos) {
            startPort = null;
            currentPos = null;
            drawConnections();
            return;
        }
        
        // ÎÅù Ìè¨Ìä∏ Ï∞æÍ∏∞
        const endPort = wiringState.ports.find(p => {
            if (p.id === startPort.id) return false;
            if (p.connected) return false;
            const dx = p.x - currentPos.x;
            const dy = p.y - currentPos.y;
            return Math.sqrt(dx * dx + dy * dy) < 30;
        });
        
        if (endPort && endPort.color === startPort.color) {
            // Ïó∞Í≤∞ ÏÑ±Í≥µ!
            startPort.connected = true;
            endPort.connected = true;
            wiringState.connections.push({ from: startPort, to: endPort });
            
            SFX.play('eat');
            
            // UI ÏóÖÎç∞Ïù¥Ìä∏
            const connEl = document.getElementById('wr-connected');
            if (connEl) connEl.textContent = wiringState.connections.length;
            
            // Î†àÎ≤® ÌÅ¥Î¶¨Ïñ¥ Ï≤¥ÌÅ¨
            if (wiringState.connections.length >= wiringState.ports.length / 2) {
                nextWiringLevel();
            }
        }
        
        startPort = null;
        currentPos = null;
        drawConnections();
    }
    
    document.getElementById('btn-quit-wiring').onclick = () => {
        if (confirm('Ï†ïÎßê Ìè¨Í∏∞ÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
            endWiringGame(false);
        }
    };
}

function drawConnections() {
    const canvas = document.getElementById('wiring-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // ÏôÑÎ£åÎêú Ïó∞Í≤∞Îì§
    for (const conn of wiringState.connections) {
        ctx.strokeStyle = conn.from.color;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(conn.from.x, conn.from.y);
        ctx.lineTo(conn.to.x, conn.to.y);
        ctx.stroke();
    }
}

function nextWiringLevel() {
    wiringState.level++;
    
    if (wiringState.level > wiringState.maxLevel) {
        endWiringGame(true);
        return;
    }
    
    setTimeout(() => {
        generateWiringLevel(wiringState.level);
        renderWiringGame();
    }, 500);
}

function startWiringLoop() {
    wiringState.timerInterval = setInterval(() => {
        if (wiringState.gameOver) return;
        
        wiringState.time--;
        
        const timeEl = document.getElementById('wr-time');
        if (timeEl) {
            const min = Math.floor(wiringState.time / 60);
            const sec = wiringState.time % 60;
            timeEl.textContent = `${min}:${sec.toString().padStart(2, '0')}`;
            timeEl.style.color = wiringState.time < 30 ? '#ff6b6b' : '#fff';
        }
        
        if (wiringState.time <= 0) {
            endWiringGame(false);
        }
    }, 1000);
}

function endWiringGame(success) {
    wiringState.gameOver = true;
    clearInterval(wiringState.timerInterval);
    
    if (success) {
        const timeLeft = wiringState.time;
        let baseReward = 150;
        let timeRating = '';
        
        if (timeLeft >= 120) { baseReward = 300; timeRating = '‚≠ê‚≠ê‚≠ê'; }
        else if (timeLeft >= 60) { baseReward = 220; timeRating = '‚≠ê‚≠ê'; }
        else if (timeLeft >= 30) { baseReward = 180; timeRating = '‚≠ê'; }
        else { baseReward = 150; timeRating = '-'; }
        
        const envBonus = getEnvBonus('wiring');
        const partsBonus = getPartsBonus('wiring');
        const totalReward = Math.floor((baseReward + envBonus + partsBonus) * wiringState.rewardMultiplier);
        
        GameState.spaceLuck = (GameState.spaceLuck || 0) + totalReward;
        GameState.save();
        
        showMiniGameResult(true, {
            baseReward, envBonus, partsBonus,
            rewardMultiplier: wiringState.rewardMultiplier,
            totalReward, timeRating,
            level: wiringState.level - 1
        });
    } else {
        showMiniGameResult(false, {
            level: wiringState.level
        });
    }
}

// ========================================
// ÎØ∏ÎãàÍ≤åÏûÑ Í≤∞Í≥º ÌôîÎ©¥
// ========================================
function showMiniGameResult(success, data) {
    if (success) {
        SFX.play('clear');
    } else {
        SFX.play('gameover');
    }
    
    app.innerHTML = `
        <div class="page-center" style="background: linear-gradient(180deg, #0a0a1a, #1a1a3a);">
            <div class="page-content">
                <div class="page-icon">${success ? '‚úÖ' : '‚ùå'}</div>
                <h2 class="page-title">${success ? 'ÏûëÏóÖ ÏôÑÎ£å!' : 'ÏûëÏóÖ Ïã§Ìå®'}</h2>
                
                ${success ? `
                    <div style="font-size: 1.5rem; color: #ffd700; margin: 10px 0;">${data.timeRating}</div>
                    <div style="background: rgba(0,0,0,0.3); border-radius: 12px; padding: 15px; margin: 20px 0;">
                        <div style="font-size: 0.8rem; color: #888; margin-bottom: 10px;">Î≥¥ÏÉÅ ÎÇ¥Ïó≠</div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span style="color: #aaa;">Í∏∞Î≥∏ Î≥¥ÏÉÅ</span>
                            <span style="color: #fff;">${data.baseReward} LUCK</span>
                        </div>
                        ${data.envBonus !== 0 ? `
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span style="color: #aaa;">ÌôòÍ≤Ω Î≥¥ÎÑàÏä§</span>
                            <span style="color: ${data.envBonus > 0 ? '#44ff88' : '#ff6b6b'};">${data.envBonus > 0 ? '+' : ''}${data.envBonus} LUCK</span>
                        </div>
                        ` : ''}
                        ${data.partsBonus !== 0 ? `
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span style="color: #aaa;">ÌååÏ∏† Î≥¥ÎÑàÏä§</span>
                            <span style="color: #44ff88;">+${data.partsBonus} LUCK</span>
                        </div>
                        ` : ''}
                        ${data.rewardMultiplier !== 1 ? `
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span style="color: #aaa;">üé≤ Ï£ºÏÇ¨ÏúÑ Î∞∞Ïú®</span>
                            <span style="color: #ffd700;">√ó${data.rewardMultiplier}</span>
                        </div>
                        ` : ''}
                        <div style="border-top: 1px solid rgba(255,255,255,0.1); margin-top: 10px; padding-top: 10px; display: flex; justify-content: space-between;">
                            <span style="color: #fff; font-weight: 600;">Ï¥ù ÌöçÎìù</span>
                            <span style="color: #ffd700; font-weight: 700; font-size: 1.2rem;">+${data.totalReward} LUCK</span>
                        </div>
                    </div>
                    <div style="color: #888; font-size: 0.85rem; margin-bottom: 15px;">ÌòÑÏû¨ Î≥¥Ïú†: ${GameState.spaceLuck.toLocaleString()} LUCK</div>
                ` : `
                    <div style="color: #888; font-size: 0.9rem; margin: 20px 0;">
                        ${data.partialReward > 0 ? `
                            Ìè¨Í∏∞ÌñàÏäµÎãàÎã§.<br>
                            <div style="margin-top: 10px; color: #ffd700;">üí∞ +${data.partialReward} LUCK ÌöçÎìù</div>
                            <div style="font-size: 0.8rem; color: #666; margin-top: 5px;">ÌòÑÏû¨ Î≥¥Ïú†: ${GameState.spaceLuck.toLocaleString()} LUCK</div>
                        ` : `
                            ÏãúÍ∞Ñ Ï¥àÍ≥º ÎòêÎäî Ìè¨Í∏∞ÌñàÏäµÎãàÎã§.<br>
                            Îã§Ïãú ÎèÑÏ†ÑÌï¥Î≥¥ÏÑ∏Ïöî!
                        `}
                    </div>
                `}
                
                <button class="btn btn-primary btn-block" id="btn-continue">Í≥ÑÏÜçÌïòÍ∏∞</button>
            </div>
        </div>
    `;
    
    document.getElementById('btn-continue').onclick = () => showSpaceLobby();
}

// ÌôòÍ≤Ω Î≥¥ÎÑàÏä§ Í≥ÑÏÇ∞
function getEnvBonus(jobType) {
    const envId = GameState.envId;
    const bonusTable = {
        cleaning: { ice: 5, atmosphere: 5, toxic: -5 },
        cargo: { hydrothermal: 5, magma: 5, toxic: -5 },
        wiring: { toxic: 5, magma: -5 }
    };
    return bonusTable[jobType]?.[envId] || 0;
}

// ÌååÏ∏† Î≥¥ÎÑàÏä§ Í≥ÑÏÇ∞
function getPartsBonus(jobType) {
    let bonus = 0;
    const parts = GameState.parts || {};
    
    // Í≥µÌÜµ Î≥¥ÎÑàÏä§
    if (parts.antenna > 0) bonus += 2;
    
    // ÏûëÏóÖÎ≥Ñ Î≥¥ÎÑàÏä§
    if (jobType === 'cleaning' && parts.leg > 0) bonus += 3;
    if (jobType === 'cargo' && parts.arm > 0) bonus += 3;
    if (jobType === 'wiring' && parts.eye > 0) bonus += 3;
    
    return bonus;
}

// ========================================
// Initialize
// ========================================
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        document.getElementById('loading').classList.add('fade-out');
        setTimeout(showTitle, 500);
    }, 800);
});
    </script>
</body>
</html>
