<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BOKLUCK Universe</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ²</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
    --void: #030308;
    --void-light: #0a0a1a;
    --void-surface: #12122a;
    --void-elevated: #1a1a3a;
    --neon-cyan: #00f5d4;
    --neon-pink: #f72585;
    --neon-purple: #7b2cbf;
    --neon-yellow: #fee440;
    --success: #10b981;
    --danger: #ef4444;
    --text-primary: #e8e8ff;
    --text-secondary: #9090b0;
    --text-muted: #606080;
    --border-subtle: rgba(255,255,255,0.06);
    --border-default: rgba(0,245,212,0.15);
    --gradient-energy: linear-gradient(135deg, #00f5d4, #fee440);
    --gradient-danger: linear-gradient(135deg, #ef4444, #f72585);
    --safe-top: env(safe-area-inset-top, 0px);
    --safe-bottom: env(safe-area-inset-bottom, 0px);
}

html, body { height: 100%; overflow: hidden; touch-action: manipulation; -webkit-tap-highlight-color: transparent; -webkit-user-select: none; user-select: none; }
body { background: var(--void); color: var(--text-primary); font-family: 'Noto Sans KR', sans-serif; font-size: 14px; }

.btn { display: inline-flex; align-items: center; justify-content: center; gap: 8px; padding: 14px 28px; border: none; border-radius: 12px; font-family: inherit; font-size: 1rem; font-weight: 600; cursor: pointer; transition: transform 0.2s; }
.btn:active { transform: scale(0.96); }
.btn-energy { background: var(--gradient-energy); color: var(--void); }
.btn-outline { background: transparent; color: var(--text-primary); border: 1px solid var(--border-default); }
.btn-ghost { background: rgba(255,255,255,0.08); color: var(--text-primary); }
.btn-sm { padding: 10px 16px; font-size: 0.85rem; }
.btn-block { width: 100%; }

#app { position: fixed; inset: 0; overflow: hidden; }
#stars-bg { position: fixed; inset: 0; z-index: 0; pointer-events: none; }
.star { position: absolute; background: white; border-radius: 50%; animation: twinkle var(--dur, 3s) ease-in-out infinite; }
@keyframes twinkle { 0%,100%{opacity:0.2} 50%{opacity:1} }
@keyframes float { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-10px)} }

.page-center { position: fixed; inset: 0; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 24px; background: linear-gradient(180deg, rgba(3,3,8,0.95), rgba(10,10,26,0.98)); }
.page-content { max-width: 400px; width: 100%; text-align: center; }
.page-icon { font-size: 4rem; margin-bottom: 16px; animation: float 3s ease-in-out infinite; }
.page-title { font-family: 'Orbitron', monospace; font-size: clamp(1.25rem,5vw,1.75rem); font-weight: 700; margin-bottom: 20px; background: var(--gradient-energy); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.page-text { font-size: 1rem; line-height: 1.9; color: var(--text-secondary); margin-bottom: 28px; }
.page-text .hl { color: var(--neon-cyan); font-weight: 500; }
.page-text .gold { color: var(--neon-yellow); }
.page-text .danger { color: var(--neon-pink); }

.dots { display: flex; justify-content: center; gap: 8px; margin-bottom: 20px; }
.dot { width: 8px; height: 8px; border-radius: 50%; background: var(--void-elevated); transition: all 0.3s; }
.dot.active { background: var(--neon-cyan); width: 24px; border-radius: 4px; }
.dot.done { background: var(--text-muted); }

.dice-box { width: 140px; height: 140px; margin: 24px auto; display: flex; align-items: center; justify-content: center; font-size: 5rem; background: var(--void-surface); border: 2px solid var(--border-default); border-radius: 20px; }
.dice-box.rolling { animation: shake 0.1s linear infinite; }
@keyframes shake { 0%,100%{transform:rotate(0) scale(1)} 25%{transform:rotate(-10deg) scale(1.05)} 50%{transform:rotate(10deg) scale(0.95)} }

#game-canvas { position: fixed; inset: 0; z-index: 1; touch-action: none; }

.hud-top { position: fixed; top: 0; left: 0; right: 0; z-index: 50; padding: 12px 16px; padding-top: calc(12px + var(--safe-top)); display: flex; justify-content: space-between; align-items: flex-start; gap: 8px; pointer-events: none; }
.hud-top > * { pointer-events: auto; }
.hud-panel { background: rgba(10,10,26,0.92); border: 1px solid var(--border-default); border-radius: 14px; padding: 10px 12px; backdrop-filter: blur(8px); }
.hud-name { font-family: 'Orbitron', monospace; font-size: 0.7rem; color: var(--neon-cyan); margin-bottom: 6px; }
.hud-row { display: flex; align-items: center; gap: 6px; font-size: 0.8rem; margin-bottom: 3px; }
.hud-val { font-family: 'Orbitron', monospace; font-weight: 700; color: var(--neon-yellow); }
.hud-label { color: var(--text-muted); font-size: 0.65rem; }

.size-bar { display: flex; align-items: center; gap: 6px; margin-top: 6px; padding-top: 6px; border-top: 1px solid var(--border-subtle); }
.size-track { flex: 1; height: 6px; background: var(--void-elevated); border-radius: 3px; overflow: hidden; }
.size-fill { height: 100%; background: var(--gradient-energy); border-radius: 3px; transition: width 0.2s; }
.size-num { font-family: 'Orbitron', monospace; font-size: 0.65rem; color: var(--text-muted); }

.parts-grid { display: flex; flex-wrap: wrap; gap: 3px; margin-bottom: 6px; }
.part-badge { display: flex; align-items: center; gap: 2px; background: var(--void-elevated); border: 1px solid var(--border-subtle); border-radius: 5px; padding: 2px 5px; font-size: 0.65rem; }
.part-badge.on { border-color: var(--neon-cyan); box-shadow: 0 0 4px rgba(0,245,212,0.3); }
.part-cnt { font-family: 'Orbitron', monospace; font-size: 0.55rem; color: var(--neon-yellow); }

.prog-section { margin-bottom: 6px; }
.prog-label { display: flex; justify-content: space-between; font-size: 0.6rem; margin-bottom: 2px; }
.prog-left { color: var(--text-muted); }
.prog-right { color: var(--neon-cyan); font-family: 'Orbitron', monospace; }
.prog-track { height: 6px; background: var(--void-elevated); border-radius: 3px; overflow: hidden; }
.prog-fill { height: 100%; border-radius: 3px; transition: width 0.2s; }
.prog-fill.evo { background: var(--gradient-energy); }
.prog-fill.stage { background: linear-gradient(90deg, var(--neon-purple), var(--neon-pink)); }

.hud-btns { display: flex; gap: 6px; }
.hud-btn { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; background: rgba(10,10,26,0.92); border: 1px solid var(--border-default); border-radius: 8px; font-size: 1rem; cursor: pointer; }

.hud-bottom { position: fixed; bottom: 0; left: 0; right: 0; z-index: 50; padding: 10px 16px; padding-bottom: calc(70px + var(--safe-bottom)); pointer-events: none; }
.stage-bar { background: rgba(10,10,26,0.9); border: 1px solid var(--border-default); border-radius: 10px; padding: 8px 12px; max-width: 340px; margin: 0 auto; }
.stage-row { display: flex; justify-content: space-between; font-size: 0.65rem; margin-bottom: 4px; }
.stage-cur { font-family: 'Orbitron', monospace; color: var(--neon-purple); }
.stage-next { color: var(--text-muted); }

.controls { position: fixed; bottom: 0; left: 0; right: 0; z-index: 50; padding: 14px; padding-bottom: calc(14px + var(--safe-bottom)); display: flex; justify-content: space-between; align-items: flex-end; pointer-events: none; }
.controls.joy-right { flex-direction: row-reverse; }
.joystick { width: 100px; height: 100px; position: relative; pointer-events: auto; }
.joy-base { width: 100%; height: 100%; background: rgba(10,10,26,0.5); border: 2px solid var(--border-default); border-radius: 50%; }
.joy-knob { position: absolute; top: 50%; left: 50%; width: 40px; height: 40px; margin: -20px; background: var(--gradient-energy); border-radius: 50%; box-shadow: 0 4px 12px rgba(0,245,212,0.4); }

.action-btn { width: 60px; height: 60px; background: rgba(10,10,26,0.8); border: 2px solid var(--neon-cyan); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.3rem; cursor: pointer; pointer-events: auto; box-shadow: 0 0 12px rgba(0,245,212,0.3); }
.action-btn:active { transform: scale(0.95); background: rgba(0,245,212,0.2); }
.action-btn.disabled { opacity: 0.3; border-color: var(--text-muted); }
.action-btn.ready { border-color: var(--neon-yellow); box-shadow: 0 0 20px rgba(254,228,64,0.5); animation: pulse 1s infinite; }
@keyframes pulse { 0%,100%{box-shadow:0 0 20px rgba(254,228,64,0.5)} 50%{box-shadow:0 0 30px rgba(254,228,64,0.8)} }

.toast-box { position: fixed; top: calc(14px + var(--safe-top)); left: 50%; transform: translateX(-50%); z-index: 300; display: flex; flex-direction: column; gap: 6px; pointer-events: none; }
.toast { background: var(--void-elevated); border: 1px solid var(--border-default); border-radius: 10px; padding: 8px 14px; display: flex; align-items: center; gap: 6px; animation: toastIn 0.3s, toastOut 0.3s 2.5s forwards; font-size: 0.85rem; white-space: nowrap; }
.toast.success { border-color: var(--success); }
.toast.danger { border-color: var(--danger); }
.toast.warning { border-color: var(--neon-yellow); }
@keyframes toastIn { from{transform:translateY(-20px);opacity:0} to{transform:translateY(0);opacity:1} }
@keyframes toastOut { from{opacity:1} to{opacity:0} }

.evo-popup { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%) scale(0); z-index: 250; background: rgba(10,10,26,0.98); border: 2px solid var(--neon-cyan); border-radius: 18px; padding: 24px 36px; text-align: center; opacity: 0; transition: all 0.4s cubic-bezier(0.34,1.56,0.64,1); }
.evo-popup.show { transform: translate(-50%,-50%) scale(1); opacity: 1; }
.evo-icon { font-size: 3rem; margin-bottom: 8px; }
.evo-title { font-family: 'Orbitron', monospace; font-size: 1.2rem; font-weight: 900; background: var(--gradient-energy); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 4px; }
.evo-desc { color: var(--text-secondary); font-size: 0.8rem; }
.evo-fx { color: var(--neon-cyan); font-size: 0.75rem; font-weight: 600; margin-top: 4px; }

.modal { position: fixed; inset: 0; z-index: 300; display: flex; align-items: center; justify-content: center; padding: 24px; background: rgba(3,3,8,0.95); }
.modal-box { text-align: center; max-width: 340px; }
.modal-icon { font-size: 4rem; margin-bottom: 12px; }
.modal-title { font-family: 'Orbitron', monospace; font-size: 1.6rem; font-weight: 900; margin-bottom: 8px; }
.modal-title.fail { color: var(--danger); }
.modal-title.win { color: var(--success); }
.modal-desc { color: var(--text-secondary); margin-bottom: 16px; line-height: 1.6; }
.modal-stats { background: var(--void-surface); border-radius: 10px; padding: 12px; margin-bottom: 16px; }
.stat-row { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid var(--border-subtle); font-size: 0.85rem; }
.stat-row:last-child { border-bottom: none; }
.stat-label { color: var(--text-muted); }
.stat-val { font-family: 'Orbitron', monospace; color: var(--neon-cyan); }

.save-page { position: fixed; inset: 0; z-index: 100; display: flex; flex-direction: column; align-items: center; padding: 24px; padding-top: calc(24px + var(--safe-top)); overflow-y: auto; background: linear-gradient(180deg, rgba(3,3,8,0.95), rgba(10,10,26,0.98)); }
.save-header { display: flex; align-items: center; justify-content: space-between; width: 100%; max-width: 440px; margin-bottom: 16px; }
.save-title { font-family: 'Orbitron', monospace; font-size: 1.1rem; }
.slots { display: flex; flex-direction: column; gap: 10px; max-width: 440px; width: 100%; }
.slot { background: var(--void-surface); border: 2px solid var(--border-subtle); border-radius: 12px; padding: 12px; text-align: left; }
.slot.empty { border-style: dashed; opacity: 0.6; text-align: center; padding: 24px 12px; cursor: pointer; }
.slot-head { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
.slot-num { font-family: 'Orbitron', monospace; font-size: 0.6rem; color: var(--text-muted); background: var(--void-light); padding: 2px 6px; border-radius: 4px; }
.slot-name { font-family: 'Orbitron', monospace; font-weight: 600; font-size: 0.9rem; margin-bottom: 2px; }
.slot-info { font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 8px; }
.slot-actions { display: flex; gap: 6px; }
.del-btn { padding: 6px 12px; background: rgba(239,68,68,0.2); border: 1px solid var(--danger); border-radius: 6px; color: var(--danger); font-size: 0.8rem; cursor: pointer; }

.climb-hud { position: fixed; top: 0; left: 0; right: 0; z-index: 50; padding: 12px 16px; padding-top: calc(12px + var(--safe-top)); display: flex; justify-content: space-between; align-items: center; pointer-events: none; }
.climb-hud > * { pointer-events: auto; }
.climb-info { background: rgba(10,10,26,0.92); border: 1px solid var(--border-default); border-radius: 10px; padding: 8px 12px; }
.climb-height { font-family: 'Orbitron', monospace; font-size: 1.1rem; font-weight: 700; color: var(--neon-cyan); }
.climb-label { font-size: 0.6rem; color: var(--text-muted); }
.climb-goal { background: rgba(10,10,26,0.92); border: 1px solid var(--neon-purple); border-radius: 10px; padding: 8px 12px; text-align: center; }
.climb-goal-text { font-size: 0.6rem; color: var(--text-muted); }
.climb-goal-val { font-family: 'Orbitron', monospace; font-size: 0.85rem; color: var(--neon-purple); }

.runner-hud { position: fixed; top: 0; left: 0; right: 0; z-index: 50; padding: 12px 16px; padding-top: calc(12px + var(--safe-top)); display: flex; justify-content: space-between; align-items: center; pointer-events: none; }
.runner-hud > * { pointer-events: auto; }
.runner-stage { background: rgba(10,10,26,0.92); border: 1px solid var(--neon-purple); border-radius: 10px; padding: 8px 14px; text-align: center; }
.runner-stage-name { font-family: 'Orbitron', monospace; font-size: 0.75rem; color: var(--neon-purple); }
.runner-dist { font-family: 'Orbitron', monospace; font-size: 0.9rem; font-weight: 700; color: var(--neon-cyan); }

.evo-dice-overlay { position: fixed; inset: 0; z-index: 200; display: flex; align-items: center; justify-content: center; background: rgba(3,3,8,0.95); }
.evo-dice-box { text-align: center; max-width: 320px; padding: 24px; }
.evo-dice-title { font-family: 'Orbitron', monospace; font-size: 1.3rem; font-weight: 700; margin-bottom: 8px; background: var(--gradient-energy); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.evo-dice-sub { color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 20px; }
.trait-result { background: var(--void-surface); border: 2px solid var(--neon-cyan); border-radius: 16px; padding: 20px; margin: 16px 0; }
.trait-icon { font-size: 3rem; margin-bottom: 8px; }
.trait-name { font-family: 'Orbitron', monospace; font-size: 1.1rem; font-weight: 700; color: var(--neon-cyan); }
.trait-desc { color: var(--text-secondary); font-size: 0.8rem; margin-top: 4px; }
.trait-effect { color: var(--neon-yellow); font-size: 0.75rem; margin-top: 8px; font-weight: 600; }
    </style>
</head>
<body>
    <div id="stars-bg"></div>
    <div id="app"></div>
    <div class="toast-box" id="toasts"></div>
    <div class="evo-popup" id="evo-popup">
        <div class="evo-icon" id="evo-icon">ğŸ§¬</div>
        <div class="evo-title" id="evo-title">ì§„í™”!</div>
        <div class="evo-desc" id="evo-desc"></div>
        <div class="evo-fx" id="evo-fx"></div>
    </div>

<script>
/* ========================================
   Constants & Configuration
======================================== */
const CONFIG = {
    EVO_THRESHOLD: 25,           // ì§„í™” ì£¼ì‚¬ìœ„ í•„ìš” ì ìˆ˜
    STAGE_THRESHOLD: 2000,
    LAND_HEIGHT: 3000,
    INITIAL_SIZE: 12,
    MAX_SIZE: 80,
    ENEMY_INTERVAL: 3500,
    MAX_ENEMIES: 7,
    MAX_FOODS: 35,
    SAVE_INTERVAL: 20000,
    RUNNER_STAGE_DIST: 300
};

// ì§„í™” íŠ¹ì„± í…Œì´ë¸” (ì£¼ì‚¬ìœ„ ê²°ê³¼ë³„)
const EVO_TRAITS = [
    { id: 'eye_keen', roll: [1,10], part: 'eye', icon: 'ğŸ‘ï¸', name: 'ì˜ˆë¦¬í•œ ëˆˆ', desc: 'ì£¼ë³€ì„ ë” ì˜ ë³¼ ìˆ˜ ìˆë‹¤', effect: 'ì‹œì•¼ +25%', stat: { sight: 1.25 } },
    { id: 'eye_multi', roll: [11,15], part: 'eye', icon: 'ğŸ‘€', name: 'ë³µì•ˆ', desc: 'ì—¬ëŸ¬ ê°œì˜ ëˆˆì´ ìƒê²¼ë‹¤', effect: 'ì‹œì•¼ +50%, ì†ë„ -5%', stat: { sight: 1.5, speed: 0.95 } },
    { id: 'mouth_big', roll: [16,25], part: 'mouth', icon: 'ğŸ‘„', name: 'í° ì…', desc: 'ë” ë§ì´ ë¨¹ì„ ìˆ˜ ìˆë‹¤', effect: 'ì ìˆ˜ +20%', stat: { score: 1.2 } },
    { id: 'mouth_filter', roll: [26,30], part: 'mouth', icon: 'ğŸ«§', name: 'ì—¬ê³¼ ì¥ì¹˜', desc: 'ì‘ì€ ë¨¹ì´ë¥¼ ìë™ í¡ìˆ˜', effect: 'ìë™ ìˆ˜ì§‘ ë²”ìœ„', stat: { autoEat: 30 } },
    { id: 'arm_tentacle', roll: [31,40], part: 'arm', icon: 'ğŸ¦‘', name: 'ì´‰ìˆ˜', desc: 'ë¨¹ì´ë¥¼ ëŒì–´ë‹¹ê¸´ë‹¤', effect: 'ìì„ íš¨ê³¼', stat: { magnet: 80 } },
    { id: 'arm_claw', roll: [41,45], part: 'arm', icon: 'ğŸ¦€', name: 'ì§‘ê²Œ', desc: 'ì ì„ ê³µê²©í•  ìˆ˜ ìˆë‹¤', effect: 'ê³µê²©ë ¥ +1', stat: { attack: 1 } },
    { id: 'leg_fin', roll: [46,55], part: 'leg', icon: 'ğŸŸ', name: 'ì§€ëŠëŸ¬ë¯¸', desc: 'ë¹ ë¥´ê²Œ í—¤ì—„ì¹œë‹¤', effect: 'ì†ë„ +15%', stat: { speed: 1.15 } },
    { id: 'leg_jet', roll: [56,60], part: 'leg', icon: 'ğŸ’¨', name: 'ì œíŠ¸ ì¶”ì§„', desc: 'ìˆœê°„ ê°€ì† ê°€ëŠ¥', effect: 'ëŒ€ì‹œ ê°•í™”', stat: { dash: 1.5 } },
    { id: 'tail_whip', roll: [61,70], part: 'tail', icon: 'ğŸ', name: 'ê¼¬ë¦¬ ì±„ì°', desc: 'ê¼¬ë¦¬ë¡œ ëŒ€ì‹œí•œë‹¤', effect: 'ëŒ€ì‹œ íšë“', stat: { canDash: true } },
    { id: 'tail_poison', roll: [71,75], part: 'tail', icon: 'ğŸ¦‚', name: 'ë…ì¹¨', desc: 'ì ì—ê²Œ ë… í”¼í•´', effect: 'ë… ê³µê²©', stat: { poison: true } },
    { id: 'shell', roll: [76,82], part: 'shell', icon: 'ğŸš', name: 'ë³´í˜¸ë§‰', desc: 'í•œ ë²ˆ í”¼í•´ë¥¼ ë§‰ëŠ”ë‹¤', effect: 'ì‹¤ë“œ +1', stat: { shield: 1 } },
    { id: 'antenna', roll: [83,88], part: 'antenna', icon: 'ğŸ“¡', name: 'ë”ë“¬ì´', desc: 'ë¨¹ì´ë¥¼ ê°ì§€í•œë‹¤', effect: 'íƒì§€ ë²”ìœ„ +30%', stat: { detect: 1.3 } },
    { id: 'ear', roll: [89,93], part: 'ear', icon: 'ğŸ‘‚', name: 'ì²­ê° ê¸°ê´€', desc: 'ì ì˜ ì›€ì§ì„ì„ ê°ì§€', effect: 'ì  í‘œì‹œ', stat: { enemySense: true } },
    { id: 'nose', roll: [94,97], part: 'nose', icon: 'ğŸ‘ƒ', name: 'í›„ê° ê¸°ê´€', desc: 'ë¨¹ì´ë¥¼ ë” ì˜ ì°¾ëŠ”ë‹¤', effect: 'ë¨¹ì´ í‘œì‹œ', stat: { foodSense: true } },
    { id: 'brain', roll: [98,100], part: 'brain', icon: 'ğŸ§ ', name: 'ì›ì‹œ ë‡Œ', desc: 'ì§€ëŠ¥ì´ ìƒê²¼ë‹¤!', effect: 'ê²½í—˜ì¹˜ +30%', stat: { exp: 1.3 } }
];

const ENVS = [
    { id: 'ocean', name: 'ì›ì‹œ í•´ì–‘', icon: 'ğŸŒŠ', range: [1,16], colors: { bg1: '#001a33', bg2: '#003366', particle: '#00aaff', food: '#00ff88', enemy: '#ff4444' }, desc: 'ë°”ë‹¤ëŠ” ìƒëª…ì˜ ìš”ëŒ.', weak: 'ê±´ì¡°í•¨ì€ ì¹˜ëª…ì .', creatures: ['ğŸ¦ ','ğŸ«§','ğŸ’§','ğŸŒ€'] },
    { id: 'hydrothermal', name: 'ì—´ìˆ˜êµ¬', icon: 'ğŸ”¥', range: [17,32], colors: { bg1: '#1a0a00', bg2: '#4d1a00', particle: '#ff6600', food: '#ffaa00', enemy: '#00ffff' }, desc: 'ê·¹í•œ í™˜ê²½ì´ ì¼ìƒ.', weak: 'í‰ì˜¨í•¨ì´ ë¶ˆì•ˆ.', creatures: ['ğŸ”´','ğŸŸ ','ğŸ’¥','âš¡'] },
    { id: 'ice', name: 'ì–¼ìŒ ë°”ë‹¤', icon: 'ğŸ§Š', range: [33,48], colors: { bg1: '#0a1a2e', bg2: '#1a3a5e', particle: '#88ddff', food: '#aaeeff', enemy: '#ff6666' }, desc: 'íš¨ìœ¨ì˜ ë‹¬ì¸.', weak: 'ëœ¨ê±°ì›€ì€ ì¹˜ëª…ì .', creatures: ['â„ï¸','ğŸ”µ','ğŸ’ ','ğŸ«§'] },
    { id: 'magma', name: 'ë§ˆê·¸ë§ˆ í˜¸ìˆ˜', icon: 'ğŸŒ‹', range: [49,64], colors: { bg1: '#1a0000', bg2: '#4d0000', particle: '#ff3300', food: '#ffff00', enemy: '#00aaff' }, desc: 'ìš©ì•”ì´ ë†€ì´í„°.', weak: 'ì–¼ìŒì´ ë¬´ë¤.', creatures: ['ğŸ”¥','ğŸŸ¡','â­','ğŸ’›'] },
    { id: 'atmosphere', name: 'ëŒ€ê¸° ë¶€ìœ ', icon: 'â˜ï¸', range: [65,80], colors: { bg1: '#1a1033', bg2: '#2d1a4d', particle: '#cc88ff', food: '#ffaaff', enemy: '#ff4444' }, desc: 'í•˜ëŠ˜ì„ ë‚˜ëŠ” ì.', weak: 'ë¬´ê±°ì›€ì´ ì .', creatures: ['ğŸ’œ','ğŸŸ£','âœ¨','ğŸ’«'] },
    { id: 'toxic', name: 'ë…ì„± ëŠª', icon: 'ğŸ’€', range: [81,100], colors: { bg1: '#0a1a0a', bg2: '#1a3a1a', particle: '#88ff00', food: '#aaff44', enemy: '#ff00ff' }, desc: 'ë…ì´ ê³§ ì•½.', weak: 'ê¹¨ë—í•¨ì´ ë¶ˆí¸.', creatures: ['ğŸŸ¢','ğŸ’š','ğŸ§ª','â˜¢ï¸'] }
];

/* ========================================
   Audio System
======================================== */
const Audio = (() => {
    let ctx = null;
    const settings = { master: 0.7, sfx: 0.8, on: true };
    
    const init = () => { if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)(); if (ctx.state === 'suspended') ctx.resume(); };
    const tone = (freq, dur, type = 'sine', v = 0.3) => {
        if (!settings.on || !ctx) return;
        const osc = ctx.createOscillator(), gain = ctx.createGain();
        osc.connect(gain); gain.connect(ctx.destination);
        osc.type = type; osc.frequency.value = freq;
        gain.gain.setValueAtTime(settings.master * settings.sfx * v, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + dur);
        osc.start(); osc.stop(ctx.currentTime + dur);
    };
    
    const playEat = () => { tone(500, 0.08); setTimeout(() => tone(700, 0.1), 50); };
    const playJump = () => { tone(400, 0.1); setTimeout(() => tone(550, 0.08), 50); };
    const playWind = () => { tone(600, 0.15); setTimeout(() => tone(900, 0.2), 80); setTimeout(() => tone(1200, 0.15), 160); };
    const playEatBig = () => { tone(400, 0.12); setTimeout(() => tone(600, 0.12), 70); setTimeout(() => tone(800, 0.15), 140); };
    const playClick = () => { tone(500, 0.05, 'sine', 0.15); };
    const playDice = () => { for (let i = 0; i < 8; i++) setTimeout(() => tone(200 + Math.random() * 400, 0.05, 'square', 0.15), i * 50); };
    const playResult = () => { tone(400, 0.12); setTimeout(() => tone(600, 0.12), 100); setTimeout(() => tone(800, 0.15), 200); };
    const playEvolve = () => { [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => tone(f, 0.25, 'sine', 0.35), i * 100)); };
    const playDeath = () => { [400, 300, 200, 100].forEach((f, i) => setTimeout(() => tone(f, 0.25, 'sawtooth', 0.3), i * 120)); };
    const playWin = () => { [523, 659, 784, 1047, 1318].forEach((f, i) => setTimeout(() => tone(f, 0.35, 'sine', 0.4), i * 130)); };
    const playDash = () => { tone(700, 0.08); tone(900, 0.06); };
    const playLand = () => { tone(300, 0.1, 'square', 0.15); };
    const playCollect = () => { tone(800, 0.08); tone(1000, 0.1); };
    
    const load = () => { try { Object.assign(settings, JSON.parse(localStorage.getItem('bokluck_audio') || '{}')); } catch{} };
    const save = () => { localStorage.setItem('bokluck_audio', JSON.stringify(settings)); };
    load();
    return { init, settings, save, playEat, playJump, playWind, playEatBig, playClick, playDice, playResult, playEvolve, playDeath, playWin, playDash, playLand, playCollect };
})();

/* ========================================
   Settings & Save System
======================================== */
const Settings = (() => {
    const defaults = { joyRight: true };
    let current = { ...defaults };
    const load = () => { try { Object.assign(current, JSON.parse(localStorage.getItem('bokluck_settings') || '{}')); } catch{} };
    const save = () => { localStorage.setItem('bokluck_settings', JSON.stringify(current)); };
    const get = k => current[k];
    const set = (k, v) => { current[k] = v; save(); };
    load();
    return { get, set, save };
})();

const Save = (() => {
    const KEY = 'bokluck_save_', MAX = 5;
    const create = () => ({
        v: 7, created: Date.now(), updated: Date.now(), playTime: 0,
        stage: 0, tutDone: false, name: null, score: 0,
        dna: { origin: null }, design: null,
        traits: [],  // íšë“í•œ íŠ¹ì„± ID ëª©ë¡
        stats: { size: CONFIG.INITIAL_SIZE, speed: 3, eaten: 0, deaths: 0, maxSize: CONFIG.INITIAL_SIZE, maxH: 0, evoPoints: 0, shield: 0 },
        runnerStage: 0, runnerEvo: 0
    });
    const get = i => { try { return JSON.parse(localStorage.getItem(KEY + i)); } catch { return null; } };
    const set = (i, d) => { d.updated = Date.now(); localStorage.setItem(KEY + i, JSON.stringify(d)); };
    const del = i => localStorage.removeItem(KEY + i);
    const all = () => Array.from({ length: MAX }, (_, i) => get(i));
    const fmt = ts => ts ? new Date(ts).toLocaleDateString('ko-KR', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) : '-';
    return { MAX, create, get, set, del, all, fmt };
})();

/* ========================================
   Game State
======================================== */
let G = { slot: null, data: null, start: 0 };
let canvas, ctx, gameLoop = null;

const load = i => { G.slot = i; G.data = Save.get(i); G.start = Date.now(); };
const saveGame = () => { if (G.slot !== null && G.data) { G.data.playTime += Date.now() - G.start; G.start = Date.now(); Save.set(G.slot, G.data); } };
const newGame = i => { G.slot = i; G.data = Save.create(); G.start = Date.now(); Save.set(i, G.data); };

const envByRoll = r => ENVS.find(e => r >= e.range[0] && r <= e.range[1]);
const envById = id => ENVS.find(e => e.id === id);

const getTraitById = id => EVO_TRAITS.find(t => t.id === id);
const getTraitByRoll = r => EVO_TRAITS.find(t => r >= t.roll[0] && r <= t.roll[1]);
const hasTrait = id => G.data?.traits?.includes(id);
const traitCount = () => G.data?.traits?.length || 0;

// íŠ¹ì„± ê¸°ë°˜ ìŠ¤íƒ¯ ê³„ì‚°
const calcStats = () => {
    const base = { speed: 1, score: 1, sight: 1, magnet: 0, autoEat: 0, dash: 1, canDash: false, shield: 0, detect: 1, exp: 1, attack: 0, poison: false, enemySense: false, foodSense: false };
    if (!G.data?.traits) return base;
    G.data.traits.forEach(id => {
        const t = getTraitById(id);
        if (t?.stat) {
            Object.keys(t.stat).forEach(k => {
                if (typeof base[k] === 'boolean') base[k] = base[k] || t.stat[k];
                else if (k === 'magnet' || k === 'autoEat' || k === 'shield' || k === 'attack') base[k] += t.stat[k];
                else base[k] *= t.stat[k];
            });
        }
    });
    return base;
};

// íŠ¹ì„± ê¸°ë°˜ ì™¸ëª¨ (íŒŒì¸  ê°œìˆ˜ ê³„ì‚°)
const getAppearance = () => {
    const parts = { eye: 0, mouth: 0, arm: 0, leg: 0, tail: 0, antenna: 0, ear: 0, nose: 0, shell: 0, brain: 0 };
    if (!G.data?.traits) return parts;
    G.data.traits.forEach(id => {
        const t = getTraitById(id);
        if (t?.part && parts[t.part] !== undefined) parts[t.part]++;
    });
    return parts;
};

/* ========================================
   UI Helpers
======================================== */
const app = document.getElementById('app');

const createStars = () => {
    const c = document.getElementById('stars-bg');
    c.innerHTML = '';
    for (let i = 0; i < 60; i++) {
        const s = document.createElement('div');
        s.className = 'star';
        const size = Math.random() * 2 + 1;
        s.style.cssText = `left:${Math.random()*100}%;top:${Math.random()*100}%;width:${size}px;height:${size}px;--dur:${Math.random()*3+2}s;animation-delay:${Math.random()*3}s;`;
        c.appendChild(s);
    }
};

const toast = (msg, type = 'info') => {
    const c = document.getElementById('toasts');
    const t = document.createElement('div');
    t.className = `toast ${type}`;
    const icons = { success: 'âœ…', danger: 'ğŸ’€', info: 'â„¹ï¸', warning: 'âš ï¸' };
    t.innerHTML = `<span>${icons[type] || 'â„¹ï¸'}</span><span>${msg}</span>`;
    c.appendChild(t);
    setTimeout(() => t.remove(), 3000);
};

const showEvo = (icon, title, desc, fx) => {
    const el = document.getElementById('evo-popup');
    document.getElementById('evo-icon').textContent = icon;
    document.getElementById('evo-title').textContent = title;
    document.getElementById('evo-desc').textContent = desc;
    document.getElementById('evo-fx').textContent = fx;
    el.classList.add('show');
    Audio.playEvolve();
    setTimeout(() => el.classList.remove('show'), 2000);
};

let cleanupFns = [];
const addCleanup = fn => cleanupFns.push(fn);
const cleanup = () => { cleanupFns.forEach(fn => fn()); cleanupFns = []; };

/* ========================================
   Story System
======================================== */
const STORIES = {
    intro: [
        { icon: 'ğŸŒŒ', title: 'íƒœì´ˆì—...', text: 'ëì—†ì´ í¼ì³ì§„ <span class="hl">ìš°ì£¼ì˜ ì‹¬ì—°</span>...<br>ì•„ì£¼ ì‘ì€ <span class="gold">ë¶ˆê½ƒ</span>ì´ í”¼ì–´ì˜¤ë¥´ë ¤ í•œë‹¤.' },
        { icon: 'âœ¨', title: 'ì˜ì‹ì˜ íƒ„ìƒ', text: 'ë‹¹ì‹ ì€ ì•„ì§ <span class="hl">ì•„ë¬´ê²ƒë„ ì•„ë‹ˆë‹¤</span>.<br>ì˜¤ì§ <span class="gold">ì¡´ì¬í•˜ê³ ì í•˜ëŠ” ì˜ì§€</span>ë§Œì´ ê¹œë¹¡ì¸ë‹¤.' },
        { icon: 'ğŸ²', title: 'ìš´ëª…ì˜ ì£¼ì‚¬ìœ„', text: '<span class="hl">BOK(ë³µ)</span>ê³¼ <span class="danger">LUCK(ìš´)</span>ì´ ëª¨ë“  ê²ƒì„ ê²°ì •í•œë‹¤.<br>ì§„í™”í•  ë•Œë§ˆë‹¤ <span class="gold">ì£¼ì‚¬ìœ„</span>ê°€ ìš´ëª…ì„ ì •í•œë‹¤.' }
    ],
    afterBirth: env => [
        { icon: env.icon, title: env.name, text: `<span class="hl">${env.name}</span>ì—ì„œ íƒœì–´ë‚¬ë‹¤.<br><span class="gold">"${env.desc}"</span><br><span class="danger">âš ï¸ ${env.weak}</span>` },
        { icon: 'ğŸ¦ ', title: 'ì²« ë²ˆì§¸ ìƒëª…', text: 'ì•„ì£¼ ì‘ì€ <span class="hl">í•˜ë‚˜ì˜ ì„¸í¬</span>.<br>ì‚´ì•„ë‚¨ìœ¼ë ¤ë©´ <span class="gold">ë¨¹ì–´ì•¼ í•œë‹¤</span>.' },
        { icon: 'ğŸ²', title: 'ì§„í™”ì˜ ë²•ì¹™', text: 'ì¶©ë¶„íˆ ë¨¹ìœ¼ë©´ <span class="gold">ì§„í™” ì£¼ì‚¬ìœ„</span>ë¥¼ ë˜ì§ˆ ìˆ˜ ìˆë‹¤!<br>ì£¼ì‚¬ìœ„ê°€ <span class="hl">ì–´ë–¤ íŠ¹ì„±</span>ì„ ì¤„ì§€ ê²°ì •í•œë‹¤.' }
    ],
    multi: [
        { icon: 'ğŸ§¬', title: 'ë‹¤ì„¸í¬ ì§„í™”!', text: 'ë§ˆì¹¨ë‚´ <span class="hl">ë‹¨ì¼ ì„¸í¬</span>ì˜ í•œê³„ë¥¼ ë„˜ì–´ì„°ë‹¤!' },
        { icon: 'ğŸ”ï¸', title: 'ìƒˆë¡œìš´ ë„ì „', text: 'ë°”ë‹¤ ê¹Šì€ ê³³ì—ì„œ <span class="gold">ìœ¡ì§€</span>ê¹Œì§€ ì˜¬ë¼ê°€ì•¼ í•œë‹¤.' },
        { icon: 'â¬†ï¸', title: 'ì í”„!', text: '<span class="hl">ë°œíŒ</span>ì„ ë°Ÿê³  ìœ„ë¡œ!<br>ğŸŒªï¸ í† ë„¤ì´ë„ë¥¼ íƒ€ë©´ ë” ë†’ì´!' }
    ],
    runner: [
        { icon: 'ğŸƒ', title: 'ìœ¡ì§€ ë„ì°©!', text: 'ë§ˆì¹¨ë‚´ <span class="hl">ìœ¡ì§€</span>ì— ë„ì°©í–ˆë‹¤!' },
        { icon: 'ğŸŒ', title: 'ì§„í™”ì˜ ì—¬ì •', text: 'ë‹¬ë¦¬ë©´ì„œ <span class="gold">ì•„ì´í…œ</span>ì„ ëª¨ì•„<br><span class="hl">ë¬¸ëª…</span>ì„ í–¥í•´ ì§„í™”í•˜ë¼!' }
    ]
};

const renderStory = (id, done = null) => {
    let seq = STORIES[id];
    if (typeof seq === 'function') seq = seq(envById(G.data?.dna?.origin));
    let idx = 0;
    
    const render = () => {
        const s = seq[idx];
        const last = idx === seq.length - 1;
        let btnText = 'ë‹¤ìŒ â†’';
        if (last) {
            if (id === 'multi') btnText = 'ğŸ”ï¸ ìœ¡ì§€ë¡œ!';
            else if (id === 'runner') btnText = 'ğŸƒ ë‹¬ë¦¬ê¸°!';
            else btnText = 'ì‹œì‘í•˜ê¸° â†’';
        }
        
        app.innerHTML = `
            <div class="page-center"><div class="page-content">
                <div class="page-icon">${s.icon}</div>
                <h2 class="page-title">${s.title}</h2>
                <div class="page-text">${s.text}</div>
                <div class="dots">${seq.map((_, i) => `<div class="dot ${i < idx ? 'done' : ''} ${i === idx ? 'active' : ''}"></div>`).join('')}</div>
                <button class="btn btn-energy" id="btn-next">${btnText}</button>
            </div></div>
        `;
        
        document.getElementById('btn-next').onclick = () => {
            Audio.playClick();
            if (last) {
                if (done) done();
                else if (id === 'intro') renderDice();
                else if (id === 'afterBirth') { G.data.tutDone = true; saveGame(); startCellWorld(); }
                else if (id === 'multi') startClimb();
                else if (id === 'runner') startRunner();
            } else { idx++; render(); }
        };
    };
    render();
};

/* ========================================
   Dice Roll (Origin)
======================================== */
const renderDice = () => {
    let rolling = false;
    
    app.innerHTML = `
        <div class="page-center"><div class="page-content">
            <h2 class="page-title">ğŸ² ìš´ëª…ì˜ ì£¼ì‚¬ìœ„</h2>
            <p style="color:var(--text-secondary);margin-bottom:16px;">íƒœì–´ë‚  ê³³ì´ ê²°ì •ë©ë‹ˆë‹¤</p>
            <div class="dice-box" id="dice">ğŸ²</div>
            <div id="result"></div>
            <button class="btn btn-energy btn-block" id="btn-roll">ìš´ëª…ì„ ë°›ì•„ë“¤ì¸ë‹¤</button>
        </div></div>
    `;
    
    const dice = document.getElementById('dice');
    const result = document.getElementById('result');
    const btn = document.getElementById('btn-roll');
    
    btn.onclick = () => {
        if (rolling) return;
        rolling = true; btn.disabled = true; btn.textContent = 'ê²°ì • ì¤‘...';
        dice.classList.add('rolling');
        Audio.playDice();
        
        const anim = setInterval(() => { dice.textContent = Math.floor(Math.random() * 100) + 1; }, 50);
        
        setTimeout(() => {
            clearInterval(anim);
            dice.classList.remove('rolling');
            const roll = Math.floor(Math.random() * 100) + 1;
            const env = envByRoll(roll);
            
            dice.textContent = roll;
            dice.style.cssText = 'font-size:3rem;font-family:Orbitron;font-weight:900;color:var(--neon-cyan);text-shadow:0 0 25px var(--neon-cyan);';
            Audio.playResult();
            
            result.innerHTML = `<div style="text-align:center;margin:16px 0;">
                <div style="font-size:3rem;margin-bottom:6px;">${env.icon}</div>
                <div style="font-family:Orbitron;font-size:1.2rem;font-weight:700;margin-bottom:4px;">${env.name}</div>
                <div style="color:var(--text-secondary);font-size:0.85rem;">${env.desc}</div>
            </div>`;
            
            btn.disabled = false;
            btn.textContent = 'ì´ ìš´ëª…ì„ ë°›ì•„ë“¤ì¸ë‹¤';
            btn.onclick = () => {
                Audio.playClick();
                G.data.dna.origin = env.id;
                G.data.stage = 1;
                G.data.score = 0;
                G.data.name = genName(env.id);
                G.data.design = genDesign(env.id);
                G.data.traits = [];
                G.data.stats = { size: CONFIG.INITIAL_SIZE, speed: 3, eaten: 0, deaths: G.data.stats?.deaths || 0, maxSize: CONFIG.INITIAL_SIZE, maxH: 0, evoPoints: 0, shield: 0 };
                saveGame();
                renderStory('afterBirth');
            };
        }, 1500);
    };
};

const genName = id => {
    const pre = { ocean: ['í‘¸ë¥¸','ê¹Šì€','íë¥´ëŠ”'], hydrothermal: ['ëœ¨ê±°ìš´','íƒ€ì˜¤ë¥´ëŠ”','ë¶ˆê½ƒ'], ice: ['ì°¨ê°€ìš´','ì–¼ì–´ë¶™ì€','ì„œë¦¬'], magma: ['ì‘ì—´í•˜ëŠ”','ìš©ì•”','ë¶‰ì€'], atmosphere: ['ë– ë„ëŠ”','ë°”ëŒì˜','í•˜ëŠ˜'], toxic: ['ë…ì˜','ë§¹ë…','ì‚°ì„±'] };
    const suf = ['ì˜ì‹','ì„¸í¬','ì¡´ì¬','ì˜í˜¼','íŒŒë™'];
    const p = pre[id] || pre.ocean;
    return p[Math.floor(Math.random() * p.length)] + ' ' + suf[Math.floor(Math.random() * suf.length)];
};

const genDesign = id => {
    const cols = { ocean: ['#00b4d8','#0077b6'], hydrothermal: ['#ff6b35','#d62828'], ice: ['#a8dadc','#457b9d'], magma: ['#ff4800','#ff8500'], atmosphere: ['#e0aaff','#9d4edd'], toxic: ['#70e000','#38b000'] };
    const c = cols[id] || cols.ocean;
    return { primary: c[0], secondary: c[1], wobble: 0.5 + Math.random() * 0.5 };
};

/* ========================================
   Evolution Dice (Trait)
======================================== */
let evoDiceResolve = null;

const showEvoDice = () => {
    return new Promise(resolve => {
        evoDiceResolve = resolve;
        
        const overlay = document.createElement('div');
        overlay.className = 'evo-dice-overlay';
        overlay.id = 'evo-dice-overlay';
        overlay.innerHTML = `
            <div class="evo-dice-box">
                <div class="evo-dice-title">ğŸ² ì§„í™” ì£¼ì‚¬ìœ„!</div>
                <div class="evo-dice-sub">ì–´ë–¤ íŠ¹ì„±ì„ ì–»ê²Œ ë ê¹Œ?</div>
                <div class="dice-box" id="evo-dice">ğŸ²</div>
                <div id="trait-result"></div>
                <button class="btn btn-energy btn-block" id="btn-evo-roll">ì£¼ì‚¬ìœ„ë¥¼ ë˜ì§„ë‹¤!</button>
            </div>
        `;
        document.body.appendChild(overlay);
        
        const dice = document.getElementById('evo-dice');
        const resultDiv = document.getElementById('trait-result');
        const btn = document.getElementById('btn-evo-roll');
        let rolling = false;
        
        btn.onclick = () => {
            if (rolling) return;
            rolling = true; btn.disabled = true; btn.textContent = 'ìš´ëª… ê²°ì • ì¤‘...';
            dice.classList.add('rolling');
            Audio.playDice();
            
            const anim = setInterval(() => { dice.textContent = Math.floor(Math.random() * 100) + 1; }, 50);
            
            setTimeout(() => {
                clearInterval(anim);
                dice.classList.remove('rolling');
                
                const roll = Math.floor(Math.random() * 100) + 1;
                const trait = getTraitByRoll(roll);
                
                dice.textContent = roll;
                dice.style.cssText = 'font-size:3rem;font-family:Orbitron;font-weight:900;color:var(--neon-cyan);text-shadow:0 0 25px var(--neon-cyan);';
                Audio.playResult();
                
                resultDiv.innerHTML = `
                    <div class="trait-result">
                        <div class="trait-icon">${trait.icon}</div>
                        <div class="trait-name">${trait.name}</div>
                        <div class="trait-desc">${trait.desc}</div>
                        <div class="trait-effect">âœ¨ ${trait.effect}</div>
                    </div>
                `;
                
                btn.textContent = 'ì§„í™” ì™„ë£Œ!';
                btn.onclick = () => {
                    Audio.playClick();
                    overlay.remove();
                    if (evoDiceResolve) evoDiceResolve(trait);
                };
            }, 1500);
        };
    });
};

/* ========================================
   Cell World Game
======================================== */
let player, foods = [], enemies = [], particles = [];
let joyPos = { x: 0, y: 0 }, joyActive = false, keys = {};
let lastSpawn = 0, dashCD = 0, dashing = false;
let canEvolve = false;

const startCellWorld = () => {
    cleanup();
    const env = envById(G.data.dna.origin);
    const joyRight = Settings.get('joyRight');
    const stats = calcStats();
    
    canEvolve = false;
    
    app.innerHTML = `
        <canvas id="game-canvas"></canvas>
        <div class="hud-top">
            <div class="hud-panel" style="min-width:120px">
                <div class="hud-name">${G.data.name}</div>
                <div class="hud-row"><span>âš¡</span><span class="hud-val" id="h-score">${G.data.score}</span><span class="hud-label">ì ìˆ˜</span></div>
                <div class="hud-row"><span>ğŸ§¬</span><span class="hud-val" id="h-traits">${traitCount()}</span><span class="hud-label">íŠ¹ì„±</span></div>
                <div class="size-bar"><span style="font-size:0.6rem">ğŸ“</span><div class="size-track"><div class="size-fill" id="h-size" style="width:${(G.data.stats.size/CONFIG.MAX_SIZE)*100}%"></div></div><span class="size-num" id="h-sizeN">${Math.round(G.data.stats.size)}</span></div>
            </div>
            <div class="hud-panel" style="max-width:150px">
                <div style="font-family:Orbitron;font-size:0.55rem;color:var(--text-muted);margin-bottom:4px;">ğŸ² ì§„í™” ê²Œì´ì§€</div>
                <div class="prog-section"><div class="prog-label"><span class="prog-left">ë‹¤ìŒ ì§„í™”</span><span class="prog-right" id="h-evoP">${G.data.stats.evoPoints}/${CONFIG.EVO_THRESHOLD}</span></div><div class="prog-track"><div class="prog-fill evo" id="h-evoB" style="width:${(G.data.stats.evoPoints/CONFIG.EVO_THRESHOLD)*100}%"></div></div></div>
                <div class="parts-grid" id="h-traits-list"></div>
            </div>
            <div class="hud-btns">
                <button class="hud-btn" id="btn-home">ğŸ </button>
                <button class="hud-btn" id="btn-pause">â¸ï¸</button>
            </div>
        </div>
        <div class="hud-bottom"><div class="stage-bar"><div class="stage-row"><span class="stage-cur">ğŸ¦  ì„¸í¬</span><span class="stage-next">ë‹¤ì„¸í¬: <span id="h-stageP">${G.data.score}/${CONFIG.STAGE_THRESHOLD}</span></span></div><div class="prog-track"><div class="prog-fill stage" id="h-stageB" style="width:${(G.data.score/CONFIG.STAGE_THRESHOLD)*100}%"></div></div></div></div>
        <div class="controls ${joyRight ? 'joy-right' : ''}">
            <div class="joystick" id="joy"><div class="joy-base"></div><div class="joy-knob" id="joy-knob"></div></div>
            <button class="action-btn ${stats.canDash ? '' : 'disabled'}" id="btn-action">ğŸ²</button>
        </div>
    `;
    
    updateTraitsUI();
    
    canvas = document.getElementById('game-canvas');
    ctx = canvas.getContext('2d');
    resize();
    
    window.addEventListener('resize', resize);
    addCleanup(() => window.removeEventListener('resize', resize));
    
    player = { x: canvas.width / 2, y: canvas.height / 2, size: G.data.stats.size, vx: 0, vy: 0 };
    foods = []; enemies = []; particles = [];
    spawnFoods(CONFIG.MAX_FOODS);
    
    setupCellControls();
    setupCellHUD();
    
    lastSpawn = Date.now();
    gameLoop = requestAnimationFrame(updateCell);
};

const updateTraitsUI = () => {
    const el = document.getElementById('h-traits-list');
    if (!el) return;
    let html = '';
    (G.data.traits || []).slice(-6).forEach(id => {
        const t = getTraitById(id);
        if (t) html += `<div class="part-badge on" title="${t.name}"><span>${t.icon}</span></div>`;
    });
    el.innerHTML = html || '<span style="font-size:0.55rem;color:var(--text-muted)">íŠ¹ì„± ì—†ìŒ</span>';
};

const resize = () => { if (canvas) { canvas.width = window.innerWidth; canvas.height = window.innerHeight; } };

const spawnFoods = n => {
    const env = envById(G.data.dna.origin);
    for (let i = 0; i < n; i++) {
        foods.push({
            x: Math.random() * canvas.width, y: Math.random() * canvas.height,
            size: 4 + Math.random() * 8, color: env.colors.food,
            vx: (Math.random() - 0.5) * 0.3, vy: (Math.random() - 0.5) * 0.3,
            type: env.creatures[Math.floor(Math.random() * env.creatures.length)]
        });
    }
};

const spawnEnemy = () => {
    const ps = player.size;
    const smaller = Math.random() < 0.4;
    let sz = smaller ? ps * (0.3 + Math.random() * 0.5) : ps * (1.2 + Math.random() * 0.8);
    sz = Math.max(8, Math.min(sz, 100));
    let x, y;
    const side = Math.floor(Math.random() * 4);
    if (side === 0) { x = -50; y = Math.random() * canvas.height; }
    else if (side === 1) { x = canvas.width + 50; y = Math.random() * canvas.height; }
    else if (side === 2) { x = Math.random() * canvas.width; y = -50; }
    else { x = Math.random() * canvas.width; y = canvas.height + 50; }
    enemies.push({ x, y, size: sz, speed: 1 + Math.random() * 1.5, angle: Math.random() * Math.PI * 2, wobble: Math.random() });
};

const setupCellControls = () => {
    const joy = document.getElementById('joy');
    const knob = document.getElementById('joy-knob');
    
    const move = (cx, cy) => {
        const r = joy.getBoundingClientRect();
        const cX = r.left + r.width / 2, cY = r.top + r.height / 2;
        const maxD = r.width / 2 - 20;
        let dx = cx - cX, dy = cy - cY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > maxD) { dx = dx / dist * maxD; dy = dy / dist * maxD; }
        knob.style.transform = `translate(${dx}px, ${dy}px)`;
        joyPos = { x: dx / maxD, y: dy / maxD };
    };
    const end = () => { joyActive = false; knob.style.transform = ''; joyPos = { x: 0, y: 0 }; };
    
    joy.addEventListener('touchstart', e => { e.preventDefault(); joyActive = true; move(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    joy.addEventListener('touchmove', e => { e.preventDefault(); if (joyActive) move(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    joy.addEventListener('touchend', end);
    joy.addEventListener('mousedown', e => { joyActive = true; move(e.clientX, e.clientY); });
    window.addEventListener('mousemove', e => { if (joyActive) move(e.clientX, e.clientY); });
    window.addEventListener('mouseup', end);
    window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if (e.key === ' ') handleAction(); });
    window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
    
    document.getElementById('btn-action').onclick = handleAction;
};

const handleAction = async () => {
    const stats = calcStats();
    const btn = document.getElementById('btn-action');
    
    if (canEvolve) {
        // ì§„í™” ì£¼ì‚¬ìœ„!
        cancelAnimationFrame(gameLoop); gameLoop = null;
        const trait = await showEvoDice();
        G.data.traits.push(trait.id);
        G.data.stats.evoPoints = 0;
        canEvolve = false;
        saveGame();
        showEvo(trait.icon, trait.name + ' íšë“!', trait.desc, trait.effect);
        setTimeout(() => {
            updateTraitsUI();
            btn.classList.remove('ready');
            btn.textContent = stats.canDash ? 'ğŸ’¨' : 'ğŸ²';
            gameLoop = requestAnimationFrame(updateCell);
        }, 2200);
    } else if (stats.canDash && dashCD <= 0 && !dashing) {
        // ëŒ€ì‹œ
        dashing = true; dashCD = 3000;
        Audio.playDash();
        const spd = 15 * stats.dash;
        const dir = { x: joyPos.x || (keys.d ? 1 : keys.a ? -1 : 0), y: joyPos.y || (keys.s ? 1 : keys.w ? -1 : 0) };
        const len = Math.sqrt(dir.x * dir.x + dir.y * dir.y) || 1;
        player.vx = dir.x / len * spd; player.vy = dir.y / len * spd;
        setTimeout(() => { dashing = false; }, 200);
    }
};

const setupCellHUD = () => {
    document.getElementById('btn-home').onclick = () => { Audio.playClick(); if (confirm('í™ˆìœ¼ë¡œ?')) { cancelAnimationFrame(gameLoop); gameLoop = null; saveGame(); renderSaves(); } };
    document.getElementById('btn-pause').onclick = () => {
        Audio.playClick();
        const btn = document.getElementById('btn-pause');
        if (gameLoop) { cancelAnimationFrame(gameLoop); gameLoop = null; btn.textContent = 'â–¶ï¸'; }
        else { gameLoop = requestAnimationFrame(updateCell); btn.textContent = 'â¸ï¸'; }
    };
};

const updateCell = () => {
    if (!canvas || !ctx) return;
    const env = envById(G.data.dna.origin);
    const stats = calcStats();
    
    if (dashCD > 0) dashCD -= 16;
    
    let ix = joyPos.x, iy = joyPos.y;
    if (keys.w || keys.arrowup) iy = -1;
    if (keys.s || keys.arrowdown) iy = 1;
    if (keys.a || keys.arrowleft) ix = -1;
    if (keys.d || keys.arrowright) ix = 1;
    
    const spd = G.data.stats.speed * stats.speed;
    if (!dashing) { player.vx = ix * spd; player.vy = iy * spd; }
    else { player.vx *= 0.95; player.vy *= 0.95; }
    
    player.x += player.vx; player.y += player.vy;
    player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
    player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));
    
    if (Date.now() - lastSpawn > CONFIG.ENEMY_INTERVAL && enemies.length < CONFIG.MAX_ENEMIES) { spawnEnemy(); lastSpawn = Date.now(); }
    
    const magnet = stats.magnet;
    const autoEat = stats.autoEat;
    
    for (let i = foods.length - 1; i >= 0; i--) {
        const f = foods[i];
        f.x += f.vx; f.y += f.vy;
        if (f.x < -30) f.x = canvas.width + 30;
        if (f.x > canvas.width + 30) f.x = -30;
        if (f.y < -30) f.y = canvas.height + 30;
        if (f.y > canvas.height + 30) f.y = -30;
        
        const dx = player.x - f.x, dy = player.y - f.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (magnet && dist < magnet) { f.x += dx * 0.04; f.y += dy * 0.04; }
        
        const eatDist = autoEat > 0 ? Math.max(player.size + f.size * 0.4, autoEat) : player.size + f.size * 0.4;
        if (dist < eatDist) {
            Audio.playEat();
            player.size = Math.min(CONFIG.MAX_SIZE, player.size + f.size * 0.12);
            G.data.stats.size = player.size;
            G.data.stats.eaten++;
            G.data.stats.evoPoints++;
            G.data.score += Math.floor(f.size * 2 * stats.score * stats.exp);
            foods.splice(i, 1);
            setTimeout(() => { if (foods.length < CONFIG.MAX_FOODS) spawnFoods(1); }, 400);
        }
    }
    
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const dx = player.x - e.x, dy = player.y - e.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const danger = e.size > player.size;
        
        if (danger) { e.x += dx / dist * e.speed * 0.45; e.y += dy / dist * e.speed * 0.45; }
        else { e.x -= dx / dist * e.speed * 0.25; e.y -= dy / dist * e.speed * 0.25; }
        e.angle += (Math.random() - 0.5) * 0.08;
        e.x += Math.cos(e.angle) * e.speed * 0.25;
        e.y += Math.sin(e.angle) * e.speed * 0.25;
        
        if (e.x < -200 || e.x > canvas.width + 200 || e.y < -200 || e.y > canvas.height + 200) { enemies.splice(i, 1); continue; }
        
        if (dist < player.size + e.size * 0.55) {
            if (danger) {
                if (G.data.stats.shield > 0) {
                    G.data.stats.shield--;
                    enemies.splice(i, 1);
                    toast('ğŸ›¡ï¸ ë³´í˜¸ë§‰ì´ í”¼í•´ë¥¼ ë§‰ì•˜ë‹¤!', 'warning');
                } else {
                    gameOverCell(); return;
                }
            } else {
                Audio.playEatBig();
                player.size = Math.min(CONFIG.MAX_SIZE, player.size + e.size * 0.2);
                G.data.stats.size = player.size;
                G.data.stats.eaten++;
                G.data.stats.evoPoints += 3;
                G.data.score += Math.floor(e.size * 4 * stats.score * stats.exp);
                enemies.splice(i, 1);
            }
        }
    }
    
    // ì§„í™” ê°€ëŠ¥ ì²´í¬
    const btn = document.getElementById('btn-action');
    if (G.data.stats.evoPoints >= CONFIG.EVO_THRESHOLD && !canEvolve) {
        canEvolve = true;
        btn.classList.add('ready');
        btn.textContent = 'ğŸ²';
        toast('ğŸ² ì§„í™” ê°€ëŠ¥! ë²„íŠ¼ì„ ëˆŒëŸ¬ ì£¼ì‚¬ìœ„ë¥¼ ë˜ì ¸ë¼!', 'success');
    }
    
    renderCell(env, stats);
    updateCellHUD();
    
    if (G.data.stage === 1 && G.data.score >= CONFIG.STAGE_THRESHOLD && traitCount() >= 3) { evolveMulti(); return; }
    
    gameLoop = requestAnimationFrame(updateCell);
};

const updateCellHUD = () => {
    const $ = id => document.getElementById(id);
    if (!$('h-score')) return;
    $('h-score').textContent = G.data.score;
    $('h-traits').textContent = traitCount();
    $('h-size').style.width = `${(player.size / CONFIG.MAX_SIZE) * 100}%`;
    $('h-sizeN').textContent = Math.round(player.size);
    $('h-evoB').style.width = `${Math.min(100, (G.data.stats.evoPoints / CONFIG.EVO_THRESHOLD) * 100)}%`;
    $('h-evoP').textContent = `${Math.min(G.data.stats.evoPoints, CONFIG.EVO_THRESHOLD)}/${CONFIG.EVO_THRESHOLD}`;
    $('h-stageB').style.width = `${Math.min(100, (G.data.score / CONFIG.STAGE_THRESHOLD) * 100)}%`;
    $('h-stageP').textContent = `${G.data.score}/${CONFIG.STAGE_THRESHOLD}`;
};

const renderCell = (env, stats) => {
    const w = canvas.width, h = canvas.height;
    const bg = ctx.createLinearGradient(0, 0, 0, h);
    bg.addColorStop(0, env.colors.bg1);
    bg.addColorStop(1, env.colors.bg2);
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, w, h);
    
    // ë¨¹ì´ ì„¼ì‹±
    if (stats.foodSense) {
        foods.forEach(f => {
            ctx.strokeStyle = 'rgba(0,255,136,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(f.x, f.y, f.size * 2, 0, Math.PI * 2);
            ctx.stroke();
        });
    }
    
    foods.forEach(f => {
        ctx.font = `${f.size * 1.6}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(f.type, f.x, f.y);
    });
    
    // ì  ì„¼ì‹±
    enemies.forEach(e => {
        if (stats.enemySense && e.size > player.size) {
            ctx.strokeStyle = 'rgba(255,68,68,0.4)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5,5]);
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.size * 1.5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        drawCreature(e, e.size > player.size, env);
    });
    
    drawPlayer();
};

const drawCreature = (e, danger, env) => {
    const t = Date.now() * 0.003;
    ctx.save();
    ctx.translate(e.x, e.y);
    ctx.shadowColor = danger ? '#ff4444' : '#44ff88';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    for (let i = 0; i < 8; i++) {
        const ang = (i / 8) * Math.PI * 2;
        const w = Math.sin(t + i + e.wobble * 10) * 2;
        const r = e.size + w;
        i === 0 ? ctx.moveTo(Math.cos(ang) * r, Math.sin(ang) * r) : ctx.lineTo(Math.cos(ang) * r, Math.sin(ang) * r);
    }
    ctx.closePath();
    ctx.fillStyle = danger ? env.colors.enemy : env.colors.food;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.beginPath(); ctx.arc(0, -e.size * 0.2, e.size * 0.15, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
    ctx.beginPath(); ctx.arc(e.size * 0.03, -e.size * 0.2, e.size * 0.07, 0, Math.PI * 2); ctx.fillStyle = '#222'; ctx.fill();
    ctx.restore();
};

const drawPlayer = () => {
    const d = G.data.design, t = Date.now() * 0.003, s = player.size;
    const parts = getAppearance();
    
    ctx.save();
    ctx.translate(player.x, player.y);
    
    // ë³´í˜¸ë§‰ í‘œì‹œ
    if (G.data.stats.shield > 0) {
        ctx.strokeStyle = 'rgba(0,245,212,0.5)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, s + 8, 0, Math.PI * 2);
        ctx.stroke();
    }
    
    ctx.shadowColor = d.primary;
    ctx.shadowBlur = 18;
    
    // ê¼¬ë¦¬
    if (parts.tail > 0) {
        ctx.strokeStyle = d.primary;
        ctx.lineWidth = Math.max(3, s * 0.07);
        ctx.lineCap = 'round';
        const tw = Math.sin(t * 2) * s * 0.25;
        ctx.beginPath();
        ctx.moveTo(-s * 0.7, 0);
        ctx.bezierCurveTo(-s * 1.1, tw, -s * 1.4, -tw * 0.4, -s * 1.7, tw * 0.3);
        ctx.stroke();
    }
    
    // íŒ”/ì´‰ìˆ˜
    if (parts.arm > 0) {
        ctx.strokeStyle = d.primary;
        ctx.lineWidth = Math.max(2, s * 0.06);
        for (let i = 0; i < parts.arm; i++) {
            const ba = (0.2 + i * 0.2) * (i % 2 === 0 ? 1 : -1) * Math.PI;
            const w = Math.sin(t * 2 + i) * 0.15;
            ctx.beginPath();
            ctx.moveTo(Math.cos(ba) * s * 0.85, Math.sin(ba) * s * 0.85);
            ctx.quadraticCurveTo(Math.cos(ba) * s * 1.3, Math.sin(ba + w) * s * 1.1, Math.cos(ba) * s * 1.5, Math.sin(ba + w * 2) * s * 0.85);
            ctx.stroke();
        }
    }
    
    // ë‹¤ë¦¬
    if (parts.leg > 0) {
        ctx.strokeStyle = d.secondary;
        ctx.lineWidth = Math.max(2, s * 0.05);
        for (let i = 0; i < parts.leg; i++) {
            const ba = Math.PI * 0.5 + (i - (parts.leg - 1) / 2) * 0.2;
            const w = Math.sin(t * 3 + i) * 0.12;
            ctx.beginPath();
            ctx.moveTo(Math.cos(ba) * s * 0.7, Math.sin(ba) * s * 0.7);
            ctx.lineTo(Math.cos(ba + w) * s * 1.3, Math.sin(ba) * s * 1.2);
            ctx.stroke();
        }
    }
    
    // ë”ë“¬ì´
    if (parts.antenna > 0) {
        ctx.strokeStyle = d.primary;
        ctx.lineWidth = 2;
        for (let i = 0; i < parts.antenna; i++) {
            const aa = -Math.PI * 0.35 + i * 0.3;
            ctx.beginPath();
            ctx.moveTo(Math.cos(aa) * s * 0.6, Math.sin(aa) * s * 0.6);
            ctx.quadraticCurveTo(Math.cos(aa) * s * 1.1, Math.sin(aa) * s * 1.0, Math.cos(aa) * s * 1.4, Math.sin(aa + Math.sin(t*3)*0.1) * s * 1.1);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(Math.cos(aa) * s * 1.4, Math.sin(aa + Math.sin(t*3)*0.1) * s * 1.1, 4, 0, Math.PI * 2);
            ctx.fillStyle = d.primary;
            ctx.fill();
        }
    }
    
    // ëª¸í†µ
    ctx.beginPath();
    for (let i = 0; i < 10; i++) {
        const ang = (i / 10) * Math.PI * 2;
        const w = Math.sin(t + i) * 2.5 * d.wobble;
        const r = s + w;
        i === 0 ? ctx.moveTo(Math.cos(ang) * r, Math.sin(ang) * r) : ctx.lineTo(Math.cos(ang) * r, Math.sin(ang) * r);
    }
    ctx.closePath();
    const grad = ctx.createRadialGradient(-s * 0.25, -s * 0.25, 0, 0, 0, s);
    grad.addColorStop(0, d.primary);
    grad.addColorStop(1, d.secondary);
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // ê»ë°ê¸°
    if (parts.shell > 0) {
        ctx.strokeStyle = 'rgba(255,255,255,0.4)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, s * 0.9, -Math.PI * 0.3, Math.PI * 0.3);
        ctx.stroke();
    }
    
    // ê·€
    if (parts.ear > 0) {
        for (let i = 0; i < parts.ear; i++) {
            const side = i % 2 === 0 ? 1 : -1;
            ctx.beginPath();
            ctx.ellipse(side * s * 0.7, -s * 0.4, s * 0.12, s * 0.2, side * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = d.primary;
            ctx.fill();
        }
    }
    
    // ëˆˆ
    const eyeCnt = Math.max(1, parts.eye);
    for (let i = 0; i < eyeCnt; i++) {
        const eX = (i - (eyeCnt - 1) / 2) * 0.3 * s * 0.7, eY = -s * 0.2;
        ctx.beginPath(); ctx.arc(eX, eY, s * 0.18, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
        ctx.beginPath(); ctx.arc(eX + s * 0.03, eY, s * 0.09, 0, Math.PI * 2); ctx.fillStyle = '#222'; ctx.fill();
        ctx.beginPath(); ctx.arc(eX - s * 0.04, eY - s * 0.04, s * 0.03, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255,255,255,0.8)'; ctx.fill();
    }
    
    // ë‡Œ (í›„ê´‘)
    if (parts.brain > 0) {
        ctx.strokeStyle = 'rgba(254,228,64,0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, -s * 0.5, s * 0.3, Math.PI, 0);
        ctx.stroke();
    }
    
    // ì½”
    if (parts.nose > 0) {
        ctx.fillStyle = '#ffcc99';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-s * 0.08, s * 0.12);
        ctx.lineTo(s * 0.08, s * 0.12);
        ctx.closePath();
        ctx.fill();
    }
    
    // ì…
    if (parts.mouth > 0) {
        ctx.strokeStyle = d.secondary;
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.arc(0, s * 0.2, s * 0.12, 0.2, Math.PI - 0.2);
        ctx.stroke();
    }
    
    ctx.restore();
};

const gameOverCell = () => {
    cancelAnimationFrame(gameLoop); gameLoop = null;
    Audio.playDeath();
    G.data.stats.deaths++;
    saveGame();
    
    app.innerHTML = `
        <div class="modal"><div class="modal-box">
            <div class="modal-icon">ğŸ’€</div>
            <h1 class="modal-title fail">ì¡ì•„ë¨¹í˜”ë‹¤!</h1>
            <p class="modal-desc">ë” í° ì¡´ì¬ì—ê²Œ í¬ì‹ë‹¹í–ˆìŠµë‹ˆë‹¤.</p>
            <div style="display:flex;flex-direction:column;gap:10px;">
                <button class="btn btn-energy btn-block" id="btn-retry">ğŸ² ë‹¤ì‹œ ì‹œì‘</button>
                <button class="btn btn-outline btn-block" id="btn-home">ğŸ  í™ˆìœ¼ë¡œ</button>
            </div>
        </div></div>
    `;
    
    document.getElementById('btn-retry').onclick = () => { Audio.playClick(); G.data.stage = 0; G.data.tutDone = false; G.data.score = 0; saveGame(); renderDice(); };
    document.getElementById('btn-home').onclick = () => { Audio.playClick(); renderSaves(); };
};

const evolveMulti = () => {
    cancelAnimationFrame(gameLoop); gameLoop = null;
    G.data.stage = 2;
    saveGame();
    Audio.playEvolve();
    renderStory('multi');
};

/* ========================================
   Climb Game
======================================== */
let climber, platforms = [], climbItems = [], camY = 0, curH = 0, canDblJump = false, wasOnGround = true;
let deathLineY = 0, landY = 0, shownOvershootWarning = false;

const startClimb = () => {
    cleanup();
    const env = envById(G.data.dna.origin);
    const joyRight = Settings.get('joyRight');
    
    app.innerHTML = `
        <canvas id="game-canvas"></canvas>
        <div class="climb-hud">
            <div class="climb-info"><div class="climb-height" id="c-height">0m</div><div class="climb-label">í˜„ì¬ ë†’ì´</div></div>
            <div class="hud-btns">
                <button class="hud-btn" id="btn-restart">ğŸ”„</button>
                <button class="hud-btn" id="btn-home">ğŸ </button>
                <button class="hud-btn" id="btn-pause">â¸ï¸</button>
            </div>
            <div class="climb-goal"><div class="climb-goal-text">ğŸ”ï¸ ìœ¡ì§€</div><div class="climb-goal-val">${CONFIG.LAND_HEIGHT}m</div></div>
        </div>
        <div class="controls ${joyRight ? 'joy-right' : ''}">
            <div class="joystick" id="joy"><div class="joy-base"></div><div class="joy-knob" id="joy-knob"></div></div>
            <button class="action-btn" id="btn-jump">â¬†ï¸</button>
        </div>
    `;
    
    canvas = document.getElementById('game-canvas');
    ctx = canvas.getContext('2d');
    resize();
    
    window.addEventListener('resize', resize);
    addCleanup(() => window.removeEventListener('resize', resize));
    
    const pSize = 28 + traitCount() * 2;
    climber = { x: canvas.width / 2, y: canvas.height - 80, w: pSize, h: pSize, vx: 0, vy: 0, onGround: true };
    wasOnGround = true;
    shownOvershootWarning = false;
    
    platforms = [];
    climbItems = [];
    deathLineY = canvas.height + 100;
    landY = -CONFIG.LAND_HEIGHT * 10 - 40;
    
    genPlats(canvas.height - 50, landY - 200);
    platforms.push({ x: canvas.width / 2 - 70, y: canvas.height - 40, w: 140, h: 18, type: 'normal' });
    platforms.push({ x: 0, y: landY, w: canvas.width, h: 150, type: 'land' });
    
    camY = 0; curH = 0;
    
    setupClimbControls();
    setupClimbHUD();
    
    gameLoop = requestAnimationFrame(updateClimb);
};

const genPlats = (fromY, toY) => {
    let y = fromY - 50;
    while (y > toY) {
        const num = 1 + Math.floor(Math.random() * 2);
        for (let i = 0; i < num; i++) {
            const w = 70 + Math.random() * 50;
            const x = Math.random() * (canvas.width - w);
            let type = 'normal';
            const hr = Math.abs(y) / (CONFIG.LAND_HEIGHT * 10);
            if (hr > 0.3 && Math.random() < 0.1) type = 'moving';
            if (hr > 0.5 && Math.random() < 0.06) type = 'breaking';
            if (hr > 0.6 && Math.random() < 0.1) type = 'bouncy';
            platforms.push({ x, y, w, h: 14, type, dir: Math.random() < 0.5 ? 1 : -1, spd: 1 + Math.random() * 1.2, broken: false, timer: 0 });
            if (Math.random() < 0.12) climbItems.push({ x: x + w / 2, y: y - 45, type: 'tornado', collected: false });
        }
        y -= 45 + Math.random() * 25;
    }
};

const setupClimbControls = () => {
    const joy = document.getElementById('joy');
    const knob = document.getElementById('joy-knob');
    const stats = calcStats();
    
    const move = (cx, cy) => {
        const r = joy.getBoundingClientRect();
        const cX = r.left + r.width / 2, cY = r.top + r.height / 2;
        const maxD = r.width / 2 - 20;
        let dx = cx - cX, dy = cy - cY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > maxD) { dx = dx / dist * maxD; dy = dy / dist * maxD; }
        knob.style.transform = `translate(${dx}px, ${dy}px)`;
        joyPos = { x: dx / maxD, y: dy / maxD };
    };
    const end = () => { joyActive = false; knob.style.transform = ''; joyPos = { x: 0, y: 0 }; };
    
    const jump = () => {
        if (climber.onGround) {
            climber.vy = -16;
            climber.onGround = false;
            wasOnGround = false;
            canDblJump = stats.speed > 1.1;
            Audio.playJump();
        } else if (canDblJump) {
            climber.vy = -13;
            canDblJump = false;
            Audio.playJump();
        }
    };
    
    joy.addEventListener('touchstart', e => { e.preventDefault(); joyActive = true; move(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    joy.addEventListener('touchmove', e => { e.preventDefault(); if (joyActive) move(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    joy.addEventListener('touchend', end);
    joy.addEventListener('mousedown', e => { joyActive = true; move(e.clientX, e.clientY); });
    window.addEventListener('mousemove', e => { if (joyActive) move(e.clientX, e.clientY); });
    window.addEventListener('mouseup', end);
    window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if (e.key === ' ' || e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') jump(); });
    window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
    
    document.getElementById('btn-jump').onclick = jump;
    document.getElementById('btn-jump').ontouchstart = e => { e.preventDefault(); jump(); };
};

const setupClimbHUD = () => {
    document.getElementById('btn-restart').onclick = () => { Audio.playClick(); if (confirm('ì²˜ìŒë¶€í„°?')) { cancelAnimationFrame(gameLoop); gameLoop = null; startClimb(); } };
    document.getElementById('btn-home').onclick = () => { Audio.playClick(); if (confirm('í™ˆìœ¼ë¡œ?')) { cancelAnimationFrame(gameLoop); gameLoop = null; saveGame(); renderSaves(); } };
    document.getElementById('btn-pause').onclick = () => {
        Audio.playClick();
        const btn = document.getElementById('btn-pause');
        if (gameLoop) { cancelAnimationFrame(gameLoop); gameLoop = null; btn.textContent = 'â–¶ï¸'; }
        else { gameLoop = requestAnimationFrame(updateClimb); btn.textContent = 'â¸ï¸'; }
    };
};

const updateClimb = () => {
    if (!canvas || !ctx) return;
    const env = envById(G.data.dna.origin);
    const stats = calcStats();
    
    let mx = joyPos.x;
    if (keys.a || keys.arrowleft) mx = -1;
    if (keys.d || keys.arrowright) mx = 1;
    
    const spd = 5 * stats.speed;
    climber.vx = mx * spd;
    climber.vy += 0.55;
    if (climber.vy > 14) climber.vy = 14;
    
    climber.x += climber.vx;
    climber.y += climber.vy;
    if (climber.x < 0) climber.x = 0;
    if (climber.x + climber.w > canvas.width) climber.x = canvas.width - climber.w;
    
    const wasOnGroundBefore = climber.onGround;
    climber.onGround = false;
    
    for (const p of platforms) {
        if (p.broken) continue;
        if (p.type === 'moving') { p.x += p.dir * p.spd; if (p.x <= 0 || p.x + p.w >= canvas.width) p.dir *= -1; }
        
        if (climber.vy >= 0 && climber.x + climber.w > p.x + 4 && climber.x < p.x + p.w - 4 && climber.y + climber.h >= p.y && climber.y + climber.h <= p.y + p.h + 16) {
            climber.y = p.y - climber.h;
            climber.vy = 0;
            climber.onGround = true;
            canDblJump = stats.speed > 1.1;
            
            if (p.type === 'bouncy') { climber.vy = -20; climber.onGround = false; Audio.playJump(); }
            else if (p.type === 'breaking') { p.timer++; if (p.timer > 25) p.broken = true; }
            else if (p.type === 'land') { climbWin(); return; }
            else if (!wasOnGroundBefore && !wasOnGround) { Audio.playLand(); }
            if (p.type === 'moving') climber.x += p.dir * p.spd;
        }
    }
    
    wasOnGround = climber.onGround;
    
    for (const item of climbItems) {
        if (item.collected) continue;
        const dx = (climber.x + climber.w / 2) - item.x;
        const dy = (climber.y + climber.h / 2) - item.y;
        if (Math.sqrt(dx * dx + dy * dy) < 35) {
            item.collected = true;
            Audio.playWind();
            climber.vy = -48;
            toast('ğŸŒªï¸ í† ë„¤ì´ë„ì˜ í˜!', 'success');
        }
    }
    
    const targetCam = -climber.y + canvas.height * 0.6;
    camY += (targetCam - camY) * 0.1;
    curH = Math.max(0, Math.floor(-climber.y / 10));
    G.data.stats.maxH = Math.max(G.data.stats.maxH, curH);
    
    if (climber.y < landY - 200 && !shownOvershootWarning) { shownOvershootWarning = true; toast('âš ï¸ ë„ˆë¬´ ì˜¬ë¼ì™”ë‹¤! ìœ¡ì§€ë¡œ ë‚´ë ¤ê°€ì!', 'warning'); }
    if (climber.y > landY - 100) shownOvershootWarning = false;
    
    const highest = Math.min(...platforms.filter(p => p.type !== 'land').map(p => p.y));
    if (-camY - canvas.height < highest + 400) genPlats(highest, highest - canvas.height * 2);
    
    if (climber.y > deathLineY || climber.y > -camY + canvas.height + 80) { climbFail(); return; }
    
    renderClimb(env);
    document.getElementById('c-height').textContent = curH + 'm';
    
    gameLoop = requestAnimationFrame(updateClimb);
};

const renderClimb = env => {
    const w = canvas.width, h = canvas.height;
    const hr = Math.min(1, curH / CONFIG.LAND_HEIGHT);
    const t = Date.now() * 0.005;
    
    const bg = ctx.createLinearGradient(0, 0, 0, h);
    if (hr < 0.5) { bg.addColorStop(0, lerpCol(env.colors.bg1, '#1a3a5e', hr * 2)); bg.addColorStop(1, lerpCol(env.colors.bg2, '#0a2040', hr * 2)); }
    else { bg.addColorStop(0, lerpCol('#1a3a5e', '#87CEEB', (hr - 0.5) * 2)); bg.addColorStop(1, lerpCol('#0a2040', '#E0F7FA', (hr - 0.5) * 2)); }
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, w, h);
    
    ctx.save();
    ctx.translate(0, camY);
    
    for (const p of platforms) {
        if (p.broken) continue;
        const sy = p.y + camY;
        if (sy < -40 || sy > h + 40) continue;
        ctx.fillStyle = platCol(p.type, hr, env);
        if (p.type === 'land') {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.fillStyle = '#228B22';
            ctx.fillRect(p.x, p.y, p.w, 20);
            for (let i = 0; i < 6; i++) {
                const tx = 30 + i * (p.w / 6);
                ctx.fillStyle = '#654321';
                ctx.fillRect(tx, p.y - 40, 10, 40);
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.arc(tx + 5, p.y - 50, 25, 0, Math.PI * 2);
                ctx.fill();
            }
        } else {
            ctx.beginPath();
            ctx.roundRect(p.x, p.y, p.w, p.h, 5);
            ctx.fill();
        }
    }
    
    for (const item of climbItems) {
        if (item.collected) continue;
        const sy = item.y + camY;
        if (sy < -40 || sy > h + 40) continue;
        ctx.save();
        ctx.translate(item.x, item.y + Math.sin(t) * 5);
        ctx.rotate(-Math.PI / 2); // ì‹œê³„ë°©í–¥ 90ë„ íšŒì „
        ctx.font = '28px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('ğŸŒªï¸', 0, 0);
        ctx.restore();
    }
    
    drawClimber();
    ctx.restore();
    
    const gH = h - 90, gX = w - 25;
    const prog = Math.min(1, curH / CONFIG.LAND_HEIGHT);
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(gX - 4, 45, 16, gH);
    const gFill = ctx.createLinearGradient(0, 45 + gH, 0, 45);
    gFill.addColorStop(0, '#00f5d4');
    gFill.addColorStop(1, '#fee440');
    ctx.fillStyle = gFill;
    ctx.fillRect(gX - 2, 45 + gH * (1 - prog), 12, gH * prog);
    ctx.fillStyle = '#228B22';
    ctx.fillRect(gX - 6, 40, 20, 8);
};

const platCol = (type, hr, env) => {
    if (type === 'moving') return '#9d4edd';
    if (type === 'breaking') return '#ef4444';
    if (type === 'bouncy') return '#10b981';
    return hr < 0.5 ? lerpCol(env.colors.food, '#48cae4', hr * 2) : lerpCol('#48cae4', '#caf0f8', (hr - 0.5) * 2);
};

const lerpCol = (a, b, t) => {
    const ah = parseInt(a.replace('#', ''), 16), bh = parseInt(b.replace('#', ''), 16);
    const ar = ah >> 16, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
    const br = bh >> 16, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
    return `#${((Math.round(ar + (br - ar) * t) << 16) | (Math.round(ag + (bg - ag) * t) << 8) | Math.round(ab + (bb - ab) * t)).toString(16).padStart(6, '0')}`;
};

const drawClimber = () => {
    const d = G.data.design, t = Date.now() * 0.005, s = climber.w / 2;
    ctx.save();
    ctx.translate(climber.x + climber.w / 2, climber.y + climber.h / 2);
    ctx.shadowColor = d.primary;
    ctx.shadowBlur = 12;
    ctx.beginPath();
    for (let i = 0; i < 8; i++) {
        const ang = (i / 8) * Math.PI * 2;
        const w = Math.sin(t + i) * 1.8;
        const r = s + w;
        i === 0 ? ctx.moveTo(Math.cos(ang) * r, Math.sin(ang) * r) : ctx.lineTo(Math.cos(ang) * r, Math.sin(ang) * r);
    }
    ctx.closePath();
    const grad = ctx.createRadialGradient(-s * 0.2, -s * 0.2, 0, 0, 0, s);
    grad.addColorStop(0, d.primary);
    grad.addColorStop(1, d.secondary);
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.shadowBlur = 0;
    const parts = getAppearance();
    const eyeCnt = Math.max(1, parts.eye);
    for (let i = 0; i < eyeCnt; i++) {
        const eA = (i - (eyeCnt - 1) / 2) * 0.35;
        const eX = eA * s * 0.7, eY = -s * 0.25;
        ctx.beginPath(); ctx.arc(eX, eY, s * 0.22, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
        ctx.beginPath(); ctx.arc(eX + s * 0.03, eY, s * 0.1, 0, Math.PI * 2); ctx.fillStyle = '#222'; ctx.fill();
    }
    ctx.restore();
};

const climbFail = () => {
    cancelAnimationFrame(gameLoop); gameLoop = null;
    Audio.playDeath();
    saveGame();
    app.innerHTML = `
        <div class="modal"><div class="modal-box">
            <div class="modal-icon">ğŸ’§</div>
            <h1 class="modal-title fail">ì¶”ë½!</h1>
            <p class="modal-desc">ë°”ë‹¤ë¡œ ë–¨ì–´ì¡ŒìŠµë‹ˆë‹¤...</p>
            <div class="modal-stats"><div class="stat-row"><span class="stat-label">ë„ë‹¬ ë†’ì´</span><span class="stat-val">${curH}m</span></div><div class="stat-row"><span class="stat-label">ìµœê³  ê¸°ë¡</span><span class="stat-val">${G.data.stats.maxH}m</span></div></div>
            <div style="display:flex;flex-direction:column;gap:10px;">
                <button class="btn btn-energy btn-block" id="btn-retry">ğŸ”„ ë‹¤ì‹œ</button>
                <button class="btn btn-outline btn-block" id="btn-home">ğŸ  í™ˆ</button>
            </div>
        </div></div>
    `;
    document.getElementById('btn-retry').onclick = () => { Audio.playClick(); startClimb(); };
    document.getElementById('btn-home').onclick = () => { Audio.playClick(); renderSaves(); };
};

const climbWin = () => {
    cancelAnimationFrame(gameLoop); gameLoop = null;
    Audio.playWin();
    G.data.stage = 3;
    G.data.runnerStage = 0;
    G.data.runnerEvo = 0;
    saveGame();
    renderStory('runner');
};

/* ========================================
   Runner Game - 5ë‹¨ê³„ ì§„í™”
======================================== */
const RUNNER_STAGES = [
    { id: 'forest', name: 'ğŸŒ² ì›ì‹œì˜ ìˆ²', dist: CONFIG.RUNNER_STAGE_DIST, bgColors: ['#1a3a1a', '#0a2a0a'], groundColor: '#3d2817', items: ['ğŸ›', 'ğŸ¦—'], obstacles: ['ğŸª¨'], evoMsg: 'ì‚¬ì§€ê°€ ë°œë‹¬í–ˆë‹¤!', baseSpeed: 2 },
    { id: 'plains', name: 'âš¡ ë²ˆê°œì˜ í‰ì›', dist: CONFIG.RUNNER_STAGE_DIST, bgColors: ['#2a2a4a', '#1a1a3a'], groundColor: '#4a3a2a', items: ['âš¡'], obstacles: ['ğŸª¨','ğŸ’€'], evoMsg: 'ì§ë¦½ë³´í–‰ì„ ì‹œì‘í–ˆë‹¤!', baseSpeed: 2.5 },
    { id: 'fire', name: 'ğŸ”¥ ë¶ˆì˜ ë°œê²¬', dist: CONFIG.RUNNER_STAGE_DIST, bgColors: ['#3a1a0a', '#2a0a00'], groundColor: '#4a3020', items: ['ğŸ”¥'], obstacles: ['ğŸŒ‹'], evoMsg: 'ë¶ˆì„ ë‹¤ë£¨ê²Œ ë˜ì—ˆë‹¤!', baseSpeed: 3 },
    { id: 'tools', name: 'ğŸ”§ ë„êµ¬ì˜ ì‹œëŒ€', dist: CONFIG.RUNNER_STAGE_DIST, bgColors: ['#2a2a2a', '#1a1a1a'], groundColor: '#3a3a3a', items: ['ğŸ”§','ğŸª“'], obstacles: ['ğŸ—¿'], evoMsg: 'ë„êµ¬ë¥¼ ë§Œë“¤ê¸° ì‹œì‘í–ˆë‹¤!', baseSpeed: 3.5 },
    { id: 'civilization', name: 'ğŸ›ï¸ ë¬¸ëª…ì˜ ì—¬ëª…', dist: CONFIG.RUNNER_STAGE_DIST, bgColors: ['#3a2a1a', '#2a1a0a'], groundColor: '#5a4a3a', items: ['ğŸ“œ','ğŸ '], obstacles: ['ğŸ—¿'], evoMsg: 'ë¬¸ëª…ì´ ì‹œì‘ë˜ì—ˆë‹¤!', baseSpeed: 4 }
];

let runner, runnerDist, runnerStage, obstacles, items, runnerParticles;
let runnerSpeed, bgOffset, lastObstacleTime = 0;
const MIN_OBSTACLE_GAP = 1800;

const startRunner = () => {
    cleanup();
    const joyRight = Settings.get('joyRight');
    
    runnerStage = G.data.runnerStage || 0;
    runnerDist = 0;
    bgOffset = 0;
    lastObstacleTime = 0;
    
    const stage = RUNNER_STAGES[runnerStage];
    runnerSpeed = stage.baseSpeed;
    
    const evoScale = 1 + G.data.runnerEvo * 0.15;
    runner = { x: 100, y: 0, w: 40 * evoScale, h: 55 * evoScale, vy: 0, onGround: true, ducking: false };
    obstacles = [];
    items = [];
    runnerParticles = [];
    
    app.innerHTML = `
        <canvas id="game-canvas"></canvas>
        <div class="runner-hud">
            <div class="runner-stage"><div class="runner-stage-name">${stage.name}</div><div class="runner-dist" id="r-dist">0m / ${stage.dist}m</div></div>
            <div class="hud-btns">
                <button class="hud-btn" id="btn-home">ğŸ </button>
                <button class="hud-btn" id="btn-pause">â¸ï¸</button>
            </div>
        </div>
        <div class="controls ${joyRight ? 'joy-right' : ''}">
            <button class="action-btn" id="btn-duck" style="font-size:1rem;">â¬‡ï¸</button>
            <button class="action-btn" id="btn-jump">â¬†ï¸</button>
        </div>
    `;
    
    canvas = document.getElementById('game-canvas');
    ctx = canvas.getContext('2d');
    resize();
    
    window.addEventListener('resize', resize);
    addCleanup(() => window.removeEventListener('resize', resize));
    
    setupRunnerControls();
    setupRunnerHUD();
    
    gameLoop = requestAnimationFrame(updateRunner);
};

const setupRunnerControls = () => {
    const jump = () => { if (runner.onGround && !runner.ducking) { runner.vy = -18; runner.onGround = false; Audio.playJump(); } };
    const duckStart = () => { if (runner.onGround) { runner.ducking = true; runner.h = 30 * (1 + G.data.runnerEvo * 0.15); } };
    const duckEnd = () => { runner.ducking = false; runner.h = 55 * (1 + G.data.runnerEvo * 0.15); };
    
    document.getElementById('btn-jump').onclick = jump;
    document.getElementById('btn-jump').ontouchstart = e => { e.preventDefault(); jump(); };
    document.getElementById('btn-duck').ontouchstart = e => { e.preventDefault(); duckStart(); };
    document.getElementById('btn-duck').ontouchend = duckEnd;
    document.getElementById('btn-duck').onmousedown = duckStart;
    document.getElementById('btn-duck').onmouseup = duckEnd;
    
    const onKeyDown = e => { if (e.key === ' ' || e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') jump(); if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') duckStart(); };
    const onKeyUp = e => { if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') duckEnd(); };
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);
    addCleanup(() => { window.removeEventListener('keydown', onKeyDown); window.removeEventListener('keyup', onKeyUp); });
};

const setupRunnerHUD = () => {
    document.getElementById('btn-home').onclick = () => { Audio.playClick(); if (confirm('í™ˆìœ¼ë¡œ?')) { cancelAnimationFrame(gameLoop); gameLoop = null; saveGame(); renderSaves(); } };
    document.getElementById('btn-pause').onclick = () => {
        Audio.playClick();
        const btn = document.getElementById('btn-pause');
        if (gameLoop) { cancelAnimationFrame(gameLoop); gameLoop = null; btn.textContent = 'â–¶ï¸'; }
        else { gameLoop = requestAnimationFrame(updateRunner); btn.textContent = 'â¸ï¸'; }
    };
};

const updateRunner = () => {
    if (!canvas || !ctx) return;
    
    const stage = RUNNER_STAGES[runnerStage];
    const groundY = canvas.height - 80;
    const now = Date.now();
    
    runner.vy += 0.8;
    runner.y += runner.vy;
    if (runner.y >= groundY - runner.h) { runner.y = groundY - runner.h; runner.vy = 0; runner.onGround = true; }
    
    runnerDist += runnerSpeed * 0.08;
    runnerSpeed = stage.baseSpeed + runnerDist * 0.002;
    runnerSpeed = Math.min(runnerSpeed, stage.baseSpeed + 3);
    bgOffset += runnerSpeed;
    
    if (now - lastObstacleTime > MIN_OBSTACLE_GAP && Math.random() < 0.012) {
        const type = stage.obstacles[Math.floor(Math.random() * stage.obstacles.length)];
        const tall = Math.random() < 0.2;
        obstacles.push({ x: canvas.width + 50, y: tall ? groundY - 65 : groundY - 40, w: 40, h: tall ? 30 : 40, type, tall });
        lastObstacleTime = now;
    }
    
    if (Math.random() < 0.015) {
        const type = stage.items[Math.floor(Math.random() * stage.items.length)];
        items.push({ x: canvas.width + 50, y: groundY - 90 - Math.random() * 40, type, collected: false });
    }
    
    for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.x -= runnerSpeed * 1.5;
        if (o.x < -60) { obstacles.splice(i, 1); continue; }
        const hs = 10;
        if (runner.x + runner.w - hs > o.x + hs && runner.x + hs < o.x + o.w - hs && runner.y + runner.h > o.y + hs && runner.y < o.y + o.h - hs) { runnerFail(); return; }
    }
    
    for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        item.x -= runnerSpeed * 1.5;
        if (item.x < -50) { items.splice(i, 1); continue; }
        if (!item.collected) {
            const dx = (runner.x + runner.w / 2) - item.x, dy = (runner.y + runner.h / 2) - item.y;
            if (Math.sqrt(dx * dx + dy * dy) < 45) {
                item.collected = true;
                Audio.playCollect();
                if (item.type === 'âš¡') { toast('âš¡ ë²ˆê°œì˜ í˜!', 'success'); runnerSpeed += 0.3; }
                else if (item.type === 'ğŸ”¥') { toast('ğŸ”¥ ë¶ˆì„ ë°œê²¬!', 'success'); runnerDist += 25; }
                else { runnerDist += 10; }
                for (let j = 0; j < 5; j++) runnerParticles.push({ x: item.x, y: item.y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4, life: 20, color: '#ffff00' });
                items.splice(i, 1);
            }
        }
    }
    
    runnerParticles = runnerParticles.filter(p => { p.x += p.vx; p.y += p.vy; p.life--; return p.life > 0; });
    
    renderRunner(stage, groundY);
    const distEl = document.getElementById('r-dist');
    if (distEl) distEl.textContent = `${Math.floor(runnerDist)}m / ${stage.dist}m`;
    
    if (runnerDist >= stage.dist) { runnerStageComplete(); return; }
    
    gameLoop = requestAnimationFrame(updateRunner);
};

const renderRunner = (stage, groundY) => {
    const w = canvas.width, h = canvas.height;
    const t = Date.now() * 0.001;
    
    const bg = ctx.createLinearGradient(0, 0, 0, h);
    bg.addColorStop(0, stage.bgColors[0]);
    bg.addColorStop(1, stage.bgColors[1]);
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, w, h);
    
    // ë°°ê²½ ì¥ì‹
    if (runnerStage === 0) {
        for (let i = 0; i < 8; i++) {
            const tx = ((w + 150) - (bgOffset * 0.3 + i * 180) % (w + 150));
            ctx.fillStyle = '#1a4a1a';
            ctx.beginPath(); ctx.moveTo(tx, groundY); ctx.lineTo(tx + 25, groundY - 100); ctx.lineTo(tx + 50, groundY); ctx.fill();
        }
    } else if (runnerStage === 2) {
        ctx.fillStyle = 'rgba(255,100,0,0.15)';
        ctx.fillRect(0, groundY - 50, w, 50);
    } else if (runnerStage === 4) {
        for (let i = 0; i < 5; i++) {
            const bx = ((w + 150) - (bgOffset * 0.15 + i * 200) % (w + 150));
            const bh = 50 + i * 15;
            ctx.fillStyle = '#3a2a1a';
            ctx.fillRect(bx, groundY - bh, 50, bh);
            ctx.fillStyle = '#ffa500';
            ctx.fillRect(bx + 10, groundY - bh + 15, 10, 10);
        }
    }
    
    ctx.fillStyle = stage.groundColor;
    ctx.fillRect(0, groundY, w, h - groundY);
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 2;
    ctx.setLineDash([20, 15]);
    ctx.lineDashOffset = -bgOffset;
    ctx.beginPath(); ctx.moveTo(0, groundY + 10); ctx.lineTo(w, groundY + 10); ctx.stroke();
    ctx.setLineDash([]);
    
    obstacles.forEach(o => { ctx.font = `${o.h}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; ctx.fillText(o.type, o.x + o.w / 2, o.y + o.h); });
    items.forEach(item => { if (item.collected) return; ctx.font = '32px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(item.type, item.x, item.y + Math.sin(t * 5) * 5); });
    runnerParticles.forEach(p => { ctx.globalAlpha = p.life / 20; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill(); });
    ctx.globalAlpha = 1;
    
    drawRunnerChar(groundY);
};

const drawRunnerChar = groundY => {
    const d = G.data.design;
    const t = Date.now() * 0.015;
    const evo = G.data.runnerEvo || 0;
    
    ctx.save();
    ctx.translate(runner.x + runner.w / 2, runner.y + runner.h / 2);
    
    const legPhase = Math.sin(t * 2) * 0.4;
    const armPhase = Math.sin(t * 2 + Math.PI) * 0.3;
    
    if (evo === 0) {
        // ì´ˆê¸°: í° ì„¸í¬
        const bounce = runner.onGround ? Math.abs(Math.sin(t)) * 3 : 0;
        ctx.translate(0, -bounce);
        ctx.shadowColor = d.primary;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const ang = (i / 8) * Math.PI * 2, w = Math.sin(t * 0.5 + i) * 3, r = runner.w / 2 + w;
            i === 0 ? ctx.moveTo(Math.cos(ang) * r, Math.sin(ang) * r) : ctx.lineTo(Math.cos(ang) * r, Math.sin(ang) * r);
        }
        ctx.closePath();
        ctx.fillStyle = d.primary;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.beginPath(); ctx.arc(5, -5, 8, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
        ctx.beginPath(); ctx.arc(8, -5, 4, 0, Math.PI * 2); ctx.fillStyle = '#222'; ctx.fill();
    } else if (evo === 1) {
        // ì‚¬ì§€ ë°œë‹¬
        ctx.strokeStyle = d.secondary; ctx.lineWidth = 5; ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(-8, runner.h / 4); ctx.lineTo(-8 + Math.sin(legPhase) * 15, runner.h / 2 + 5); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(8, runner.h / 4); ctx.lineTo(8 - Math.sin(legPhase) * 15, runner.h / 2 + 5); ctx.stroke();
        ctx.fillStyle = d.primary;
        ctx.beginPath();
        for (let i = 0; i < 8; i++) { const ang = (i / 8) * Math.PI * 2, r = runner.w / 2.5; i === 0 ? ctx.moveTo(Math.cos(ang) * r, Math.sin(ang) * r) : ctx.lineTo(Math.cos(ang) * r, Math.sin(ang) * r); }
        ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.arc(5, -8, 7, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
        ctx.beginPath(); ctx.arc(7, -8, 3.5, 0, Math.PI * 2); ctx.fillStyle = '#222'; ctx.fill();
    } else if (evo === 2) {
        // ì§ë¦½ë³´í–‰
        ctx.fillStyle = d.primary;
        ctx.beginPath(); ctx.ellipse(0, 0, runner.w / 3, runner.h / 2.5, 0, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(0, -runner.h / 2, runner.w / 4, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(-5, -runner.h / 2 - 2, 5, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
        ctx.beginPath(); ctx.arc(5, -runner.h / 2 - 2, 5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(-3, -runner.h / 2 - 2, 2.5, 0, Math.PI * 2); ctx.fillStyle = '#222'; ctx.fill();
        ctx.beginPath(); ctx.arc(7, -runner.h / 2 - 2, 2.5, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = d.secondary; ctx.lineWidth = 6;
        ctx.beginPath(); ctx.moveTo(-8, runner.h / 4); ctx.lineTo(-8 + Math.sin(legPhase) * 18, runner.h / 2 + 8); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(8, runner.h / 4); ctx.lineTo(8 - Math.sin(legPhase) * 18, runner.h / 2 + 8); ctx.stroke();
        ctx.strokeStyle = d.primary; ctx.lineWidth = 5;
        ctx.beginPath(); ctx.moveTo(-runner.w / 3, -5); ctx.lineTo(-runner.w / 2 - Math.sin(armPhase) * 12, 12); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(runner.w / 3, -5); ctx.lineTo(runner.w / 2 + Math.sin(armPhase) * 12, 12); ctx.stroke();
    } else if (evo === 3) {
        // ë¶ˆ ì‚¬ìš©
        ctx.fillStyle = d.primary;
        ctx.beginPath(); ctx.ellipse(0, 0, runner.w / 3, runner.h / 2.5, 0, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(0, -runner.h / 2, runner.w / 4, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(-5, -runner.h / 2 - 2, 5, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
        ctx.beginPath(); ctx.arc(5, -runner.h / 2 - 2, 5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(-3, -runner.h / 2 - 2, 2.5, 0, Math.PI * 2); ctx.fillStyle = '#222'; ctx.fill();
        ctx.beginPath(); ctx.arc(7, -runner.h / 2 - 2, 2.5, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = d.secondary; ctx.lineWidth = 6;
        ctx.beginPath(); ctx.moveTo(-8, runner.h / 4); ctx.lineTo(-8 + Math.sin(legPhase) * 16, runner.h / 2 + 6); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(8, runner.h / 4); ctx.lineTo(8 - Math.sin(legPhase) * 16, runner.h / 2 + 6); ctx.stroke();
        ctx.strokeStyle = d.primary; ctx.lineWidth = 5;
        ctx.beginPath(); ctx.moveTo(runner.w / 3, -5); ctx.lineTo(runner.w / 2 + 10, -15); ctx.stroke();
        ctx.font = '16px Arial'; ctx.fillText('ğŸ”¥', runner.w / 2 + 12, -22);
    } else {
        // ë„êµ¬/ë¬¸ëª…
        ctx.fillStyle = '#8B4513';
        ctx.beginPath(); ctx.roundRect(-runner.w / 3, -runner.h / 4, runner.w / 1.5, runner.h / 1.8, 5); ctx.fill();
        ctx.fillStyle = d.primary;
        ctx.beginPath(); ctx.arc(0, -runner.h / 2 - 5, runner.w / 3.5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(-6, -runner.h / 2 - 5, 5, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
        ctx.beginPath(); ctx.arc(6, -runner.h / 2 - 5, 5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(-4, -runner.h / 2 - 5, 2.5, 0, Math.PI * 2); ctx.fillStyle = '#222'; ctx.fill();
        ctx.beginPath(); ctx.arc(8, -runner.h / 2 - 5, 2.5, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = '#222'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0, -runner.h / 2 - 2, 6, 0.2, Math.PI - 0.2); ctx.stroke();
        ctx.strokeStyle = d.primary; ctx.lineWidth = 7;
        ctx.beginPath(); ctx.moveTo(-10, runner.h / 4); ctx.lineTo(-10 + Math.sin(legPhase) * 15, runner.h / 2 + 6); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(10, runner.h / 4); ctx.lineTo(10 - Math.sin(legPhase) * 15, runner.h / 2 + 6); ctx.stroke();
        ctx.font = '14px Arial'; ctx.fillText(evo >= 4 ? 'ğŸ“œ' : 'ğŸ”§', runner.w / 2 + 8, -10);
    }
    
    ctx.restore();
};

const runnerFail = () => {
    cancelAnimationFrame(gameLoop); gameLoop = null;
    Audio.playDeath();
    app.innerHTML = `
        <div class="modal"><div class="modal-box">
            <div class="modal-icon">ğŸ’¥</div>
            <h1 class="modal-title fail">ì¶©ëŒ!</h1>
            <p class="modal-desc">ì¥ì• ë¬¼ì— ë¶€ë”ªí˜”ìŠµë‹ˆë‹¤.</p>
            <div class="modal-stats"><div class="stat-row"><span class="stat-label">ì§„í–‰ ê±°ë¦¬</span><span class="stat-val">${Math.floor(runnerDist)}m</span></div></div>
            <div style="display:flex;flex-direction:column;gap:10px;">
                <button class="btn btn-energy btn-block" id="btn-retry">ğŸ”„ ë‹¤ì‹œ</button>
                <button class="btn btn-outline btn-block" id="btn-home">ğŸ  í™ˆ</button>
            </div>
        </div></div>
    `;
    document.getElementById('btn-retry').onclick = () => { Audio.playClick(); startRunner(); };
    document.getElementById('btn-home').onclick = () => { Audio.playClick(); renderSaves(); };
};

const runnerStageComplete = () => {
    cancelAnimationFrame(gameLoop); gameLoop = null;
    Audio.playEvolve();
    
    const stage = RUNNER_STAGES[runnerStage];
    const isLast = runnerStage >= RUNNER_STAGES.length - 1;
    
    G.data.runnerEvo++;
    
    if (!isLast) {
        G.data.runnerStage = runnerStage + 1;
        saveGame();
        showEvo('ğŸ§¬', 'ì§„í™”!', stage.evoMsg, `${runnerStage + 2}ë‹¨ê³„ë¡œ...`);
        setTimeout(() => startRunner(), 2500);
    } else {
        G.data.stage = 4;
        saveGame();
        app.innerHTML = `
            <div class="modal"><div class="modal-box">
                <div class="modal-icon">ğŸ‰</div>
                <h1 class="modal-title win">ë¬¸ëª… ì™„ì„±!</h1>
                <p class="modal-desc">ë‹¹ì‹ ì€ ë¯¸ìƒë¬¼ì—ì„œ ì‹œì‘í•˜ì—¬<br>ë§ˆì¹¨ë‚´ ë¬¸ëª…ì„ ì´ë£¨ì—ˆìŠµë‹ˆë‹¤!</p>
                <div class="modal-stats">
                    <div class="stat-row"><span class="stat-label">ìµœì¢… ì ìˆ˜</span><span class="stat-val">${G.data.score}</span></div>
                    <div class="stat-row"><span class="stat-label">íšë“ íŠ¹ì„±</span><span class="stat-val">${traitCount()}ê°œ</span></div>
                    <div class="stat-row"><span class="stat-label">ì§„í™” ë‹¨ê³„</span><span class="stat-val">${G.data.runnerEvo}ë‹¨ê³„</span></div>
                </div>
                <button class="btn btn-energy btn-block" id="btn-home">ğŸ  í™ˆìœ¼ë¡œ</button>
            </div></div>
        `;
        document.getElementById('btn-home').onclick = () => { Audio.playClick(); renderSaves(); };
    }
};

/* ========================================
   Pages
======================================== */
const renderTitle = () => {
    app.innerHTML = `
        <div class="page-center"><div class="page-content">
            <div class="page-icon">ğŸ²</div>
            <h1 style="font-family:Orbitron;font-size:clamp(2rem,8vw,3rem);font-weight:900;background:var(--gradient-energy);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:4px;">BOKLUCK</h1>
            <h2 style="font-family:Orbitron;font-size:1rem;color:var(--text-secondary);margin-bottom:24px;">Universe</h2>
            <p style="font-size:0.85rem;color:var(--text-muted);line-height:1.7;max-width:260px;margin:0 auto 32px;">
                <strong style="color:var(--neon-cyan)">BOK(ë³µ)</strong> ë˜ëŠ” <strong style="color:var(--neon-pink)">LUCK(ìš´)</strong>ìœ¼ë¡œ<br>ë§Œë“¤ì–´ê°€ëŠ” ë‹¹ì‹ ë§Œì˜ ìš°ì£¼
            </p>
            <div style="display:flex;flex-direction:column;gap:10px;max-width:240px;margin:0 auto;">
                <button class="btn btn-energy btn-block" id="btn-start">ğŸš€ ê²Œì„ ì‹œì‘</button>
                <button class="btn btn-outline btn-block" id="btn-settings">âš™ï¸ ì„¤ì •</button>
            </div>
        </div></div>
    `;
    document.getElementById('btn-start').onclick = () => { Audio.init(); Audio.playClick(); renderSaves(); };
    document.getElementById('btn-settings').onclick = () => { Audio.init(); Audio.playClick(); renderSettings(); };
};

const renderSaves = () => {
    const slots = Save.all();
    let html = '';
    for (let i = 0; i < Save.MAX; i++) {
        const s = slots[i];
        if (s) {
            const stageNames = ['ì‹œì‘ì „', 'ì„¸í¬', 'ë‹¤ì„¸í¬', 'ìœ¡ì§€', 'ë¬¸ëª…'];
            const st = stageNames[s.stage] || 'ì‹œì‘ì „';
            html += `<div class="slot">
                <div class="slot-head"><span class="slot-num">ìŠ¬ë¡¯ ${i + 1}</span><span style="font-size:0.6rem;color:var(--text-muted)">${Save.fmt(s.updated)}</span></div>
                <div class="slot-name">${s.name || 'ì´ë¦„ì—†ìŒ'}</div>
                <div class="slot-info">${s.dna?.origin ? envById(s.dna.origin)?.icon : 'â“'} ${st} Â· ì ìˆ˜: ${s.score || 0} Â· íŠ¹ì„±: ${s.traits?.length || 0}ê°œ</div>
                <div class="slot-actions">
                    <button class="btn btn-energy btn-sm" style="flex:1" onclick="handleLoad(${i})">â–¶ï¸ ê³„ì†</button>
                    <button class="del-btn" onclick="handleDel(${i})">ğŸ—‘ï¸</button>
                </div>
            </div>`;
        } else {
            html += `<div class="slot empty" onclick="handleNew(${i})"><span style="font-size:1.6rem;opacity:0.5">â•</span><p style="color:var(--text-muted);margin-top:6px;font-size:0.8rem;">ìŠ¬ë¡¯ ${i + 1} - ìƒˆ ê²Œì„</p></div>`;
        }
    }
    app.innerHTML = `
        <div class="save-page">
            <div class="save-header">
                <button class="btn btn-ghost btn-sm" id="btn-back">â† ë’¤ë¡œ</button>
                <h1 class="save-title">ğŸ’¾ ì €ì¥ ìŠ¬ë¡¯</h1>
                <div style="width:55px"></div>
            </div>
            <div class="slots">${html}</div>
        </div>
    `;
    document.getElementById('btn-back').onclick = () => { Audio.playClick(); renderTitle(); };
};

window.handleNew = i => { Audio.playClick(); newGame(i); renderStory('intro'); };
window.handleLoad = i => {
    Audio.playClick(); load(i);
    if (!G.data.tutDone) renderStory('intro');
    else if (G.data.stage === 1) startCellWorld();
    else if (G.data.stage === 2) startClimb();
    else if (G.data.stage === 3) startRunner();
    else if (G.data.stage === 4) { toast('ì´ë¯¸ í´ë¦¬ì–´í•œ ì„¸ì´ë¸Œì…ë‹ˆë‹¤!', 'success'); renderSaves(); }
    else renderDice();
};
window.handleDel = i => { Audio.playClick(); if (confirm('ì •ë§ ì‚­ì œ?')) { Save.del(i); renderSaves(); } };

const renderSettings = () => {
    const joyRight = Settings.get('joyRight');
    app.innerHTML = `
        <div class="page-center"><div class="page-content" style="max-width:340px;">
            <h2 class="page-title">âš™ï¸ ì„¤ì •</h2>
            <div style="background:var(--void-surface);border-radius:12px;padding:16px;margin-bottom:16px;text-align:left;">
                <div style="font-size:0.7rem;color:var(--text-muted);margin-bottom:8px;">ğŸ”Š ì‚¬ìš´ë“œ</div>
                <div style="display:flex;align-items:center;justify-content:space-between;padding:8px 0;border-bottom:1px solid var(--border-subtle);">
                    <span>ë§ˆìŠ¤í„°</span>
                    <input type="range" id="vol-m" min="0" max="100" value="${Audio.settings.master * 100}" style="width:80px;">
                </div>
                <div style="display:flex;align-items:center;justify-content:space-between;padding:8px 0;">
                    <span>íš¨ê³¼ìŒ</span>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <input type="range" id="vol-s" min="0" max="100" value="${Audio.settings.sfx * 100}" style="width:80px;">
                        <button class="btn btn-ghost btn-sm" id="toggle-sfx">${Audio.settings.on ? 'ğŸ”Š' : 'ğŸ”‡'}</button>
                    </div>
                </div>
            </div>
            <div style="background:var(--void-surface);border-radius:12px;padding:16px;margin-bottom:16px;text-align:left;">
                <div style="font-size:0.7rem;color:var(--text-muted);margin-bottom:8px;">ğŸ•¹ï¸ ì¡°ì‘</div>
                <div style="display:flex;align-items:center;justify-content:space-between;padding:8px 0;">
                    <span>ì¡°ì´ìŠ¤í‹±</span>
                    <div style="display:flex;gap:6px;">
                        <button class="btn btn-sm ${!joyRight ? 'btn-energy' : 'btn-ghost'}" id="joy-left">â¬…ï¸ ì™¼ìª½</button>
                        <button class="btn btn-sm ${joyRight ? 'btn-energy' : 'btn-ghost'}" id="joy-right">â¡ï¸ ì˜¤ë¥¸ìª½</button>
                    </div>
                </div>
            </div>
            <button class="btn btn-energy btn-block" id="btn-close">í™•ì¸</button>
        </div></div>
    `;
    document.getElementById('vol-m').oninput = e => { Audio.settings.master = e.target.value / 100; Audio.save(); };
    document.getElementById('vol-s').oninput = e => { Audio.settings.sfx = e.target.value / 100; Audio.save(); };
    document.getElementById('toggle-sfx').onclick = e => { Audio.settings.on = !Audio.settings.on; e.target.textContent = Audio.settings.on ? 'ğŸ”Š' : 'ğŸ”‡'; Audio.save(); };
    document.getElementById('joy-left').onclick = () => { Settings.set('joyRight', false); renderSettings(); };
    document.getElementById('joy-right').onclick = () => { Settings.set('joyRight', true); renderSettings(); };
    document.getElementById('btn-close').onclick = () => { Audio.playClick(); renderTitle(); };
};

/* ========================================
   Init
======================================== */
document.addEventListener('DOMContentLoaded', () => {
    createStars();
    renderTitle();
    setInterval(saveGame, CONFIG.SAVE_INTERVAL);
    window.addEventListener('beforeunload', saveGame);
    console.log('ğŸ² BOKLUCK Universe v1.0.0');
});
</script>
</body>
</html>
