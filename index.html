<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BOKLUCK Universe</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ²</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
    --void: #030308;
    --void-light: #0a0a1a;
    --void-surface: #12122a;
    --void-elevated: #1a1a3a;
    
    --neon-cyan: #00f5d4;
    --neon-pink: #f72585;
    --neon-purple: #7b2cbf;
    --neon-yellow: #fee440;
    --neon-orange: #ff6b35;
    
    --success: #10b981;
    --danger: #ef4444;
    --warning: #f59e0b;
    --legendary: #ffd700;
    
    --text-primary: #e8e8ff;
    --text-secondary: #9090b0;
    --text-muted: #606080;
    
    --border-subtle: rgba(255, 255, 255, 0.06);
    --border-default: rgba(0, 245, 212, 0.15);
    
    --gradient-energy: linear-gradient(135deg, #00f5d4 0%, #fee440 100%);
    --gradient-danger: linear-gradient(135deg, #ef4444 0%, #f72585 100%);
    
    --safe-top: env(safe-area-inset-top, 0px);
    --safe-bottom: env(safe-area-inset-bottom, 0px);
}

html, body {
    height: 100%;
    overflow: hidden;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    -webkit-user-select: none;
    user-select: none;
}

body {
    background: var(--void);
    color: var(--text-primary);
    font-family: 'Noto Sans KR', -apple-system, sans-serif;
    font-size: 14px;
    line-height: 1.5;
}

.font-display { font-family: 'Orbitron', monospace; }
.hidden { display: none !important; }

.btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 14px 28px;
    border: none;
    border-radius: 12px;
    font-family: inherit;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}

.btn:active { transform: scale(0.96); }
.btn-energy { background: var(--gradient-energy); color: var(--void); }
.btn-danger { background: var(--gradient-danger); color: white; }
.btn-outline { background: transparent; color: var(--text-primary); border: 1px solid var(--border-default); }
.btn-ghost { background: rgba(255,255,255,0.08); color: var(--text-primary); }
.btn-sm { padding: 10px 16px; font-size: 0.85rem; }
.btn-block { width: 100%; }

#app { position: fixed; inset: 0; overflow: hidden; }
#stars-bg { position: fixed; inset: 0; z-index: 0; pointer-events: none; }

.star {
    position: absolute;
    background: white;
    border-radius: 50%;
    animation: twinkle var(--dur, 3s) ease-in-out infinite;
}

@keyframes twinkle {
    0%, 100% { opacity: 0.2; }
    50% { opacity: 1; }
}

.story-overlay {
    position: fixed;
    inset: 0;
    z-index: 100;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 24px;
    padding-bottom: calc(24px + var(--safe-bottom));
    background: linear-gradient(180deg, rgba(3,3,8,0.95) 0%, rgba(10,10,26,0.98) 100%);
}

.story-content { max-width: 400px; width: 100%; text-align: center; }

.story-icon {
    font-size: 4rem;
    margin-bottom: 16px;
    animation: float 3s ease-in-out infinite;
}

@keyframes float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

.story-title {
    font-family: 'Orbitron', monospace;
    font-size: clamp(1.25rem, 5vw, 1.75rem);
    font-weight: 700;
    margin-bottom: 24px;
    background: var(--gradient-energy);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

.story-text {
    font-size: 1rem;
    line-height: 1.9;
    color: var(--text-secondary);
    margin-bottom: 32px;
    min-height: 100px;
}

.story-text .highlight { color: var(--neon-cyan); font-weight: 500; }
.story-text .danger { color: var(--neon-pink); }
.story-text .golden { color: var(--neon-yellow); }

.story-indicator { display: flex; justify-content: center; gap: 8px; margin-bottom: 24px; }

.story-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--void-elevated);
    transition: all 0.3s;
}

.story-dot.active { background: var(--neon-cyan); width: 24px; border-radius: 4px; }
.story-dot.done { background: var(--text-muted); }

.dice-modal {
    position: fixed;
    inset: 0;
    z-index: 200;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 24px;
    background: rgba(3,3,8,0.95);
}

.dice-container { text-align: center; max-width: 350px; width: 100%; }

.dice-visual {
    width: 140px;
    height: 140px;
    margin: 24px auto;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 5rem;
    background: var(--void-surface);
    border: 2px solid var(--border-default);
    border-radius: 20px;
}

.dice-visual.rolling { animation: diceShake 0.1s linear infinite; }

@keyframes diceShake {
    0%, 100% { transform: rotate(0deg) scale(1); }
    25% { transform: rotate(-10deg) scale(1.05); }
    50% { transform: rotate(10deg) scale(0.95); }
    75% { transform: rotate(-5deg) scale(1.02); }
}

#game-canvas {
    position: fixed;
    inset: 0;
    z-index: 1;
    touch-action: none;
}

.game-hud-top {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 50;
    padding: 12px 16px;
    padding-top: calc(12px + var(--safe-top));
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 8px;
    pointer-events: none;
}

.game-hud-top > * { pointer-events: auto; }

.hud-left-panel {
    background: rgba(10, 10, 26, 0.92);
    border: 1px solid var(--border-default);
    border-radius: 16px;
    padding: 12px;
    backdrop-filter: blur(10px);
    min-width: 130px;
}

.hud-name {
    font-family: 'Orbitron', monospace;
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--neon-cyan);
    margin-bottom: 8px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.hud-stat-row {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 4px;
    font-size: 0.8rem;
}

.hud-stat-row:last-child { margin-bottom: 0; }
.hud-stat-icon { width: 18px; text-align: center; font-size: 0.9rem; }
.hud-stat-value { font-family: 'Orbitron', monospace; font-weight: 700; color: var(--neon-yellow); }
.hud-stat-label { color: var(--text-muted); font-size: 0.7rem; }

.size-indicator {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid var(--border-subtle);
}

.size-bar {
    flex: 1;
    height: 8px;
    background: var(--void-elevated);
    border-radius: 4px;
    overflow: hidden;
}

.size-fill {
    height: 100%;
    background: var(--gradient-energy);
    border-radius: 4px;
    transition: width 0.3s;
}

.size-text {
    font-family: 'Orbitron', monospace;
    font-size: 0.7rem;
    color: var(--text-muted);
    min-width: 30px;
    text-align: right;
}

.hud-right-panel {
    background: rgba(10, 10, 26, 0.92);
    border: 1px solid var(--border-default);
    border-radius: 16px;
    padding: 10px;
    backdrop-filter: blur(10px);
    max-width: 160px;
}

.hud-section-title {
    font-family: 'Orbitron', monospace;
    font-size: 0.65rem;
    color: var(--text-muted);
    margin-bottom: 6px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.body-parts-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-bottom: 8px;
}

.body-part {
    display: flex;
    align-items: center;
    gap: 2px;
    background: var(--void-elevated);
    border: 1px solid var(--border-subtle);
    border-radius: 6px;
    padding: 3px 6px;
    font-size: 0.7rem;
}

.body-part.active {
    border-color: var(--neon-cyan);
    box-shadow: 0 0 6px rgba(0, 245, 212, 0.3);
}

.body-part-icon { font-size: 0.8rem; }
.body-part-count { font-family: 'Orbitron', monospace; font-size: 0.6rem; color: var(--neon-yellow); }

.progress-section { margin-bottom: 8px; }

.progress-label {
    display: flex;
    justify-content: space-between;
    font-size: 0.65rem;
    margin-bottom: 3px;
}

.progress-label-left { color: var(--text-muted); }
.progress-label-right { color: var(--neon-cyan); font-family: 'Orbitron', monospace; }

.progress-bar-container {
    height: 8px;
    background: var(--void-elevated);
    border-radius: 4px;
    overflow: hidden;
}

.progress-bar-fill {
    height: 100%;
    border-radius: 4px;
    transition: width 0.3s;
}

.progress-bar-fill.evo { background: var(--gradient-energy); }
.progress-bar-fill.stage { background: linear-gradient(90deg, var(--neon-purple), var(--neon-pink)); }

.hud-buttons { display: flex; gap: 8px; }

.hud-btn {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(10, 10, 26, 0.92);
    border: 1px solid var(--border-default);
    border-radius: 10px;
    font-size: 1.1rem;
    cursor: pointer;
    backdrop-filter: blur(10px);
}

.hud-btn:active { transform: scale(0.95); }

.game-hud-bottom {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 50;
    padding: 12px 16px;
    padding-bottom: calc(75px + var(--safe-bottom));
    pointer-events: none;
}

.stage-progress-bar {
    background: rgba(10, 10, 26, 0.9);
    border: 1px solid var(--border-default);
    border-radius: 12px;
    padding: 10px 14px;
    backdrop-filter: blur(10px);
    max-width: 360px;
    margin: 0 auto;
}

.stage-label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
}

.stage-current {
    font-family: 'Orbitron', monospace;
    font-size: 0.7rem;
    color: var(--neon-purple);
}

.stage-next { font-size: 0.65rem; color: var(--text-muted); }

.stage-bar {
    height: 8px;
    background: var(--void-elevated);
    border-radius: 4px;
    overflow: hidden;
}

.stage-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--neon-purple), var(--neon-pink));
    border-radius: 4px;
    transition: width 0.3s;
}

.mobile-controls {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 50;
    padding: 16px;
    padding-bottom: calc(16px + var(--safe-bottom));
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    pointer-events: none;
}

.joystick-container {
    width: 110px;
    height: 110px;
    position: relative;
    pointer-events: auto;
}

.joystick-base {
    width: 100%;
    height: 100%;
    background: rgba(10, 10, 26, 0.6);
    border: 2px solid var(--border-default);
    border-radius: 50%;
}

.joystick-knob {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 45px;
    height: 45px;
    margin: -22.5px 0 0 -22.5px;
    background: var(--gradient-energy);
    border-radius: 50%;
    box-shadow: 0 4px 15px rgba(0, 245, 212, 0.4);
    transition: transform 0.05s;
}

.action-btn {
    width: 70px;
    height: 70px;
    background: rgba(10, 10, 26, 0.8);
    border: 2px solid var(--neon-cyan);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    cursor: pointer;
    pointer-events: auto;
    box-shadow: 0 0 15px rgba(0, 245, 212, 0.3);
}

.action-btn:active { transform: scale(0.95); background: rgba(0, 245, 212, 0.2); }

.toast-container {
    position: fixed;
    top: calc(16px + var(--safe-top));
    left: 50%;
    transform: translateX(-50%);
    z-index: 300;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    pointer-events: none;
}

.toast {
    background: var(--void-elevated);
    border: 1px solid var(--border-default);
    border-radius: 12px;
    padding: 10px 16px;
    display: flex;
    align-items: center;
    gap: 8px;
    animation: toastIn 0.3s ease, toastOut 0.3s ease 2.5s forwards;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    font-size: 0.9rem;
}

.toast.success { border-color: var(--success); }
.toast.danger { border-color: var(--danger); }
.toast.warning { border-color: var(--warning); }
.toast.legendary { border-color: var(--legendary); background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,140,0,0.1)); }

@keyframes toastIn {
    from { transform: translateY(-20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

@keyframes toastOut {
    from { opacity: 1; }
    to { opacity: 0; }
}

.evo-alert {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    z-index: 250;
    background: rgba(10, 10, 26, 0.98);
    border: 2px solid var(--neon-cyan);
    border-radius: 20px;
    padding: 28px 40px;
    text-align: center;
    opacity: 0;
    transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.evo-alert.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
}

.evo-alert-icon { font-size: 3.5rem; margin-bottom: 10px; }

.evo-alert-title {
    font-family: 'Orbitron', monospace;
    font-size: 1.3rem;
    font-weight: 900;
    background: var(--gradient-energy);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 6px;
}

.evo-alert-desc { color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 6px; }
.evo-alert-effect { color: var(--neon-cyan); font-size: 0.8rem; font-weight: 600; }

.gameover-modal {
    position: fixed;
    inset: 0;
    z-index: 300;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 24px;
    background: rgba(3, 3, 8, 0.95);
}

.gameover-content { text-align: center; max-width: 340px; }
.gameover-icon { font-size: 4.5rem; margin-bottom: 14px; }

.gameover-title {
    font-family: 'Orbitron', monospace;
    font-size: 1.8rem;
    font-weight: 900;
    color: var(--danger);
    margin-bottom: 10px;
}

.gameover-title.success { color: var(--success); }

.gameover-desc { color: var(--text-secondary); margin-bottom: 20px; line-height: 1.6; }

.gameover-stats {
    background: var(--void-surface);
    border-radius: 12px;
    padding: 14px;
    margin-bottom: 20px;
}

.gameover-stat {
    display: flex;
    justify-content: space-between;
    padding: 6px 0;
    border-bottom: 1px solid var(--border-subtle);
    font-size: 0.9rem;
}

.gameover-stat:last-child { border-bottom: none; }
.gameover-stat-label { color: var(--text-muted); }
.gameover-stat-value { font-family: 'Orbitron', monospace; color: var(--neon-cyan); }

.title-page, .save-page {
    position: fixed;
    inset: 0;
    z-index: 100;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 24px;
    text-align: center;
}

.save-page {
    justify-content: flex-start;
    padding-top: calc(24px + var(--safe-top));
    overflow-y: auto;
}

.title-logo { font-size: 4.5rem; margin-bottom: 14px; animation: float 3s ease-in-out infinite; }

.title-main {
    font-family: 'Orbitron', monospace;
    font-size: clamp(2.2rem, 9vw, 3.5rem);
    font-weight: 900;
    background: var(--gradient-energy);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 6px;
}

.title-sub { font-family: 'Orbitron', monospace; font-size: 1rem; color: var(--text-secondary); margin-bottom: 28px; }
.title-tagline { font-size: 0.9rem; color: var(--text-muted); line-height: 1.7; max-width: 280px; margin-bottom: 40px; }
.title-buttons { display: flex; flex-direction: column; gap: 12px; width: 100%; max-width: 260px; }

.save-header { display: flex; align-items: center; justify-content: space-between; width: 100%; max-width: 460px; margin-bottom: 20px; }
.save-title { font-family: 'Orbitron', monospace; font-size: 1.2rem; }
.save-slots { display: flex; flex-direction: column; gap: 12px; max-width: 460px; width: 100%; }

.save-slot {
    background: var(--void-surface);
    border: 2px solid var(--border-subtle);
    border-radius: 14px;
    padding: 14px;
    text-align: left;
}

.save-slot.empty { border-style: dashed; opacity: 0.6; text-align: center; padding: 28px 14px; cursor: pointer; }
.save-slot.empty:hover { opacity: 0.8; }
.save-slot-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
.save-slot-number { font-family: 'Orbitron', monospace; font-size: 0.65rem; color: var(--text-muted); background: var(--void-light); padding: 3px 7px; border-radius: 5px; }
.save-slot-name { font-family: 'Orbitron', monospace; font-weight: 600; margin-bottom: 3px; font-size: 0.95rem; }
.save-slot-info { font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 10px; }
.save-slot-actions { display: flex; gap: 8px; }

.delete-btn {
    padding: 8px 14px;
    background: rgba(239, 68, 68, 0.2);
    border: 1px solid var(--danger);
    border-radius: 8px;
    color: var(--danger);
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s;
}

.delete-btn:hover { background: rgba(239, 68, 68, 0.4); }
.delete-btn:active { transform: scale(0.95); }

.settings-modal {
    position: fixed;
    inset: 0;
    z-index: 400;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 24px;
    background: rgba(3,3,8,0.95);
}

.settings-content {
    background: var(--void-surface);
    border: 1px solid var(--border-default);
    border-radius: 18px;
    padding: 22px;
    max-width: 380px;
    width: 100%;
    max-height: 80vh;
    overflow-y: auto;
}

.settings-title { font-family: 'Orbitron', monospace; font-size: 1.2rem; text-align: center; margin-bottom: 22px; }
.settings-section { margin-bottom: 22px; }
.settings-section-title { font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 10px; }
.settings-row { display: flex; align-items: center; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid var(--border-subtle); }

.volume-slider {
    -webkit-appearance: none;
    width: 90px;
    height: 6px;
    background: var(--void-light);
    border-radius: 3px;
}

.volume-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    background: var(--gradient-energy);
    border-radius: 50%;
    cursor: pointer;
}

.toggle {
    width: 46px;
    height: 26px;
    background: var(--void-light);
    border-radius: 13px;
    cursor: pointer;
    position: relative;
}

.toggle.active { background: var(--neon-cyan); }

.toggle-knob {
    position: absolute;
    top: 3px;
    left: 3px;
    width: 20px;
    height: 20px;
    background: white;
    border-radius: 50%;
    transition: transform 0.2s;
}

.toggle.active .toggle-knob { transform: translateX(20px); }

/* ë‹¤ì„¸í¬ ê²Œì„ ì „ìš© ìŠ¤íƒ€ì¼ */
.climb-hud {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 50;
    padding: 12px 16px;
    padding-top: calc(12px + var(--safe-top));
    display: flex;
    justify-content: space-between;
    align-items: center;
    pointer-events: none;
}

.climb-hud > * { pointer-events: auto; }

.climb-info {
    background: rgba(10, 10, 26, 0.92);
    border: 1px solid var(--border-default);
    border-radius: 12px;
    padding: 10px 14px;
    backdrop-filter: blur(10px);
}

.climb-height {
    font-family: 'Orbitron', monospace;
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--neon-cyan);
}

.climb-height-label {
    font-size: 0.7rem;
    color: var(--text-muted);
}

.climb-goal {
    background: rgba(10, 10, 26, 0.92);
    border: 1px solid var(--neon-purple);
    border-radius: 12px;
    padding: 10px 14px;
    backdrop-filter: blur(10px);
    text-align: center;
}

.climb-goal-text {
    font-size: 0.7rem;
    color: var(--text-muted);
}

.climb-goal-value {
    font-family: 'Orbitron', monospace;
    font-size: 0.9rem;
    color: var(--neon-purple);
}
    </style>
</head>
<body>
    <div id="stars-bg"></div>
    <div id="app"></div>
    <div class="toast-container" id="toast-container"></div>
    <div class="evo-alert" id="evo-alert">
        <div class="evo-alert-icon" id="evo-alert-icon">ğŸ§¬</div>
        <div class="evo-alert-title" id="evo-alert-title">ì§„í™”!</div>
        <div class="evo-alert-desc" id="evo-alert-desc">ì„¤ëª…</div>
        <div class="evo-alert-effect" id="evo-alert-effect">íš¨ê³¼</div>
    </div>

<script>
/* ========================================
   Constants
======================================== */
const GROWTH_THRESHOLD = 20;
const STAGE_THRESHOLD = 500;
const INITIAL_SIZE = 12;
const MAX_SIZE = 80;
const ENEMY_SPAWN_INTERVAL = 3500;
const MAX_ENEMIES = 7;
const MAX_FOODS = 35;

// ìœ¡ì§€ ì˜¬ë¼ê°€ê¸° ëª©í‘œ ë†’ì´
const LAND_HEIGHT = 1000;

const BODY_PARTS = {
    eye: { icon: 'ğŸ‘ï¸', name: 'ëˆˆ', maxCount: 3, effect: 'ì‹œì•¼ +20%' },
    mouth: { icon: 'ğŸ‘„', name: 'ì…', maxCount: 2, effect: 'ì„­ì·¨ ì†ë„ +15%' },
    arm: { icon: 'ğŸ¦¾', name: 'íŒ”', maxCount: 4, effect: 'ìì„ íš¨ê³¼' },
    leg: { icon: 'ğŸ¦¿', name: 'ë‹¤ë¦¬', maxCount: 4, effect: 'ì†ë„ +10%' },
    tail: { icon: 'ğŸ', name: 'ê¼¬ë¦¬', maxCount: 2, effect: 'ëŒ€ì‹œ ê°€ëŠ¥' },
    ear: { icon: 'ğŸ‘‚', name: 'ê·€', maxCount: 2, effect: 'ì  ê°ì§€' },
    nose: { icon: 'ğŸ‘ƒ', name: 'ì½”', maxCount: 2, effect: 'ë¨¹ì´ íƒì§€' },
    antenna: { icon: 'ğŸ“¡', name: 'ë”ë“¬ì´', maxCount: 2, effect: 'ë²”ìœ„ +15%' }
};

const Environments = [
    { id: 'ocean', name: 'ì›ì‹œ í•´ì–‘', icon: 'ğŸŒŠ', range: [1, 16], 
      colors: { bg1: '#001a33', bg2: '#003366', particle: '#00aaff', food: '#00ff88', enemy: '#ff4444' },
      desc: 'ë°”ë‹¤ëŠ” ìƒëª…ì˜ ìš”ëŒ.', weak: 'ê±´ì¡°í•œ í™˜ê²½ì€ ì¹˜ëª…ì .', creatures: ['ğŸ¦ ', 'ğŸ«§', 'ğŸ’§', 'ğŸŒ€'] },
    { id: 'hydrothermal', name: 'ì—´ìˆ˜êµ¬', icon: 'ğŸ”¥', range: [17, 32],
      colors: { bg1: '#1a0a00', bg2: '#4d1a00', particle: '#ff6600', food: '#ffaa00', enemy: '#00ffff' },
      desc: 'ê·¹í•œ í™˜ê²½ì´ ì¼ìƒ.', weak: 'í‰ì˜¨í•¨ì´ ì˜¤íˆë ¤ ë¶ˆì•ˆ.', creatures: ['ğŸ”´', 'ğŸŸ ', 'ğŸ’¥', 'âš¡'] },
    { id: 'ice', name: 'ì–¼ìŒ ë°”ë‹¤', icon: 'ğŸ§Š', range: [33, 48],
      colors: { bg1: '#0a1a2e', bg2: '#1a3a5e', particle: '#88ddff', food: '#aaeeff', enemy: '#ff6666' },
      desc: 'íš¨ìœ¨ì˜ ë‹¬ì¸.', weak: 'ëœ¨ê±°ì›€ì€ ì¹˜ëª…ì .', creatures: ['â„ï¸', 'ğŸ”µ', 'ğŸ’ ', 'ğŸ«§'] },
    { id: 'magma', name: 'ë§ˆê·¸ë§ˆ í˜¸ìˆ˜', icon: 'ğŸŒ‹', range: [49, 64],
      colors: { bg1: '#1a0000', bg2: '#4d0000', particle: '#ff3300', food: '#ffff00', enemy: '#00aaff' },
      desc: 'ìš©ì•”ì´ ë†€ì´í„°.', weak: 'ì–¼ìŒì´ ë¬´ë¤.', creatures: ['ğŸ”¥', 'ğŸŸ¡', 'â­', 'ğŸ’›'] },
    { id: 'atmosphere', name: 'ëŒ€ê¸° ë¶€ìœ ', icon: 'â˜ï¸', range: [65, 80],
      colors: { bg1: '#1a1033', bg2: '#2d1a4d', particle: '#cc88ff', food: '#ffaaff', enemy: '#ff4444' },
      desc: 'í•˜ëŠ˜ì„ ë‚˜ëŠ” ì.', weak: 'ë¬´ê±°ì›€ì´ ì .', creatures: ['ğŸ’œ', 'ğŸŸ£', 'âœ¨', 'ğŸ’«'] },
    { id: 'toxic', name: 'ë…ì„± ëŠª', icon: 'ğŸ’€', range: [81, 100],
      colors: { bg1: '#0a1a0a', bg2: '#1a3a1a', particle: '#88ff00', food: '#aaff44', enemy: '#ff00ff' },
      desc: 'ë…ì´ ê³§ ì•½.', weak: 'ê¹¨ë—í•¨ì´ ë¶ˆí¸.', creatures: ['ğŸŸ¢', 'ğŸ’š', 'ğŸ§ª', 'â˜¢ï¸'] }
];

/* ========================================
   Audio System
======================================== */
const Audio = (() => {
    let ctx = null;
    const settings = { master: 0.7, sfx: 0.8, sfxOn: true };
    
    const init = () => {
        if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (ctx.state === 'suspended') ctx.resume();
    };
    
    const vol = () => settings.sfxOn ? settings.sfx * settings.master : 0;
    
    const tone = (freq, dur, type = 'sine', v = 0.3) => {
        if (!settings.sfxOn || !ctx) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(vol() * v, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + dur);
        osc.start();
        osc.stop(ctx.currentTime + dur);
    };
    
    const playDiceRoll = () => { init(); for (let i = 0; i < 8; i++) setTimeout(() => tone(200 + Math.random() * 400, 0.05, 'square', 0.2), i * 50); };
    const playDiceResult = (s) => { init(); if (s) { tone(400, 0.15); setTimeout(() => tone(600, 0.15), 100); setTimeout(() => tone(800, 0.2), 200); } else { tone(300, 0.3, 'sawtooth'); setTimeout(() => tone(150, 0.4, 'sawtooth'), 150); } };
    const playEat = () => { init(); tone(600, 0.06); setTimeout(() => tone(800, 0.08), 40); };
    const playEatBig = () => { init(); tone(400, 0.1); setTimeout(() => tone(600, 0.1), 60); setTimeout(() => tone(800, 0.15), 120); };
    const playEvolve = () => { init(); [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => tone(f, 0.3, 'sine', 0.4), i * 120)); };
    const playClick = () => { init(); tone(500, 0.06, 'sine', 0.2); };
    const playDeath = () => { init(); [400, 300, 200, 100].forEach((f, i) => setTimeout(() => tone(f, 0.3, 'sawtooth', 0.4), i * 150)); };
    const playJump = () => { init(); tone(400, 0.1); setTimeout(() => tone(600, 0.08), 50); };
    const playLand = () => { init(); tone(300, 0.15, 'square', 0.2); };
    const playWin = () => { init(); [523, 659, 784, 1047, 1318].forEach((f, i) => setTimeout(() => tone(f, 0.4, 'sine', 0.5), i * 150)); };
    
    const load = () => { try { Object.assign(settings, JSON.parse(localStorage.getItem('bokluck_audio') || '{}')); } catch {} };
    const save = () => { localStorage.setItem('bokluck_audio', JSON.stringify(settings)); };
    
    load();
    return { init, settings, save, playDiceRoll, playDiceResult, playEat, playEatBig, playEvolve, playClick, playDeath, playJump, playLand, playWin };
})();

/* ========================================
   Save System
======================================== */
const Save = (() => {
    const KEY = 'bokluck_save_';
    const MAX = 5;
    
    const newGame = () => ({
        version: 3,
        created: Date.now(),
        updated: Date.now(),
        playTime: 0,
        stage: 0, // 0: íŠœí† ë¦¬ì–¼ì „, 1: ì„¸í¬, 2: ë‹¤ì„¸í¬(ìœ¡ì§€ì˜¬ë¼ê°€ê¸°), 3: ìœ¡ì§€ë„ë‹¬
        tutorialDone: false,
        name: null,
        score: 0,
        dna: { origin: null, traits: [] },
        design: null,
        bodyParts: {
            eye: 0, mouth: 0, arm: 0, leg: 0,
            tail: 0, ear: 0, nose: 0, antenna: 0
        },
        stats: { size: INITIAL_SIZE, speed: 3, eaten: 0, deaths: 0, maxSize: INITIAL_SIZE, maxHeight: 0 },
        history: []
    });
    
    const get = (i) => { try { return JSON.parse(localStorage.getItem(KEY + i)); } catch { return null; } };
    const set = (i, d) => { d.updated = Date.now(); localStorage.setItem(KEY + i, JSON.stringify(d)); };
    const del = (i) => { localStorage.removeItem(KEY + i); };
    const all = () => Array.from({ length: MAX }, (_, i) => get(i));
    const formatDate = (ts) => ts ? new Date(ts).toLocaleDateString('ko-KR', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) : '-';
    
    return { MAX, newGame, get, set, del, all, formatDate };
})();

/* ========================================
   Game State
======================================== */
let State = { slot: null, data: null, sessionStart: 0 };

const loadSlot = (i) => { State.slot = i; State.data = Save.get(i); State.sessionStart = Date.now(); };
const saveGame = () => { if (State.slot !== null && State.data) { State.data.playTime += Date.now() - State.sessionStart; State.sessionStart = Date.now(); Save.set(State.slot, State.data); } };
const newGame = (i) => { State.slot = i; State.data = Save.newGame(); State.sessionStart = Date.now(); Save.set(i, State.data); };

const getEnvByRoll = (r) => Environments.find(e => r >= e.range[0] && r <= e.range[1]);
const getEnvById = (id) => Environments.find(e => e.id === id);

/* ========================================
   UI Helpers
======================================== */
const app = document.getElementById('app');

const createStars = () => {
    const c = document.getElementById('stars-bg');
    c.innerHTML = '';
    for (let i = 0; i < 80; i++) {
        const s = document.createElement('div');
        s.className = 'star';
        s.style.cssText = `left:${Math.random()*100}%;top:${Math.random()*100}%;width:${Math.random()*2+1}px;height:${s.style.width};--dur:${Math.random()*3+2}s;animation-delay:${Math.random()*3}s;`;
        c.appendChild(s);
    }
};

const toast = (msg, type = 'info') => {
    const c = document.getElementById('toast-container');
    const t = document.createElement('div');
    t.className = `toast ${type}`;
    const icons = { success: 'âœ…', danger: 'ğŸ’€', warning: 'âš ï¸', legendary: 'â­', info: 'â„¹ï¸' };
    t.innerHTML = `<span>${icons[type] || 'â„¹ï¸'}</span><span>${msg}</span>`;
    c.appendChild(t);
    setTimeout(() => t.remove(), 3000);
};

const showEvoAlert = (icon, title, desc, effect) => {
    const el = document.getElementById('evo-alert');
    document.getElementById('evo-alert-icon').textContent = icon;
    document.getElementById('evo-alert-title').textContent = title;
    document.getElementById('evo-alert-desc').textContent = desc;
    document.getElementById('evo-alert-effect').textContent = effect;
    el.classList.add('show');
    Audio.playEvolve();
    setTimeout(() => el.classList.remove('show'), 2200);
};

/* ========================================
   Body Parts System
======================================== */
const getTotalParts = () => {
    if (!State.data?.bodyParts) return 0;
    return Object.values(State.data.bodyParts).reduce((a, b) => a + b, 0);
};

const getNextPartThreshold = () => {
    const total = getTotalParts();
    return (total + 1) * GROWTH_THRESHOLD;
};

const addRandomPart = () => {
    const parts = State.data.bodyParts;
    const available = Object.keys(BODY_PARTS).filter(key => 
        parts[key] < BODY_PARTS[key].maxCount
    );
    
    if (available.length === 0) return null;
    
    const chosen = available[Math.floor(Math.random() * available.length)];
    parts[chosen]++;
    
    return { key: chosen, ...BODY_PARTS[chosen], count: parts[chosen] };
};

const hasPart = (key) => State.data?.bodyParts?.[key] > 0;
const getPartCount = (key) => State.data?.bodyParts?.[key] || 0;

/* ========================================
   Story System
======================================== */
const StorySequences = {
    intro: [
        { icon: 'ğŸŒŒ', title: 'íƒœì´ˆì—...', text: 'ëì—†ì´ í¼ì³ì§„ <span class="highlight">ìš°ì£¼ì˜ ì‹¬ì—°</span>...<br><br>ê·¸ ì–´ë”˜ê°€ì—ì„œ, ì•„ì£¼ ì‘ì€ <span class="golden">ë¶ˆê½ƒ</span>ì´ í”¼ì–´ì˜¤ë¥´ë ¤ í•œë‹¤.' },
        { icon: 'âœ¨', title: 'ì˜ì‹ì˜ íƒ„ìƒ', text: 'ë‹¹ì‹ ì€ ì•„ì§ <span class="highlight">ì•„ë¬´ê²ƒë„ ì•„ë‹ˆë‹¤</span>.<br><br>í˜•íƒœë„, ì´ë¦„ë„ ì—†ë‹¤.<br>ì˜¤ì§ <span class="golden">ì¡´ì¬í•˜ê³ ì í•˜ëŠ” ì˜ì§€</span>ë§Œì´ ê¹œë¹¡ì¸ë‹¤.' },
        { icon: 'ğŸ²', title: 'ìš´ëª…ì˜ ì£¼ì‚¬ìœ„', text: 'ì´ ìš°ì£¼ì—ì„œëŠ” <span class="highlight">BOK(ë³µ)</span>ê³¼ <span class="danger">LUCK(ìš´)</span>ì´<br>ëª¨ë“  ê²ƒì„ ê²°ì •í•œë‹¤.<br><br>ë‹¹ì‹ ì´ <span class="golden">ì–´ë””ì„œ íƒœì–´ë‚ ì§€</span>ì¡°ì°¨<br>ìš´ëª…ì˜ ì£¼ì‚¬ìœ„ê°€ ê²°ì •í•  ê²ƒì´ë‹¤.' },
        { icon: 'ğŸŒŠ', title: 'ì—¬ì„¯ ê°œì˜ ìš”ëŒ', text: 'ì›ì‹œ í•´ì–‘, ì—´ìˆ˜êµ¬, ì–¼ìŒ ë°”ë‹¤,<br>ë§ˆê·¸ë§ˆ í˜¸ìˆ˜, ëŒ€ê¸°ì¸µ, ë…ì„± ëŠª...<br><br>ì—¬ì„¯ ê°œì˜ <span class="highlight">ìƒëª…ì˜ ìš”ëŒ</span> ì¤‘ í•˜ë‚˜ê°€<br>ë‹¹ì‹ ì˜ <span class="golden">ì²« ë²ˆì§¸ ê³ í–¥</span>ì´ ë  ê²ƒì´ë‹¤.' }
    ],
    afterBirth: (env) => [
        { icon: env.icon, title: env.name, text: `ë‹¹ì‹ ì€ <span class="highlight">${env.name}</span>ì—ì„œ íƒœì–´ë‚¬ë‹¤.<br><br><span class="golden">"${env.desc}"</span><br><span class="danger">âš ï¸ ${env.weak}</span>` },
        { icon: 'ğŸ¦ ', title: 'ì²« ë²ˆì§¸ ìƒëª…', text: 'ì•„ì£¼ ì‘ê³ , ì—°ì•½í•œ <span class="highlight">í•˜ë‚˜ì˜ ì„¸í¬</span>.<br>ê·¸ê²ƒì´ ì§€ê¸ˆì˜ ë‹¹ì‹ ì´ë‹¤.<br><br>ì‚´ì•„ë‚¨ìœ¼ë ¤ë©´ <span class="golden">ë¨¹ì–´ì•¼ í•œë‹¤</span>.' },
        { icon: 'âš”ï¸', title: 'ê²½ìŸê³¼ ìƒì¡´', text: 'í•˜ì§€ë§Œ ë‹¹ì‹ ë§Œ ë°°ê³ í”ˆ ê²Œ ì•„ë‹ˆë‹¤.<br><br><span class="danger">ë” í° ì¡´ì¬</span>ë“¤ì´ ë‹¹ì‹ ì„ ë…¸ë¦°ë‹¤.<br><span class="highlight">ì‘ì€ ê²ƒ</span>ì„ ë¨¹ê³  <span class="golden">ì»¤ì ¸ì•¼</span> ì‚´ì•„ë‚¨ëŠ”ë‹¤.' },
        { icon: 'ğŸ§¬', title: 'ì§„í™”ì˜ ì‹œì‘', text: 'ì¶©ë¶„íˆ ë¨¹ìœ¼ë©´ ëª¸ì´ ë³€í•œë‹¤.<br><br><span class="golden">ëˆˆ</span>ì´ ìƒê¸°ê³ , <span class="golden">íŒ”ë‹¤ë¦¬</span>ê°€ ìë¼ê³ ,<br><span class="golden">ê¼¬ë¦¬</span>ê°€ ë»—ì–´ë‚˜ê°ˆ ê²ƒì´ë‹¤.<br><br>ì–´ë–¤ í˜•íƒœë¡œ ì§„í™”í• ì§€ëŠ”... <span class="highlight">ìš´ëª…</span>ì´ ê²°ì •í•œë‹¤.' }
    ],
    multicellular: [
        { icon: 'ğŸ§¬', title: 'ë‹¤ì„¸í¬ ì§„í™”!', text: 'ìˆ˜ë§ì€ ì‹œí–‰ì°©ì˜¤ ëì—...<br>ë‹¹ì‹ ì€ ë§ˆì¹¨ë‚´ <span class="highlight">ë‹¨ì¼ ì„¸í¬</span>ì˜ í•œê³„ë¥¼ ë„˜ì–´ì„°ë‹¤.' },
        { icon: 'ğŸ”ï¸', title: 'ìƒˆë¡œìš´ ë„ì „', text: 'ì´ì œ ë‹¹ì‹  ì•ì—ëŠ” <span class="golden">ìƒˆë¡œìš´ ì—¬ì •</span>ì´ í¼ì³ì§„ë‹¤.<br><br>ë°”ë‹¤ ê¹Šì€ ê³³ì—ì„œ <span class="highlight">ìœ¡ì§€</span>ê¹Œì§€...<br>ëì—†ì´ ì˜¬ë¼ê°€ì•¼ í•œë‹¤.' },
        { icon: 'ğŸ¦˜', title: 'ì í”„ì™€ ë°œíŒ', text: '<span class="highlight">ë°œíŒ</span>ì„ ë°Ÿê³  ìœ„ë¡œ ì˜¬ë¼ê°€ë¼.<br><br>ë–¨ì–´ì§€ë©´ ë‹¤ì‹œ ì‹œì‘ì´ë‹¤.<br><span class="golden">ìœ¡ì§€</span>ì— ë„ë‹¬í•˜ë©´ ìƒˆë¡œìš´ ì„¸ê³„ê°€ ì—´ë¦°ë‹¤!' }
    ]
};

const renderStory = (seqId, onComplete = null) => {
    let seq = StorySequences[seqId];
    if (typeof seq === 'function') seq = seq(getEnvById(State.data?.dna?.origin));
    let idx = 0;
    
    const render = () => {
        const s = seq[idx];
        const isLast = idx === seq.length - 1;
        
        app.innerHTML = `
            <div class="story-overlay">
                <div class="story-content">
                    <div class="story-icon">${s.icon}</div>
                    <h2 class="story-title">${s.title}</h2>
                    <div class="story-text">${s.text}</div>
                    <div class="story-indicator">${seq.map((_, i) => `<div class="story-dot ${i < idx ? 'done' : ''} ${i === idx ? 'active' : ''}"></div>`).join('')}</div>
                    <button class="btn btn-energy" id="btn-next">${isLast ? (seqId === 'multicellular' ? 'ğŸ”ï¸ ìœ¡ì§€ë¡œ ì´ë™í•˜ê¸°' : 'ì‹œì‘í•˜ê¸° â†’') : 'ë‹¤ìŒ â†’'}</button>
                </div>
            </div>
        `;
        
        document.getElementById('btn-next').onclick = () => {
            Audio.playClick();
            if (isLast) {
                if (onComplete) onComplete();
                else if (seqId === 'intro') renderDiceRoll();
                else if (seqId === 'afterBirth') { State.data.tutorialDone = true; saveGame(); startCellWorld(); }
                else if (seqId === 'multicellular') { startClimbGame(); }
            } else { idx++; render(); }
        };
    };
    render();
};

/* ========================================
   Dice Roll
======================================== */
const renderDiceRoll = () => {
    let rolling = false;
    
    app.innerHTML = `
        <div class="dice-modal">
            <div class="dice-container">
                <h2 style="font-family:Orbitron;font-size:1.2rem;background:var(--gradient-energy);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:8px;">ğŸ² ìš´ëª…ì˜ ì£¼ì‚¬ìœ„</h2>
                <p style="color:var(--text-secondary);margin-bottom:12px;font-size:0.9rem;">ë‹¹ì‹ ì´ íƒœì–´ë‚  ê³³ì´ ê²°ì •ë©ë‹ˆë‹¤</p>
                <div class="dice-visual" id="dice-visual">ğŸ²</div>
                <div id="dice-result"></div>
                <button class="btn btn-energy btn-block" id="btn-roll">ìš´ëª…ì„ ë°›ì•„ë“¤ì¸ë‹¤</button>
            </div>
        </div>
    `;
    
    const dv = document.getElementById('dice-visual');
    const dr = document.getElementById('dice-result');
    const btn = document.getElementById('btn-roll');
    
    btn.onclick = () => {
        if (rolling) return;
        rolling = true;
        btn.disabled = true;
        btn.textContent = 'ìš´ëª…ì„ ê²°ì •í•˜ëŠ” ì¤‘...';
        dv.classList.add('rolling');
        Audio.playDiceRoll();
        
        const anim = setInterval(() => { dv.textContent = Math.floor(Math.random() * 100) + 1; }, 50);
        
        setTimeout(() => {
            clearInterval(anim);
            dv.classList.remove('rolling');
            
            const roll = Math.floor(Math.random() * 100) + 1;
            const env = getEnvByRoll(roll);
            
            dv.textContent = roll;
            dv.style.cssText = 'font-size:3.5rem;font-family:Orbitron;font-weight:900;color:var(--neon-cyan);text-shadow:0 0 30px var(--neon-cyan);';
            
            Audio.playDiceResult(true);
            
            dr.innerHTML = `
                <div style="text-align:center;margin:20px 0;">
                    <div style="font-size:3.5rem;margin-bottom:8px;">${env.icon}</div>
                    <div style="font-family:Orbitron;font-size:1.4rem;font-weight:700;margin-bottom:6px;">${env.name}</div>
                    <div style="color:var(--text-secondary);font-size:0.85rem;">${env.desc}</div>
                </div>
            `;
            
            btn.disabled = false;
            btn.textContent = 'ì´ ìš´ëª…ì„ ë°›ì•„ë“¤ì¸ë‹¤';
            btn.onclick = () => {
                Audio.playClick();
                State.data.dna.origin = env.id;
                State.data.dna.traits.push(`${env.id.toUpperCase()}_NATIVE`);
                State.data.stage = 1;
                State.data.score = 0;
                State.data.name = generateName(env.id);
                State.data.design = generateDesign(env.id);
                State.data.bodyParts = { eye: 0, mouth: 0, arm: 0, leg: 0, tail: 0, ear: 0, nose: 0, antenna: 0 };
                State.data.stats = { size: INITIAL_SIZE, speed: 3, eaten: 0, deaths: State.data.stats?.deaths || 0, maxSize: INITIAL_SIZE, maxHeight: 0 };
                State.data.history.push({ chapter: 1, title: 'íƒ„ìƒ', content: `${env.name}ì—ì„œ ìƒëª…ì´ ê¹¨ì–´ë‚¬ë‹¤.`, time: Date.now() });
                saveGame();
                renderStory('afterBirth');
            };
        }, 1500);
    };
};

const generateName = (envId) => {
    const pre = { ocean: ['í‘¸ë¥¸', 'ê¹Šì€', 'íë¥´ëŠ”'], hydrothermal: ['ëœ¨ê±°ìš´', 'íƒ€ì˜¤ë¥´ëŠ”', 'ë¶ˆê½ƒ'], ice: ['ì°¨ê°€ìš´', 'ì–¼ì–´ë¶™ì€', 'ì„œë¦¬'], magma: ['ì‘ì—´í•˜ëŠ”', 'ìš©ì•”', 'ë¶‰ì€'], atmosphere: ['ë– ë„ëŠ”', 'ë°”ëŒì˜', 'í•˜ëŠ˜'], toxic: ['ë…ì˜', 'ë§¹ë…', 'ì‚°ì„±'] };
    const suf = ['ì˜ì‹', 'ì„¸í¬', 'ì¡´ì¬', 'ì˜í˜¼', 'íŒŒë™'];
    const p = pre[envId] || pre.ocean;
    return p[Math.floor(Math.random() * p.length)] + ' ' + suf[Math.floor(Math.random() * suf.length)];
};

const generateDesign = (envId) => {
    const cols = { ocean: ['#00b4d8', '#0077b6'], hydrothermal: ['#ff6b35', '#d62828'], ice: ['#a8dadc', '#457b9d'], magma: ['#ff4800', '#ff8500'], atmosphere: ['#e0aaff', '#9d4edd'], toxic: ['#70e000', '#38b000'] };
    const c = cols[envId] || cols.ocean;
    return { primary: c[0], secondary: c[1], wobble: 0.5 + Math.random() * 0.5 };
};

/* ========================================
   Cell World Game (Stage 1)
======================================== */
let canvas, ctx;
let gameLoop = null;
let player = null;
let foods = [];
let enemies = [];
let particles = [];
let joystickPos = { x: 0, y: 0 };
let joystickActive = false;
let keys = {};
let lastEnemySpawn = 0;
let dashCooldown = 0;
let isDashing = false;

const startCellWorld = () => {
    const env = getEnvById(State.data.dna.origin);
    const parts = State.data.bodyParts;
    
    app.innerHTML = `
        <canvas id="game-canvas"></canvas>
        
        <div class="game-hud-top">
            <div class="hud-left-panel">
                <div class="hud-name" id="hud-name">${State.data.name}</div>
                <div class="hud-stat-row">
                    <span class="hud-stat-icon">âš¡</span>
                    <span class="hud-stat-value" id="hud-score">${State.data.score}</span>
                    <span class="hud-stat-label">ì ìˆ˜</span>
                </div>
                <div class="hud-stat-row">
                    <span class="hud-stat-icon">ğŸ´</span>
                    <span class="hud-stat-value" id="hud-eaten">${State.data.stats.eaten}</span>
                    <span class="hud-stat-label">ì„­ì·¨</span>
                </div>
                <div class="size-indicator">
                    <span style="font-size:0.65rem;">ğŸ“</span>
                    <div class="size-bar">
                        <div class="size-fill" id="size-fill" style="width:${(State.data.stats.size / MAX_SIZE) * 100}%"></div>
                    </div>
                    <span class="size-text" id="size-text">${Math.round(State.data.stats.size)}</span>
                </div>
            </div>
            
            <div class="hud-right-panel">
                <div class="hud-section-title">ğŸ§¬ ì‹ ì²´ íŒŒì¸ </div>
                <div class="body-parts-grid" id="body-parts-grid"></div>
                
                <div class="progress-section">
                    <div class="progress-label">
                        <span class="progress-label-left">ë‹¤ìŒ íŒŒì¸ </span>
                        <span class="progress-label-right" id="part-progress-text">0/${GROWTH_THRESHOLD}</span>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar-fill evo" id="part-progress" style="width:0%"></div>
                    </div>
                </div>
            </div>
            
            <div class="hud-buttons">
                <button class="hud-btn" id="btn-home" title="í™ˆìœ¼ë¡œ">ğŸ </button>
                <button class="hud-btn" id="btn-pause" title="ì¼ì‹œì •ì§€">â¸ï¸</button>
            </div>
        </div>
        
        <div class="game-hud-bottom">
            <div class="stage-progress-bar">
                <div class="stage-label">
                    <span class="stage-current">ğŸ¦  ì„¸í¬ ë‹¨ê³„</span>
                    <span class="stage-next">ë‹¤ì„¸í¬ê¹Œì§€: <span id="stage-progress-text">${State.data.score}/${STAGE_THRESHOLD}</span></span>
                </div>
                <div class="stage-bar">
                    <div class="stage-fill" id="stage-progress" style="width:${(State.data.score / STAGE_THRESHOLD) * 100}%"></div>
                </div>
            </div>
        </div>
        
        <div class="mobile-controls">
            <div class="joystick-container" id="joystick">
                <div class="joystick-base"></div>
                <div class="joystick-knob" id="joystick-knob"></div>
            </div>
            <button class="action-btn" id="dash-btn" style="${hasPart('tail') ? '' : 'opacity:0.3;border-color:var(--text-muted);'}">ğŸ’¨</button>
        </div>
    `;
    
    updateBodyPartsUI();
    
    canvas = document.getElementById('game-canvas');
    ctx = canvas.getContext('2d');
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    const legBonus = getPartCount('leg') * 0.4;
    player = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: State.data.stats.size,
        speed: State.data.stats.speed + legBonus,
        vx: 0,
        vy: 0
    };
    
    foods = [];
    enemies = [];
    particles = [];
    spawnFoods(MAX_FOODS);
    
    setupCellControls();
    setupCellHUDEvents();
    
    lastEnemySpawn = Date.now();
    gameLoop = requestAnimationFrame(updateCellWorld);
};

const updateBodyPartsUI = () => {
    const grid = document.getElementById('body-parts-grid');
    if (!grid) return;
    
    const parts = State.data.bodyParts;
    let html = '';
    
    Object.keys(BODY_PARTS).forEach(key => {
        const part = BODY_PARTS[key];
        const count = parts[key] || 0;
        if (count > 0) {
            html += `<div class="body-part active" title="${part.name}: ${part.effect}">
                <span class="body-part-icon">${part.icon}</span>
                <span class="body-part-count">Ã—${count}</span>
            </div>`;
        }
    });
    
    if (html === '') {
        html = '<div style="font-size:0.7rem;color:var(--text-muted);padding:4px;">íŒŒì¸  ì—†ìŒ</div>';
    }
    
    grid.innerHTML = html;
};

const resizeCanvas = () => { if (canvas) { canvas.width = window.innerWidth; canvas.height = window.innerHeight; } };

const spawnFoods = (count) => {
    const env = getEnvById(State.data.dna.origin);
    for (let i = 0; i < count; i++) {
        foods.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: 4 + Math.random() * 8,
            color: env.colors.food,
            vx: (Math.random() - 0.5) * 0.3,
            vy: (Math.random() - 0.5) * 0.3,
            type: env.creatures[Math.floor(Math.random() * env.creatures.length)]
        });
    }
};

const spawnEnemy = () => {
    const playerSize = player.size;
    const isSmaller = Math.random() < 0.4;
    let size = isSmaller ? playerSize * (0.3 + Math.random() * 0.5) : playerSize * (1.2 + Math.random() * 0.8);
    size = Math.max(8, Math.min(size, 100));
    
    let x, y;
    const side = Math.floor(Math.random() * 4);
    if (side === 0) { x = -50; y = Math.random() * canvas.height; }
    else if (side === 1) { x = canvas.width + 50; y = Math.random() * canvas.height; }
    else if (side === 2) { x = Math.random() * canvas.width; y = -50; }
    else { x = Math.random() * canvas.width; y = canvas.height + 50; }
    
    const enemyParts = {
        eye: Math.floor(Math.random() * 4),
        mouth: Math.floor(Math.random() * 3),
        arm: Math.floor(Math.random() * 5),
        leg: Math.floor(Math.random() * 5),
        tail: Math.floor(Math.random() * 3),
        antenna: Math.floor(Math.random() * 3)
    };
    
    enemies.push({
        x, y, size,
        speed: 1 + Math.random() * 1.5,
        angle: Math.random() * Math.PI * 2,
        wobble: Math.random(),
        parts: enemyParts
    });
};

const setupCellControls = () => {
    const joystick = document.getElementById('joystick');
    const knob = document.getElementById('joystick-knob');
    
    const handleMove = (cx, cy) => {
        const r = joystick.getBoundingClientRect();
        const centerX = r.left + r.width / 2;
        const centerY = r.top + r.height / 2;
        const maxDist = r.width / 2 - 22;
        
        let dx = cx - centerX;
        let dy = cy - centerY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }
        
        knob.style.transform = `translate(${dx}px, ${dy}px)`;
        joystickPos = { x: dx / maxDist, y: dy / maxDist };
    };
    
    const handleEnd = () => { joystickActive = false; knob.style.transform = ''; joystickPos = { x: 0, y: 0 }; };
    
    joystick.addEventListener('touchstart', (e) => { e.preventDefault(); joystickActive = true; handleMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    joystick.addEventListener('touchmove', (e) => { e.preventDefault(); if (joystickActive) handleMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    joystick.addEventListener('touchend', handleEnd);
    joystick.addEventListener('touchcancel', handleEnd);
    
    joystick.addEventListener('mousedown', (e) => { joystickActive = true; handleMove(e.clientX, e.clientY); });
    window.addEventListener('mousemove', (e) => { if (joystickActive) handleMove(e.clientX, e.clientY); });
    window.addEventListener('mouseup', handleEnd);
    
    window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; if (e.key === ' ') tryDash(); });
    window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
    
    document.getElementById('dash-btn').addEventListener('touchstart', (e) => { e.preventDefault(); tryDash(); });
    document.getElementById('dash-btn').addEventListener('click', tryDash);
};

const tryDash = () => {
    if (!hasPart('tail') || dashCooldown > 0 || isDashing) return;
    
    isDashing = true;
    dashCooldown = 3000;
    Audio.playJump();
    
    const dashSpeed = 15;
    const dashDir = { x: joystickPos.x || (keys.d ? 1 : keys.a ? -1 : 0), y: joystickPos.y || (keys.s ? 1 : keys.w ? -1 : 0) };
    const len = Math.sqrt(dashDir.x * dashDir.x + dashDir.y * dashDir.y) || 1;
    
    player.vx = (dashDir.x / len) * dashSpeed;
    player.vy = (dashDir.y / len) * dashSpeed;
    
    for (let i = 0; i < 10; i++) {
        particles.push({
            x: player.x, y: player.y,
            vx: -player.vx * 0.3 + (Math.random() - 0.5) * 3,
            vy: -player.vy * 0.3 + (Math.random() - 0.5) * 3,
            size: 5, color: State.data.design.primary, life: 20
        });
    }
    
    setTimeout(() => { isDashing = false; }, 200);
};

const setupCellHUDEvents = () => {
    document.getElementById('btn-home').onclick = () => {
        Audio.playClick();
        if (confirm('í™ˆìœ¼ë¡œ ëŒì•„ê°€ì‹œê² ìŠµë‹ˆê¹Œ?\nì§„í–‰ ìƒí™©ì´ ì €ì¥ë©ë‹ˆë‹¤.')) {
            cancelAnimationFrame(gameLoop);
            gameLoop = null;
            saveGame();
            renderSaveSelect();
        }
    };
    
    document.getElementById('btn-pause').onclick = () => {
        Audio.playClick();
        if (gameLoop) {
            cancelAnimationFrame(gameLoop);
            gameLoop = null;
            document.getElementById('btn-pause').textContent = 'â–¶ï¸';
            toast('ì¼ì‹œì •ì§€', 'info');
        } else {
            gameLoop = requestAnimationFrame(updateCellWorld);
            document.getElementById('btn-pause').textContent = 'â¸ï¸';
        }
    };
};

const updateCellWorld = () => {
    if (!canvas || !ctx) return;
    
    const env = getEnvById(State.data.dna.origin);
    const parts = State.data.bodyParts;
    
    if (dashCooldown > 0) dashCooldown -= 16;
    
    let inputX = joystickPos.x;
    let inputY = joystickPos.y;
    if (keys.w || keys.arrowup) inputY = -1;
    if (keys.s || keys.arrowdown) inputY = 1;
    if (keys.a || keys.arrowleft) inputX = -1;
    if (keys.d || keys.arrowright) inputX = 1;
    
    const legBonus = getPartCount('leg') * 0.4;
    const baseSpeed = State.data.stats.speed + legBonus;
    
    if (!isDashing) {
        player.vx = inputX * baseSpeed;
        player.vy = inputY * baseSpeed;
    } else {
        player.vx *= 0.95;
        player.vy *= 0.95;
    }
    
    player.x += player.vx;
    player.y += player.vy;
    player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
    player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));
    
    if (Date.now() - lastEnemySpawn > ENEMY_SPAWN_INTERVAL && enemies.length < MAX_ENEMIES) {
        spawnEnemy();
        lastEnemySpawn = Date.now();
    }
    
    const magnetRange = hasPart('arm') ? 80 + getPartCount('arm') * 20 : 0;
    
    for (let i = foods.length - 1; i >= 0; i--) {
        const food = foods[i];
        food.x += food.vx;
        food.y += food.vy;
        if (food.x < -30) food.x = canvas.width + 30;
        if (food.x > canvas.width + 30) food.x = -30;
        if (food.y < -30) food.y = canvas.height + 30;
        if (food.y > canvas.height + 30) food.y = -30;
        
        const dx = player.x - food.x;
        const dy = player.y - food.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (magnetRange > 0 && dist < magnetRange) {
            food.x += dx * 0.04;
            food.y += dy * 0.04;
        }
        
        if (dist < player.size + food.size * 0.4) {
            Audio.playEat();
            
            for (let j = 0; j < 5; j++) {
                particles.push({
                    x: food.x, y: food.y,
                    vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
                    size: 3, color: food.color, life: 25
                });
            }
            
            const sizeGain = food.size * 0.15;
            player.size = Math.min(MAX_SIZE, player.size + sizeGain);
            State.data.stats.size = player.size;
            State.data.stats.maxSize = Math.max(State.data.stats.maxSize, player.size);
            State.data.stats.eaten++;
            
            const mouthBonus = 1 + getPartCount('mouth') * 0.15;
            const baseScore = Math.floor(food.size * 2 * mouthBonus);
            State.data.score += baseScore;
            
            checkEvolution();
            
            foods.splice(i, 1);
            setTimeout(() => { if (foods.length < MAX_FOODS) spawnFoods(1); }, 500);
        }
    }
    
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        const isDangerous = enemy.size > player.size;
        
        if (isDangerous) {
            enemy.x += (dx / dist) * enemy.speed * 0.5;
            enemy.y += (dy / dist) * enemy.speed * 0.5;
        } else {
            enemy.x -= (dx / dist) * enemy.speed * 0.3;
            enemy.y -= (dy / dist) * enemy.speed * 0.3;
        }
        
        enemy.angle += (Math.random() - 0.5) * 0.1;
        enemy.x += Math.cos(enemy.angle) * enemy.speed * 0.3;
        enemy.y += Math.sin(enemy.angle) * enemy.speed * 0.3;
        
        if (enemy.x < -200 || enemy.x > canvas.width + 200 || enemy.y < -200 || enemy.y > canvas.height + 200) {
            enemies.splice(i, 1);
            continue;
        }
        
        if (dist < player.size + enemy.size * 0.6) {
            if (isDangerous) {
                gameOverCell();
                return;
            } else {
                Audio.playEatBig();
                
                for (let j = 0; j < 10; j++) {
                    particles.push({
                        x: enemy.x, y: enemy.y,
                        vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6,
                        size: 5, color: env.colors.food, life: 30
                    });
                }
                
                const sizeGain = enemy.size * 0.25;
                player.size = Math.min(MAX_SIZE, player.size + sizeGain);
                State.data.stats.size = player.size;
                State.data.stats.maxSize = Math.max(State.data.stats.maxSize, player.size);
                State.data.stats.eaten++;
                
                const mouthBonus = 1 + getPartCount('mouth') * 0.15;
                const baseScore = Math.floor(enemy.size * 5 * mouthBonus);
                State.data.score += baseScore;
                
                toast(`+${baseScore} í° ë¨¹ì´!`, 'success');
                checkEvolution();
                
                enemies.splice(i, 1);
            }
        }
    }
    
    particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.size *= 0.95;
        return p.life > 0;
    });
    
    renderCellWorld(env);
    updateCellHUD();
    
    if (Date.now() - State.sessionStart > 15000) saveGame();
    
    // ë‹¤ì„¸í¬ ì§„í™” ì²´í¬ (stageê°€ 1ì¼ ë•Œë§Œ!)
    if (State.data.stage === 1 && State.data.score >= STAGE_THRESHOLD && getTotalParts() >= 5) {
        evolveToMulticellular();
        return;
    }
    
    gameLoop = requestAnimationFrame(updateCellWorld);
};

const checkEvolution = () => {
    const eaten = State.data.stats.eaten;
    const nextThreshold = getNextPartThreshold();
    
    if (eaten >= nextThreshold) {
        const newPart = addRandomPart();
        if (newPart) {
            showEvoAlert(newPart.icon, `${newPart.name} íšë“!`, `${newPart.name}ì´(ê°€) ${newPart.count}ê°œê°€ ë˜ì—ˆë‹¤!`, newPart.effect);
            updateBodyPartsUI();
            
            if (newPart.key === 'tail') {
                const dashBtn = document.getElementById('dash-btn');
                if (dashBtn) {
                    dashBtn.style.opacity = '1';
                    dashBtn.style.borderColor = 'var(--neon-cyan)';
                }
            }
            
            State.data.history.push({ chapter: State.data.history.length + 1, title: `${newPart.name} íšë“`, content: `${newPart.name}ì´(ê°€) ìƒê²¼ë‹¤.`, time: Date.now() });
            saveGame();
        }
    }
};

const updateCellHUD = () => {
    const scoreEl = document.getElementById('hud-score');
    const eatenEl = document.getElementById('hud-eaten');
    if (scoreEl) scoreEl.textContent = State.data.score;
    if (eatenEl) eatenEl.textContent = State.data.stats.eaten;
    
    const sizeFill = document.getElementById('size-fill');
    const sizeText = document.getElementById('size-text');
    if (sizeFill) sizeFill.style.width = `${(player.size / MAX_SIZE) * 100}%`;
    if (sizeText) sizeText.textContent = Math.round(player.size);
    
    const eaten = State.data.stats.eaten;
    const currentBase = getTotalParts() * GROWTH_THRESHOLD;
    const progress = ((eaten - currentBase) / GROWTH_THRESHOLD) * 100;
    
    const partProgress = document.getElementById('part-progress');
    const partText = document.getElementById('part-progress-text');
    if (partProgress) partProgress.style.width = `${Math.min(100, Math.max(0, progress))}%`;
    if (partText) partText.textContent = `${Math.max(0, eaten - currentBase)}/${GROWTH_THRESHOLD}`;
    
    const stageProgress = document.getElementById('stage-progress');
    const stageText = document.getElementById('stage-progress-text');
    if (stageProgress) stageProgress.style.width = `${Math.min(100, (State.data.score / STAGE_THRESHOLD) * 100)}%`;
    if (stageText) stageText.textContent = `${State.data.score}/${STAGE_THRESHOLD}`;
};

const renderCellWorld = (env) => {
    const w = canvas.width, h = canvas.height;
    
    const bg = ctx.createLinearGradient(0, 0, 0, h);
    bg.addColorStop(0, env.colors.bg1);
    bg.addColorStop(1, env.colors.bg2);
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, w, h);
    
    ctx.globalAlpha = 0.2;
    for (let i = 0; i < 40; i++) {
        const x = (Date.now() * 0.01 + i * 97) % (w + 80) - 40;
        const y = (Date.now() * 0.005 + i * 43) % (h + 80) - 40;
        ctx.fillStyle = env.colors.particle;
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
    
    foods.forEach(f => {
        ctx.font = `${f.size * 1.8}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(f.type, f.x, f.y);
    });
    
    enemies.forEach(e => {
        drawCreature(ctx, e.x, e.y, e.size, e.parts, e.size > player.size, env, e.wobble);
    });
    
    particles.forEach(p => {
        ctx.globalAlpha = p.life / 30;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;
    
    drawPlayerCell(player.x, player.y, player.size);
};

const drawCreature = (ctx, x, y, size, parts, isDangerous, env, wobbleOffset = 0) => {
    const time = Date.now() * 0.003;
    
    ctx.save();
    ctx.translate(x, y);
    
    ctx.shadowColor = isDangerous ? '#ff0000' : '#00ff00';
    ctx.shadowBlur = 12;
    
    ctx.beginPath();
    const points = 8;
    for (let i = 0; i < points; i++) {
        const angle = (i / points) * Math.PI * 2;
        const wobble = Math.sin(time + i + wobbleOffset * 10) * 3;
        const r = size + wobble;
        const px = Math.cos(angle) * r;
        const py = Math.sin(angle) * r;
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fillStyle = isDangerous ? env.colors.enemy : env.colors.food;
    ctx.fill();
    ctx.shadowBlur = 0;
    
    const eyeCount = parts.eye || 1;
    for (let i = 0; i < Math.min(eyeCount, 3); i++) {
        const eyeAngle = -0.3 + (i - (eyeCount - 1) / 2) * 0.4;
        const eyeX = Math.cos(eyeAngle) * size * 0.5;
        const eyeY = Math.sin(eyeAngle) * size * 0.5 - size * 0.2;
        
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, size * 0.15, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eyeX + size * 0.03, eyeY, size * 0.07, 0, Math.PI * 2);
        ctx.fillStyle = isDangerous ? '#ff0000' : '#000';
        ctx.fill();
    }
    
    ctx.restore();
};

const drawPlayerCell = (x, y, size) => {
    const design = State.data.design;
    const parts = State.data.bodyParts;
    const time = Date.now() * 0.003;
    
    ctx.save();
    ctx.translate(x, y);
    
    if (isDashing) {
        for (let i = 1; i <= 3; i++) {
            ctx.save();
            ctx.translate(-player.vx * i * 2, -player.vy * i * 2);
            ctx.globalAlpha = 0.3 / i;
            drawPlayerCellBody(size, design, parts, time);
            ctx.restore();
        }
    }
    
    ctx.globalAlpha = 1;
    drawPlayerCellBody(size, design, parts, time);
    ctx.restore();
};

const drawPlayerCellBody = (size, design, parts, time) => {
    ctx.shadowColor = design.primary;
    ctx.shadowBlur = 20;
    
    ctx.beginPath();
    const points = 10;
    for (let i = 0; i < points; i++) {
        const angle = (i / points) * Math.PI * 2;
        const wobble = Math.sin(time + i) * 3 * design.wobble;
        const r = size + wobble;
        const px = Math.cos(angle) * r;
        const py = Math.sin(angle) * r;
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
    
    const grad = ctx.createRadialGradient(-size * 0.3, -size * 0.3, 0, 0, 0, size);
    grad.addColorStop(0, design.primary);
    grad.addColorStop(1, design.secondary);
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.shadowBlur = 0;
    
    ctx.beginPath();
    ctx.arc(-size * 0.25, -size * 0.25, size * 0.18, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fill();
    
    const eyeCount = parts.eye || 0;
    for (let i = 0; i < eyeCount; i++) {
        const eyeAngle = -0.2 + (i - (eyeCount - 1) / 2) * 0.35;
        const eyeX = Math.cos(eyeAngle) * size * 0.45;
        const eyeY = Math.sin(eyeAngle) * size * 0.3 - size * 0.15;
        
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, size * 0.18, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eyeX + size * 0.04, eyeY, size * 0.08, 0, Math.PI * 2);
        ctx.fillStyle = '#111';
        ctx.fill();
    }
    
    const armCount = parts.arm || 0;
    if (armCount > 0) {
        ctx.strokeStyle = design.primary;
        ctx.lineWidth = Math.max(2, size * 0.08);
        ctx.lineCap = 'round';
        for (let i = 0; i < armCount; i++) {
            const baseAngle = (0.3 + i * 0.2) * (i % 2 === 0 ? 1 : -1) * Math.PI;
            const wobble = Math.sin(time * 2 + i) * 0.2;
            ctx.beginPath();
            ctx.moveTo(Math.cos(baseAngle) * size, Math.sin(baseAngle) * size);
            ctx.quadraticCurveTo(
                Math.cos(baseAngle) * size * 1.5,
                Math.sin(baseAngle + wobble) * size * 1.3,
                Math.cos(baseAngle) * size * 1.8,
                Math.sin(baseAngle + wobble * 2) * size
            );
            ctx.stroke();
        }
    }
    
    const legCount = parts.leg || 0;
    if (legCount > 0) {
        ctx.strokeStyle = design.secondary;
        ctx.lineWidth = Math.max(2, size * 0.06);
        for (let i = 0; i < legCount; i++) {
            const baseAngle = Math.PI * 0.5 + (i - (legCount - 1) / 2) * 0.25;
            const wobble = Math.sin(time * 3 + i) * 0.15;
            ctx.beginPath();
            ctx.moveTo(Math.cos(baseAngle) * size * 0.8, Math.sin(baseAngle) * size * 0.8);
            ctx.lineTo(Math.cos(baseAngle + wobble) * size * 1.5, Math.sin(baseAngle) * size * 1.4);
            ctx.stroke();
        }
    }
    
    const tailCount = parts.tail || 0;
    if (tailCount > 0) {
        ctx.strokeStyle = design.primary;
        ctx.lineWidth = Math.max(3, size * 0.1);
        ctx.lineCap = 'round';
        for (let i = 0; i < tailCount; i++) {
            const tailWobble = Math.sin(time * 2 + i) * size * 0.3;
            const offsetY = (i - (tailCount - 1) / 2) * size * 0.15;
            ctx.beginPath();
            ctx.moveTo(-size * 0.8, offsetY);
            ctx.bezierCurveTo(-size * 1.3, tailWobble + offsetY, -size * 1.6, -tailWobble * 0.5 + offsetY, -size * 2, tailWobble * 0.3 + offsetY);
            ctx.stroke();
        }
    }
};

const gameOverCell = () => {
    cancelAnimationFrame(gameLoop);
    gameLoop = null;
    
    Audio.playDeath();
    State.data.stats.deaths++;
    saveGame();
    
    app.innerHTML = `
        <div class="gameover-modal">
            <div class="gameover-content">
                <div class="gameover-icon">ğŸ’€</div>
                <h1 class="gameover-title">ì¡ì•„ë¨¹í˜”ë‹¤!</h1>
                <p class="gameover-desc">ë” í° ì¡´ì¬ì—ê²Œ í¬ì‹ë‹¹í–ˆìŠµë‹ˆë‹¤.<br>ë‹¤ì‹œ ìš´ëª…ì˜ ì£¼ì‚¬ìœ„ë¥¼ êµ´ë ¤ì•¼ í•©ë‹ˆë‹¤.</p>
                
                <div class="gameover-stats">
                    <div class="gameover-stat">
                        <span class="gameover-stat-label">ìµœì¢… ì ìˆ˜</span>
                        <span class="gameover-stat-value">${State.data.score}</span>
                    </div>
                    <div class="gameover-stat">
                        <span class="gameover-stat-label">íšë“ íŒŒì¸ </span>
                        <span class="gameover-stat-value">${getTotalParts()}ê°œ</span>
                    </div>
                    <div class="gameover-stat">
                        <span class="gameover-stat-label">ì‚¬ë§ íšŸìˆ˜</span>
                        <span class="gameover-stat-value">${State.data.stats.deaths}</span>
                    </div>
                </div>
                
                <div style="display:flex;flex-direction:column;gap:12px;">
                    <button class="btn btn-energy btn-block" id="btn-retry">ğŸ² ë‹¤ì‹œ ì‹œì‘</button>
                    <button class="btn btn-outline btn-block" id="btn-home">ğŸ  í™ˆìœ¼ë¡œ</button>
                </div>
            </div>
        </div>
    `;
    
    document.getElementById('btn-retry').onclick = () => {
        Audio.playClick();
        State.data.stage = 0;
        State.data.tutorialDone = false;
        State.data.score = 0;
        State.data.dna = { origin: null, traits: [] };
        State.data.design = null;
        State.data.bodyParts = { eye: 0, mouth: 0, arm: 0, leg: 0, tail: 0, ear: 0, nose: 0, antenna: 0 };
        State.data.stats = { size: INITIAL_SIZE, speed: 3, eaten: 0, deaths: State.data.stats.deaths, maxSize: INITIAL_SIZE, maxHeight: 0 };
        saveGame();
        renderDiceRoll();
    };
    
    document.getElementById('btn-home').onclick = () => {
        Audio.playClick();
        renderSaveSelect();
    };
};

const evolveToMulticellular = () => {
    cancelAnimationFrame(gameLoop);
    gameLoop = null;
    
    // stageë¥¼ 2ë¡œ ë³€ê²½í•˜ì—¬ ë‹¤ì‹œ íŠ¸ë¦¬ê±°ë˜ì§€ ì•Šë„ë¡ í•¨
    State.data.stage = 2;
    State.data.history.push({ chapter: State.data.history.length + 1, title: 'ë‹¤ì„¸í¬ ì§„í™”', content: 'ë‹¨ì¼ ì„¸í¬ì˜ í•œê³„ë¥¼ ë„˜ì–´ì„°ë‹¤.', time: Date.now() });
    saveGame();
    
    Audio.playEvolve();
    
    // ìŠ¤í† ë¦¬ ì‹œí€€ìŠ¤ ì¬ìƒ í›„ ë¯¸ë‹ˆê²Œì„ìœ¼ë¡œ ì´ë™
    renderStory('multicellular');
};

/* ========================================
   Climb Game (Stage 2) - ìœ¡ì§€ ì˜¬ë¼ê°€ê¸°
======================================== */
let climbPlayer = null;
let platforms = [];
let climbParticles = [];
let cameraY = 0;
let currentHeight = 0;
let isJumping = false;
let canDoubleJump = false;

const startClimbGame = () => {
    const env = getEnvById(State.data.dna.origin);
    
    app.innerHTML = `
        <canvas id="game-canvas"></canvas>
        
        <div class="climb-hud">
            <div class="climb-info">
                <div class="climb-height" id="climb-height">0m</div>
                <div class="climb-height-label">í˜„ì¬ ë†’ì´</div>
            </div>
            
            <div class="hud-buttons">
                <button class="hud-btn" id="btn-home">ğŸ </button>
                <button class="hud-btn" id="btn-pause">â¸ï¸</button>
            </div>
            
            <div class="climb-goal">
                <div class="climb-goal-text">ğŸ”ï¸ ìœ¡ì§€ê¹Œì§€</div>
                <div class="climb-goal-value" id="climb-goal">${LAND_HEIGHT}m</div>
            </div>
        </div>
        
        <div class="mobile-controls">
            <div class="joystick-container" id="joystick">
                <div class="joystick-base"></div>
                <div class="joystick-knob" id="joystick-knob"></div>
            </div>
            <button class="action-btn" id="jump-btn">ğŸ¦˜</button>
        </div>
    `;
    
    canvas = document.getElementById('game-canvas');
    ctx = canvas.getContext('2d');
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // í”Œë ˆì´ì–´ ì´ˆê¸°í™”
    climbPlayer = {
        x: canvas.width / 2,
        y: canvas.height - 100,
        width: 30 + getTotalParts() * 2,
        height: 30 + getTotalParts() * 2,
        vx: 0,
        vy: 0,
        onGround: true
    };
    
    // ë°œíŒ ìƒì„±
    platforms = [];
    generatePlatforms(0, canvas.height * 3);
    
    // ì‹œì‘ ë°œíŒ
    platforms.push({
        x: canvas.width / 2 - 60,
        y: canvas.height - 50,
        width: 120,
        height: 15,
        type: 'normal'
    });
    
    cameraY = 0;
    currentHeight = 0;
    climbParticles = [];
    
    setupClimbControls();
    setupClimbHUDEvents();
    
    gameLoop = requestAnimationFrame(updateClimbGame);
};

const generatePlatforms = (fromY, toY) => {
    let y = fromY - 80;
    
    while (y > toY) {
        const numPlatforms = 1 + Math.floor(Math.random() * 2);
        
        for (let i = 0; i < numPlatforms; i++) {
            const width = 60 + Math.random() * 60;
            const x = Math.random() * (canvas.width - width);
            
            // ë°œíŒ íƒ€ì… (ë†’ì´ì— ë”°ë¼ ë‹¤ì–‘í•´ì§)
            let type = 'normal';
            const heightRatio = Math.abs(y) / LAND_HEIGHT;
            if (heightRatio > 0.3 && Math.random() < 0.2) type = 'moving';
            if (heightRatio > 0.5 && Math.random() < 0.15) type = 'breaking';
            if (heightRatio > 0.7 && Math.random() < 0.1) type = 'bouncy';
            
            platforms.push({
                x, y, width,
                height: 12,
                type,
                moveDir: Math.random() < 0.5 ? 1 : -1,
                moveSpeed: 1 + Math.random() * 2,
                broken: false,
                breakTimer: 0
            });
        }
        
        y -= 60 + Math.random() * 40;
    }
    
    // ìœ¡ì§€ (ê³¨ì¸ ì§€ì )
    if (toY <= -LAND_HEIGHT * 10) {
        platforms.push({
            x: 0,
            y: -LAND_HEIGHT * 10 - 50,
            width: canvas.width,
            height: 100,
            type: 'land'
        });
    }
};

const setupClimbControls = () => {
    const joystick = document.getElementById('joystick');
    const knob = document.getElementById('joystick-knob');
    
    const handleMove = (cx, cy) => {
        const r = joystick.getBoundingClientRect();
        const centerX = r.left + r.width / 2;
        const centerY = r.top + r.height / 2;
        const maxDist = r.width / 2 - 22;
        
        let dx = cx - centerX;
        let dy = cy - centerY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }
        
        knob.style.transform = `translate(${dx}px, ${dy}px)`;
        joystickPos = { x: dx / maxDist, y: dy / maxDist };
    };
    
    const handleEnd = () => { joystickActive = false; knob.style.transform = ''; joystickPos = { x: 0, y: 0 }; };
    
    joystick.addEventListener('touchstart', (e) => { e.preventDefault(); joystickActive = true; handleMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    joystick.addEventListener('touchmove', (e) => { e.preventDefault(); if (joystickActive) handleMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    joystick.addEventListener('touchend', handleEnd);
    joystick.addEventListener('touchcancel', handleEnd);
    
    joystick.addEventListener('mousedown', (e) => { joystickActive = true; handleMove(e.clientX, e.clientY); });
    window.addEventListener('mousemove', (e) => { if (joystickActive) handleMove(e.clientX, e.clientY); });
    window.addEventListener('mouseup', handleEnd);
    
    const jump = () => {
        if (climbPlayer.onGround) {
            climbPlayer.vy = -15;
            climbPlayer.onGround = false;
            canDoubleJump = hasPart('leg') && getPartCount('leg') >= 2;
            Audio.playJump();
        } else if (canDoubleJump) {
            climbPlayer.vy = -12;
            canDoubleJump = false;
            Audio.playJump();
            
            // ë”ë¸”ì í”„ íŒŒí‹°í´
            for (let i = 0; i < 5; i++) {
                climbParticles.push({
                    x: climbPlayer.x + climbPlayer.width / 2,
                    y: climbPlayer.y + climbPlayer.height,
                    vx: (Math.random() - 0.5) * 4,
                    vy: 2 + Math.random() * 2,
                    size: 4,
                    color: State.data.design.primary,
                    life: 20
                });
            }
        }
    };
    
    window.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') jump();
    });
    window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
    
    document.getElementById('jump-btn').addEventListener('touchstart', (e) => { e.preventDefault(); jump(); });
    document.getElementById('jump-btn').addEventListener('click', jump);
};

const setupClimbHUDEvents = () => {
    document.getElementById('btn-home').onclick = () => {
        Audio.playClick();
        if (confirm('í™ˆìœ¼ë¡œ ëŒì•„ê°€ì‹œê² ìŠµë‹ˆê¹Œ?')) {
            cancelAnimationFrame(gameLoop);
            gameLoop = null;
            saveGame();
            renderSaveSelect();
        }
    };
    
    document.getElementById('btn-pause').onclick = () => {
        Audio.playClick();
        if (gameLoop) {
            cancelAnimationFrame(gameLoop);
            gameLoop = null;
            document.getElementById('btn-pause').textContent = 'â–¶ï¸';
            toast('ì¼ì‹œì •ì§€', 'info');
        } else {
            gameLoop = requestAnimationFrame(updateClimbGame);
            document.getElementById('btn-pause').textContent = 'â¸ï¸';
        }
    };
};

const updateClimbGame = () => {
    if (!canvas || !ctx) return;
    
    const env = getEnvById(State.data.dna.origin);
    
    // ì¢Œìš° ì´ë™
    let moveX = joystickPos.x;
    if (keys.a || keys.arrowleft) moveX = -1;
    if (keys.d || keys.arrowright) moveX = 1;
    
    const moveSpeed = 5 + getPartCount('leg') * 0.5;
    climbPlayer.vx = moveX * moveSpeed;
    
    // ì¤‘ë ¥
    climbPlayer.vy += 0.6;
    if (climbPlayer.vy > 15) climbPlayer.vy = 15;
    
    // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
    climbPlayer.x += climbPlayer.vx;
    climbPlayer.y += climbPlayer.vy;
    
    // í™”ë©´ ê²½ê³„
    if (climbPlayer.x < 0) climbPlayer.x = 0;
    if (climbPlayer.x + climbPlayer.width > canvas.width) climbPlayer.x = canvas.width - climbPlayer.width;
    
    // ë°œíŒ ì¶©ëŒ
    climbPlayer.onGround = false;
    
    platforms.forEach(p => {
        if (p.broken) return;
        
        // ì›€ì§ì´ëŠ” ë°œíŒ
        if (p.type === 'moving') {
            p.x += p.moveDir * p.moveSpeed;
            if (p.x <= 0 || p.x + p.width >= canvas.width) p.moveDir *= -1;
        }
        
        // ì¶©ëŒ ì²´í¬ (ìœ„ì—ì„œ ë–¨ì–´ì§ˆ ë•Œë§Œ)
        if (climbPlayer.vy > 0 &&
            climbPlayer.x + climbPlayer.width > p.x &&
            climbPlayer.x < p.x + p.width &&
            climbPlayer.y + climbPlayer.height > p.y &&
            climbPlayer.y + climbPlayer.height < p.y + p.height + 15) {
            
            climbPlayer.y = p.y - climbPlayer.height;
            climbPlayer.vy = 0;
            climbPlayer.onGround = true;
            canDoubleJump = hasPart('leg') && getPartCount('leg') >= 2;
            
            // ë°œíŒ íƒ€ì…ë³„ íš¨ê³¼
            if (p.type === 'bouncy') {
                climbPlayer.vy = -20;
                climbPlayer.onGround = false;
                Audio.playJump();
            } else if (p.type === 'breaking') {
                p.breakTimer++;
                if (p.breakTimer > 30) {
                    p.broken = true;
                    Audio.playDeath();
                }
            } else if (p.type === 'land') {
                // ìœ¡ì§€ ë„ì°©!
                climbSuccess();
                return;
            }
            
            // ì›€ì§ì´ëŠ” ë°œíŒ ìœ„ì—ì„œ
            if (p.type === 'moving') {
                climbPlayer.x += p.moveDir * p.moveSpeed;
            }
        }
    });
    
    // ì¹´ë©”ë¼ ë”°ë¼ê°€ê¸°
    const targetCameraY = -climbPlayer.y + canvas.height * 0.6;
    cameraY += (targetCameraY - cameraY) * 0.1;
    
    // í˜„ì¬ ë†’ì´ ê³„ì‚°
    currentHeight = Math.max(0, Math.floor(-climbPlayer.y / 10));
    State.data.stats.maxHeight = Math.max(State.data.stats.maxHeight, currentHeight);
    
    // ìƒˆ ë°œíŒ ìƒì„±
    const highestPlatform = Math.min(...platforms.map(p => p.y));
    if (-cameraY - canvas.height < highestPlatform + 500) {
        generatePlatforms(highestPlatform, highestPlatform - canvas.height * 2);
    }
    
    // ë‚™í•˜ ì²´í¬
    if (climbPlayer.y > -cameraY + canvas.height + 100) {
        climbFall();
        return;
    }
    
    // íŒŒí‹°í´ ì—…ë°ì´íŠ¸
    climbParticles = climbParticles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.size *= 0.95;
        return p.life > 0;
    });
    
    // ë Œë”ë§
    renderClimbGame(env);
    
    // HUD ì—…ë°ì´íŠ¸
    document.getElementById('climb-height').textContent = currentHeight + 'm';
    
    gameLoop = requestAnimationFrame(updateClimbGame);
};

const renderClimbGame = (env) => {
    const w = canvas.width, h = canvas.height;
    
    // ë°°ê²½ (ë†’ì´ì— ë”°ë¼ ë³€í™”)
    const heightRatio = Math.min(1, currentHeight / LAND_HEIGHT);
    
    // ë°”ë‹¤ â†’ í•˜ëŠ˜ ê·¸ë¼ë°ì´ì…˜
    const bg = ctx.createLinearGradient(0, 0, 0, h);
    if (heightRatio < 0.5) {
        bg.addColorStop(0, lerpColor(env.colors.bg1, '#1a3a5e', heightRatio * 2));
        bg.addColorStop(1, lerpColor(env.colors.bg2, '#0a2040', heightRatio * 2));
    } else {
        bg.addColorStop(0, lerpColor('#1a3a5e', '#87CEEB', (heightRatio - 0.5) * 2));
        bg.addColorStop(1, lerpColor('#0a2040', '#E0F7FA', (heightRatio - 0.5) * 2));
    }
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, w, h);
    
    // ë°°ê²½ íŒŒí‹°í´
    ctx.globalAlpha = 0.3;
    for (let i = 0; i < 30; i++) {
        const x = (Date.now() * 0.02 + i * 73) % (w + 40) - 20;
        const y = ((Date.now() * 0.01 + i * 31 + cameraY * 0.5) % (h + 40) - 20);
        ctx.fillStyle = heightRatio < 0.5 ? env.colors.particle : '#ffffff';
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
    
    ctx.save();
    ctx.translate(0, cameraY);
    
    // ë°œíŒ ê·¸ë¦¬ê¸°
    platforms.forEach(p => {
        if (p.broken) return;
        
        const screenY = p.y + cameraY;
        if (screenY < -50 || screenY > h + 50) return;
        
        ctx.fillStyle = getPlatformColor(p.type, heightRatio);
        
        if (p.type === 'land') {
            // ìœ¡ì§€
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(p.x, p.y, p.width, p.height);
            
            // ì”ë””
            ctx.fillStyle = '#228B22';
            ctx.fillRect(p.x, p.y, p.width, 20);
            
            // ë‚˜ë¬´
            for (let i = 0; i < 5; i++) {
                const tx = p.x + 50 + i * (p.width / 5);
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(tx, p.y - 40, 10, 40);
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.arc(tx + 5, p.y - 50, 25, 0, Math.PI * 2);
                ctx.fill();
            }
        } else {
            // ì¼ë°˜ ë°œíŒ
            ctx.beginPath();
            ctx.roundRect(p.x, p.y, p.width, p.height, 6);
            ctx.fill();
            
            // ë°œíŒ í•˜ì´ë¼ì´íŠ¸
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(p.x + 4, p.y + 2, p.width - 8, 4);
        }
        
        // ë¶€ì„œì§€ëŠ” ë°œíŒ í‘œì‹œ
        if (p.type === 'breaking' && p.breakTimer > 0) {
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(p.x, p.y, p.width, p.height);
            ctx.setLineDash([]);
        }
    });
    
    // íŒŒí‹°í´
    climbParticles.forEach(p => {
        ctx.globalAlpha = p.life / 20;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;
    
    // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
    drawClimbPlayer();
    
    ctx.restore();
    
    // ë†’ì´ ê²Œì´ì§€ (ì˜¤ë¥¸ìª½)
    const gaugeHeight = h - 100;
    const gaugeX = w - 30;
    const progress = Math.min(1, currentHeight / LAND_HEIGHT);
    
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(gaugeX - 5, 50, 20, gaugeHeight);
    
    ctx.fillStyle = 'var(--gradient-energy)';
    const fill = ctx.createLinearGradient(0, 50 + gaugeHeight, 0, 50);
    fill.addColorStop(0, '#00f5d4');
    fill.addColorStop(1, '#fee440');
    ctx.fillStyle = fill;
    ctx.fillRect(gaugeX - 3, 50 + gaugeHeight * (1 - progress), 16, gaugeHeight * progress);
    
    // ê³¨ ë§ˆì»¤
    ctx.fillStyle = '#228B22';
    ctx.fillRect(gaugeX - 8, 45, 26, 10);
    ctx.fillStyle = 'white';
    ctx.font = '10px Orbitron';
    ctx.textAlign = 'center';
    ctx.fillText('ğŸ”ï¸', gaugeX + 5, 53);
};

const getPlatformColor = (type, heightRatio) => {
    switch (type) {
        case 'moving': return '#9d4edd';
        case 'breaking': return '#ef4444';
        case 'bouncy': return '#10b981';
        default:
            // ë†’ì´ì— ë”°ë¼ ìƒ‰ìƒ ë³€í™”
            if (heightRatio < 0.3) return '#00b4d8';
            if (heightRatio < 0.6) return '#48cae4';
            if (heightRatio < 0.9) return '#90e0ef';
            return '#caf0f8';
    }
};

const lerpColor = (a, b, t) => {
    const ah = parseInt(a.replace('#', ''), 16);
    const bh = parseInt(b.replace('#', ''), 16);
    
    const ar = ah >> 16, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
    const br = bh >> 16, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
    
    const rr = Math.round(ar + (br - ar) * t);
    const rg = Math.round(ag + (bg - ag) * t);
    const rb = Math.round(ab + (bb - ab) * t);
    
    return `#${((rr << 16) | (rg << 8) | rb).toString(16).padStart(6, '0')}`;
};

const drawClimbPlayer = () => {
    const design = State.data.design;
    const parts = State.data.bodyParts;
    const time = Date.now() * 0.005;
    
    ctx.save();
    ctx.translate(climbPlayer.x + climbPlayer.width / 2, climbPlayer.y + climbPlayer.height / 2);
    
    // ëª¸ì²´
    ctx.shadowColor = design.primary;
    ctx.shadowBlur = 15;
    
    const size = climbPlayer.width / 2;
    
    ctx.beginPath();
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const wobble = Math.sin(time + i) * 2;
        const r = size + wobble;
        const px = Math.cos(angle) * r;
        const py = Math.sin(angle) * r;
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
    
    const grad = ctx.createRadialGradient(-size * 0.3, -size * 0.3, 0, 0, 0, size);
    grad.addColorStop(0, design.primary);
    grad.addColorStop(1, design.secondary);
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // ëˆˆ
    const eyeCount = parts.eye || 0;
    for (let i = 0; i < eyeCount; i++) {
        const eyeAngle = (i - (eyeCount - 1) / 2) * 0.4;
        const eyeX = eyeAngle * size * 0.8;
        const eyeY = -size * 0.3;
        
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, size * 0.25, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eyeX + 2, eyeY, size * 0.12, 0, Math.PI * 2);
        ctx.fillStyle = '#111';
        ctx.fill();
    }
    
    // ë‹¤ë¦¬ (ë›°ëŠ” ëª¨ì…˜)
    const legCount = parts.leg || 0;
    if (legCount > 0) {
        ctx.strokeStyle = design.secondary;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        
        const jumpPhase = climbPlayer.onGround ? 0 : Math.sin(time * 3);
        
        for (let i = 0; i < legCount; i++) {
            const baseAngle = Math.PI * 0.5 + (i - (legCount - 1) / 2) * 0.3;
            const kickAngle = jumpPhase * 0.3;
            
            ctx.beginPath();
            ctx.moveTo(Math.cos(baseAngle) * size * 0.7, Math.sin(baseAngle) * size * 0.7);
            ctx.lineTo(Math.cos(baseAngle + kickAngle) * size * 1.3, Math.sin(baseAngle) * size * 1.2);
            ctx.stroke();
        }
    }
    
    ctx.restore();
};

const climbFall = () => {
    cancelAnimationFrame(gameLoop);
    gameLoop = null;
    
    Audio.playDeath();
    
    app.innerHTML = `
        <div class="gameover-modal">
            <div class="gameover-content">
                <div class="gameover-icon">ğŸ’§</div>
                <h1 class="gameover-title">ì¶”ë½!</h1>
                <p class="gameover-desc">ë°”ë‹¤ë¡œ ë‹¤ì‹œ ë–¨ì–´ì¡ŒìŠµë‹ˆë‹¤...<br>ë‹¤ì‹œ ì˜¬ë¼ê°€ì•¼ í•©ë‹ˆë‹¤!</p>
                
                <div class="gameover-stats">
                    <div class="gameover-stat">
                        <span class="gameover-stat-label">ë„ë‹¬ ë†’ì´</span>
                        <span class="gameover-stat-value">${currentHeight}m</span>
                    </div>
                    <div class="gameover-stat">
                        <span class="gameover-stat-label">ìµœê³  ê¸°ë¡</span>
                        <span class="gameover-stat-value">${State.data.stats.maxHeight}m</span>
                    </div>
                </div>
                
                <div style="display:flex;flex-direction:column;gap:12px;">
                    <button class="btn btn-energy btn-block" id="btn-retry">ğŸ”„ ë‹¤ì‹œ ì‹œë„</button>
                    <button class="btn btn-outline btn-block" id="btn-home">ğŸ  í™ˆìœ¼ë¡œ</button>
                </div>
            </div>
        </div>
    `;
    
    saveGame();
    
    document.getElementById('btn-retry').onclick = () => {
        Audio.playClick();
        startClimbGame();
    };
    
    document.getElementById('btn-home').onclick = () => {
        Audio.playClick();
        renderSaveSelect();
    };
};

const climbSuccess = () => {
    cancelAnimationFrame(gameLoop);
    gameLoop = null;
    
    Audio.playWin();
    
    State.data.stage = 3;
    State.data.history.push({ chapter: State.data.history.length + 1, title: 'ìœ¡ì§€ ë„ë‹¬', content: 'ë§ˆì¹¨ë‚´ ìœ¡ì§€ì— ë°œì„ ë””ë ë‹¤!', time: Date.now() });
    saveGame();
    
    app.innerHTML = `
        <div class="gameover-modal">
            <div class="gameover-content">
                <div class="gameover-icon">ğŸ”ï¸</div>
                <h1 class="gameover-title success">ìœ¡ì§€ ë„ë‹¬!</h1>
                <p class="gameover-desc">ë§ˆì¹¨ë‚´ ë°”ë‹¤ë¥¼ ë²—ì–´ë‚˜ ìœ¡ì§€ì— ë„ì°©í–ˆìŠµë‹ˆë‹¤!<br><br>ìƒˆë¡œìš´ ì„¸ê³„ê°€ ë‹¹ì‹ ì„ ê¸°ë‹¤ë¦¬ê³  ìˆìŠµë‹ˆë‹¤...</p>
                
                <div class="gameover-stats">
                    <div class="gameover-stat">
                        <span class="gameover-stat-label">ì´ ì´ë™ ê±°ë¦¬</span>
                        <span class="gameover-stat-value">${LAND_HEIGHT}m</span>
                    </div>
                    <div class="gameover-stat">
                        <span class="gameover-stat-label">íšë“ íŒŒì¸ </span>
                        <span class="gameover-stat-value">${getTotalParts()}ê°œ</span>
                    </div>
                </div>
                
                <div style="display:flex;flex-direction:column;gap:12px;">
                    <button class="btn btn-energy btn-block" id="btn-continue">ğŸŒ ë‹¤ìŒ ë‹¨ê³„ (ì¤€ë¹„ ì¤‘)</button>
                    <button class="btn btn-outline btn-block" id="btn-home">ğŸ  í™ˆìœ¼ë¡œ</button>
                </div>
            </div>
        </div>
    `;
    
    document.getElementById('btn-continue').onclick = () => {
        Audio.playClick();
        toast('ë‹¤ìŒ ë‹¨ê³„ëŠ” ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤!', 'info');
    };
    
    document.getElementById('btn-home').onclick = () => {
        Audio.playClick();
        renderSaveSelect();
    };
};

/* ========================================
   Pages
======================================== */
const renderTitle = () => {
    app.innerHTML = `
        <div class="title-page">
            <div class="title-logo">ğŸ²</div>
            <h1 class="title-main">BOKLUCK</h1>
            <h2 class="title-sub">Universe</h2>
            <p class="title-tagline">
                <strong style="color:var(--neon-cyan)">BOK(ë³µ)</strong> ë˜ëŠ” 
                <strong style="color:var(--neon-pink)">LUCK(ìš´)</strong>ìœ¼ë¡œ<br>
                ë§Œë“¤ì–´ê°€ëŠ” ë‹¹ì‹ ë§Œì˜ ìš°ì£¼ ì´ì•¼ê¸°
            </p>
            <div class="title-buttons">
                <button class="btn btn-energy btn-block" id="btn-start">ğŸš€ ê²Œì„ ì‹œì‘</button>
                <button class="btn btn-outline btn-block" id="btn-settings">âš™ï¸ ì„¤ì •</button>
            </div>
        </div>
    `;
    
    document.getElementById('btn-start').onclick = () => { Audio.init(); Audio.playClick(); renderSaveSelect(); };
    document.getElementById('btn-settings').onclick = () => { Audio.init(); Audio.playClick(); renderSettings(); };
};

const renderSaveSelect = () => {
    const slots = Save.all();
    
    let slotsHTML = '';
    for (let i = 0; i < Save.MAX; i++) {
        const s = slots[i];
        if (s) {
            const stageText = s.stage === 1 ? 'ì„¸í¬' : s.stage === 2 ? 'ë‹¤ì„¸í¬' : s.stage === 3 ? 'ìœ¡ì§€' : 'ì‹œì‘ì „';
            slotsHTML += `
                <div class="save-slot">
                    <div class="save-slot-header">
                        <span class="save-slot-number">ìŠ¬ë¡¯ ${i + 1}</span>
                        <span style="font-size:0.7rem;color:var(--text-muted)">${Save.formatDate(s.updated)}</span>
                    </div>
                    <div class="save-slot-name">${s.name || 'ì´ë¦„ ì—†ìŒ'}</div>
                    <div class="save-slot-info">
                        ${s.dna?.origin ? getEnvById(s.dna.origin)?.icon : 'â“'} ${stageText}
                        Â· ì ìˆ˜: ${s.score || 0}
                        Â· íŒŒì¸ : ${s.bodyParts ? Object.values(s.bodyParts).reduce((a,b)=>a+b,0) : 0}ê°œ
                    </div>
                    <div class="save-slot-actions">
                        <button class="btn btn-energy btn-sm" style="flex:1" onclick="handleLoadSlot(${i})">â–¶ï¸ ê³„ì†</button>
                        <button class="delete-btn" onclick="handleDeleteSlot(${i})">ğŸ—‘ï¸</button>
                    </div>
                </div>
            `;
        } else {
            slotsHTML += `
                <div class="save-slot empty" onclick="handleNewSlot(${i})">
                    <span style="font-size:1.8rem;opacity:0.5">â•</span>
                    <p style="color:var(--text-muted);margin-top:6px;font-size:0.85rem;">ìŠ¬ë¡¯ ${i + 1} - ìƒˆ ê²Œì„</p>
                </div>
            `;
        }
    }
    
    app.innerHTML = `
        <div class="save-page">
            <div class="save-header">
                <button class="btn btn-ghost btn-sm" id="btn-back">â† ë’¤ë¡œ</button>
                <h1 class="save-title">ğŸ’¾ ì €ì¥ ìŠ¬ë¡¯</h1>
                <div style="width:60px"></div>
            </div>
            <div class="save-slots">
                ${slotsHTML}
            </div>
        </div>
    `;
    
    document.getElementById('btn-back').onclick = () => { Audio.playClick(); renderTitle(); };
};

// ì „ì—­ í•¨ìˆ˜ë¡œ ì •ì˜í•˜ì—¬ onclickì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•˜ê²Œ
window.handleNewSlot = (i) => {
    Audio.playClick();
    newGame(i);
    renderStory('intro');
};

window.handleLoadSlot = (i) => {
    Audio.playClick();
    loadSlot(i);
    
    if (!State.data.tutorialDone) {
        renderStory('intro');
    } else if (State.data.stage === 1) {
        startCellWorld();
    } else if (State.data.stage === 2) {
        startClimbGame();
    } else if (State.data.stage === 3) {
        // ìœ¡ì§€ ë„ë‹¬ í›„ - ì¼ë‹¨ í´ë¼ì´ë° ë‹¤ì‹œ
        startClimbGame();
    } else {
        renderDiceRoll();
    }
};

window.handleDeleteSlot = (i) => {
    Audio.playClick();
    if (confirm('ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')) {
        Save.del(i);
        renderSaveSelect();
    }
};

const renderSettings = () => {
    app.innerHTML = `
        <div class="settings-modal">
            <div class="settings-content">
                <h2 class="settings-title">âš™ï¸ ì„¤ì •</h2>
                <div class="settings-section">
                    <div class="settings-section-title">ğŸ”Š ì‚¬ìš´ë“œ</div>
                    <div class="settings-row">
                        <span>ë§ˆìŠ¤í„° ë³¼ë¥¨</span>
                        <input type="range" class="volume-slider" id="vol-master" min="0" max="100" value="${Audio.settings.master * 100}">
                    </div>
                    <div class="settings-row">
                        <span>íš¨ê³¼ìŒ</span>
                        <div style="display:flex;align-items:center;gap:10px">
                            <input type="range" class="volume-slider" id="vol-sfx" min="0" max="100" value="${Audio.settings.sfx * 100}">
                            <div class="toggle ${Audio.settings.sfxOn ? 'active' : ''}" id="toggle-sfx"><div class="toggle-knob"></div></div>
                        </div>
                    </div>
                </div>
                <div class="settings-section">
                    <div class="settings-section-title">ğŸ® í…ŒìŠ¤íŠ¸</div>
                    <div class="settings-row">
                        <span>íš¨ê³¼ìŒ í…ŒìŠ¤íŠ¸</span>
                        <button class="btn btn-outline btn-sm" id="test-sfx">ğŸ”” ì¬ìƒ</button>
                    </div>
                </div>
                <button class="btn btn-energy btn-block" id="btn-close" style="margin-top:20px">í™•ì¸</button>
            </div>
        </div>
    `;
    
    document.getElementById('vol-master').oninput = (e) => { Audio.settings.master = e.target.value / 100; Audio.save(); };
    document.getElementById('vol-sfx').oninput = (e) => { Audio.settings.sfx = e.target.value / 100; Audio.save(); };
    document.getElementById('toggle-sfx').onclick = (e) => { Audio.settings.sfxOn = !Audio.settings.sfxOn; e.currentTarget.classList.toggle('active'); Audio.save(); };
    document.getElementById('test-sfx').onclick = () => { Audio.init(); Audio.playEvolve(); };
    document.getElementById('btn-close').onclick = () => { Audio.playClick(); renderTitle(); };
};

/* ========================================
   Initialize
======================================== */
document.addEventListener('DOMContentLoaded', () => {
    createStars();
    renderTitle();
    setInterval(saveGame, 30000);
    window.addEventListener('beforeunload', saveGame);
    console.log('ğŸ² BOKLUCK Universe v0.5.0');
});
</script>
</body>
</html>
